<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>tdd on BUF1024!!!</title>
    <link>https://luoguochun.cn/tags/tdd/</link>
    <description>Recent content in tdd on BUF1024!!!</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 11 Jan 2014 23:48:14 +0000</lastBuildDate><atom:link href="https://luoguochun.cn/tags/tdd/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>C 简单单元测试框架</title>
      <link>https://luoguochun.cn/post/2014-01-11-ctest/</link>
      <pubDate>Sat, 11 Jan 2014 23:48:14 +0000</pubDate>
      
      <guid>https://luoguochun.cn/post/2014-01-11-ctest/</guid>
      <description>&lt;p&gt;大约2年前，仿照GTEST写了个简单的C++单元测试框架。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://luoguochun.cn/2012/02/09/simple-c++-test-framework/&#34;&gt;https://luoguochun.cn/2012/02/09/simple-c++-test-framework/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;后来用C写后台程序比较多了，C++那个框架却不怎么好用了，于是又写了个C的。&lt;/p&gt;
&lt;p&gt;功能和作用和C++的一模一样，并尽量做到用法和C++的一样。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/buf1024/ctest&#34;&gt;https://github.com/buf1024/ctest&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Very Very Simple C&#43;&#43; Testing Framework</title>
      <link>https://luoguochun.cn/post/2012-02-09-simple-c&#43;&#43;-test-framework/</link>
      <pubDate>Thu, 09 Feb 2012 20:50:00 +0000</pubDate>
      
      <guid>https://luoguochun.cn/post/2012-02-09-simple-c&#43;&#43;-test-framework/</guid>
      <description>&lt;h3 id=&#34;简介&#34;&gt;简介 &lt;a href=&#34;#%e7%ae%80%e4%bb%8b&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;测试驱动开发(TDD)是敏捷开发的一种方法，TDD的一个重要的工具就是单元测试(Unit Test)。如果想详细了解什么是TDD和单元测试请GOOGLE之。简单来和简略地说TDD是在测试驱动下的开发，先写完成测试然后努力使测试通过。单元测试大体包括下面所说的断言，测试固件（非常不喜欢国人这样翻译）和测试环境。&lt;/p&gt;
&lt;p&gt;C++单元测试框架google 的&lt;a href=&#34;http://code.google.com/p/googletest/&#34;&gt;gtest&lt;/a&gt;是其中的不错一款，本测试框架是模仿它的。为什么不直接用它而要模仿它？因为公司不允许（允许但过程很麻烦）使用第三方的库，而公司又要求作单元测试，于是这个东西就写了出来。&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;小，只有一个头文件，其实你会觉得很啰嗦。&lt;/li&gt;
&lt;li&gt;使用方法和GTEST一样，当然也没那么全。&lt;/li&gt;
&lt;li&gt;跨平台&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下载：&lt;a href=&#34;https://github.com/buf1024/mydoc/blob/master/tmpcode/test.h&#34;&gt;test.h&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;断言test-assertion&#34;&gt;断言(Test Assertion) &lt;a href=&#34;#%e6%96%ad%e8%a8%80test-assertion&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;断言包括两种，一种是以EXPECT_XXX，一种是ASSERT_XX，前者即使断言不通过，继续执行此测试用例下面的测试，后都则立即停止执行当前的测试用例。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;断言宏&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;EXPECT_EQ/ASSERT_EQ&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;期待数值相等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EXPECT_NEQ/ASSERT_NEQ&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;期待数值不相等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EXPECT_STREQ/ASSERT_STREQ&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;期待字符串相等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EXPECT_STRNEQ/ASSERT_STRNEQ&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;期待字符串不相等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EXPECT_BINEQ/ASSERT_BINEQ&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;期待二进制相等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EXPECT_BINNEQ/ASSERT_BINNEQ&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;期待二进制不相等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EXPECT_TRUE/ASSERT_TRUE&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;期待值为真&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EXPECT_FALSE/ASSERT_FALSE&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;期待值为假&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;固件test-fixture&#34;&gt;固件(Test Fixture) &lt;a href=&#34;#%e5%9b%ba%e4%bb%b6test-fixture&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;测试固件可看作是一组测试用例的集合，在执行这组测试用例之前或之后，可以先执行一些操作，同时也可以在执行单个测试用例之前或之后，也可以执行一些操作。对于单个测试用用例，这里，当作是包含一个测试用例的测试固件来处理。&lt;/p&gt;
&lt;p&gt;使用Test Fixture，你要继承Test这个类。类声明：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    class Test
    {
        ....
    public:
        static void SetUpTestCase()
        {
        }
        static void TearDownTestCase()
        {
        }
        virtual void SetUp()
        {
        }
        virtual void TearDown()
        {
        }
        ...
    };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后重写上述方法，带static的是执行所有用例之前或后执行的，不带的是每个测试用例执行之前或之后执行的。&lt;/p&gt;
&lt;p&gt;提供两个宏进行操作：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;宏&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;含义&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;实例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;TEST_F&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;测试固件&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;TEST_F(MyTestFixture, MyCase) &lt;!-- raw HTML omitted --&gt;{ &lt;!-- raw HTML omitted --&gt;} &lt;!-- raw HTML omitted --&gt;MyTestFixture是你继续Test的固件。&lt;!-- raw HTML omitted --&gt;MyCase是这个用例的名称。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TEST&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;测试用用例&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;TEST(MyDummyFixture, MyCase) &lt;!-- raw HTML omitted --&gt;{ &lt;!-- raw HTML omitted --&gt;} &lt;!-- raw HTML omitted --&gt;MyTestFixture是固件名称，事实上它什么也不做。&lt;!-- raw HTML omitted --&gt;MyCase是这个用例的名称。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;环境test-environment&#34;&gt;环境(Test Environment) &lt;a href=&#34;#%e7%8e%af%e5%a2%83test-environment&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;测试环境是所有Test Fixture执行之前或之后进行的准备和清理。继续类Environment，其声明为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    class Environment
    {
    public:
        Environment(){}
        virtual ~Environment(){}
    public:
        virtual void SetUp(){}
        virtual void TearDown(){}
    };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看的人应该明白。不解释。&lt;br&gt;
在初始化之前，如果使用测试环境，则要用宏SET_ENVIRONMENT将环境添加进去。&lt;/p&gt;
&lt;h3 id=&#34;其它&#34;&gt;其它 &lt;a href=&#34;#%e5%85%b6%e5%ae%83&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;还有一些与测试无关，但是与本框架相关的一些宏。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;宏&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;INIT_TEST&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;初始化框架，在使用调用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RUN_ALL_TEST&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;运行测试&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;编译好测试程序后，可执行程序接受一些选项，和GTEST的一样。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;选项&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&amp;ndash;help&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;输出帮助信息，仅显示英文，因为哥的工作的UNIX不支持中文。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;ndash;list_tests&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;列出测试用例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;ndash;filter=POSTIVE_PATTERNS[-NEGATIVE_PATTERNS]&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;过虑，仅支持通佩符&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;居然这个介绍花的时间比写这个测试框架的时间还长。&lt;/p&gt;
&lt;h3 id=&#34;示例&#34;&gt;示例 &lt;a href=&#34;#%e7%a4%ba%e4%be%8b&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;更多示例参考GTEST。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

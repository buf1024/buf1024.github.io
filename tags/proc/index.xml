<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>proc on BUF1024!!!</title>
    <link>https://luoguochun.cn/tags/proc/</link>
    <description>Recent content in proc on BUF1024!!!</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 28 Jul 2014 14:57:18 +0000</lastBuildDate><atom:link href="https://luoguochun.cn/tags/proc/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>linux /proc 伪文件系统</title>
      <link>https://luoguochun.cn/post/2014-07-28-process-information-pseduo-file-system/</link>
      <pubDate>Mon, 28 Jul 2014 14:57:18 +0000</pubDate>
      
      <guid>https://luoguochun.cn/post/2014-07-28-process-information-pseduo-file-system/</guid>
      <description>&lt;p&gt;linux /proc伪文件系统是内核数据结构的接口，是异常强大的，大部分的文件都是只读的。本文主要是根据man proc来补充说明(&lt;strong&gt;未完待续&lt;/strong&gt;)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;/proc/[pid]&lt;/em&gt;&lt;br&gt;
每一个正在运行的进程都对应有这样一个伪目录，目录名为该进程的pid。每个伪目录下面都有以下伪文件或伪目录:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/[pid]/auxv&lt;br&gt;
包含ELF解析信息（ELF就是linux系统二进制可执行文件的文件格式），&lt;code&gt;auxv&lt;/code&gt; 是 AUXiliary Vector简写。每个条目的格式就是:一个&lt;code&gt;unsigned long&lt;/code&gt;ID加上一个&lt;code&gt;unsigned long&lt;/code&gt;数值。这个AUXV是什么意思呢？ 我们可以通过加上&lt;code&gt;LD_SHOW_AUXV=1 程序名&lt;/code&gt;可以获取具体的数值:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    [heidong@HEIDONGVM 2218]$ LD_SHOW_AUXV=1 /bin/sh         
    AT_SYSINFO_EHDR: 0x7fff173d8000        
    AT_HWCAP:        178bf3ff         
    AT_PAGESZ:       4096         
    AT_CLKTCK:       100         
    AT_PHDR:         0x400040         
    AT_PHENT:        56         
    AT_PHNUM:        9         
    AT_BASE:         0x7fd32ed59000         
    AT_FLAGS:        0x0         
    AT_ENTRY:        0x41aef0         
    AT_UID:          500         
    AT_EUID:         500         
    AT_GID:          500         
    AT_EGID:         500         
    AT_SECURE:       0         
    AT_RANDOM:       0x7fff17230579         
    AT_EXECFN:       /bin/sh         
    AT_PLATFORM:     x86_64         
    sh-4.1$          
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对应的&lt;code&gt;AT_*&lt;/code&gt;的含义可在&lt;code&gt;/usr/include/elf.h&lt;/code&gt;找到。&lt;br&gt;
相关参考: &lt;a href=&#34;http://www.linuxquestions.org/questions/linux-kernel-70/what-does-proc-pid-auxv-mean-exactly-4175421876/&#34;&gt;What does /proc/PID/auxv mean exactly?&lt;/a&gt; 和 &lt;a href=&#34;http://lenky.info/archives/2013/02/2203&#34;&gt;关于ELF的辅助向量&lt;/a&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;/proc/[pid]/cmdline&lt;/em&gt;&lt;br&gt;
包含非僵死进程的命令行启动参数，该文件包含&lt;code&gt;&amp;quot;\0&amp;quot;&lt;/code&gt;。如:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    [heidong@HEIDONGVM 2238]$ cat cmdline         
    bash[heidong@HEIDONGVM 2238]$          
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;/proc/[pid]/coredump_filter&lt;/em&gt;&lt;br&gt;
用于控制哪些内存段写入到core文件，16进制显示，是与&lt;code&gt;mmap&lt;/code&gt;映射类型的位掩码。默认0,1,4,5(如果内核编译时定义CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS)，所以默认值是33。掩码含义是：&lt;br&gt;
bit 0 dump匿名私有映射.&lt;br&gt;
bit 1 dump匿名共享映射.&lt;br&gt;
bit 2 dump基于文件的私有映射.&lt;br&gt;
bit 3 dump基于文件的共享映射.&lt;br&gt;
bit 4(linux 2.6.24) dump elf 头.&lt;br&gt;
bit 5(linux 2.6.28) dump私有页面(private huge pages).
bit 6(linux 2.6.28) dump共享页面(shared huge pages).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/[pid]/cpuset&lt;br&gt;
// todo&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/[pid]/cwd&lt;br&gt;
进程当前工作目录的软连接。对于多线程的程序，如果主线程退出或挂掉了，子线程还存在，这个连接时无效的。去到当前工作目录：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    $ cd /proc/20/cwd; /bin/pwd          
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;/proc/[pid]/environ&lt;/em&gt;&lt;br&gt;
进程环境变量，每个条目都是以&lt;code&gt;&amp;quot;\0&amp;quot;&lt;/code&gt;结束。可用这种方法显示:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    [heidong@HEIDONGVM 2238]$ (cat /proc/2238/environ; echo) | tr &#39;\000&#39; &#39;\n&#39;        
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/[pid]/exe&lt;br&gt;
进程可执行文件在软连接。对于多线程的程序，如果主线程退出或挂掉了，子线程还存在，这个连接时无效的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;/proc/[pid]/fd/&lt;/em&gt;&lt;br&gt;
打开文件文件描述符目录在连接。对于多线程的程序，如果主线程退出或挂掉了，子线程还存在，这个连接时无效的。&lt;code&gt;/proc/self/fd/N&lt;/code&gt;和&lt;code&gt;/dev/fd/N&lt;/code&gt;是一样在。补充说明，对于只知道fd怎么找对于的文件呢？答案是很简单的，直接用&lt;code&gt;readlink&lt;/code&gt;函数，查看对于该目录下文件的连接就可以了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/[pid]/fdinfo/&lt;br&gt;
这个目录是和/proc/[pid]/fd/对应的，就是对于没个文件的当前偏移和打开标示。如:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    [heidong@HEIDONGVM fdinfo]$ cat 165        
    pos:	0        
    flags:	0100002        
    [heidong@HEIDONGVM fdinfo]$        
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/[pid]/limits&lt;br&gt;
limits信息。和&lt;code&gt;getrlimit&lt;/code&gt;获取的信息是一样的。如:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    [heidong@HEIDONGVM 3500]$ cat limits         
    Limit                     Soft Limit           Hard Limit           Units     
    Max cpu time              unlimited            unlimited            seconds   
    Max file size             unlimited            unlimited            bytes     
    Max data size             unlimited            unlimited            bytes     
    Max stack size            10485760             unlimited            bytes     
    Max core file size        unlimited            unlimited            bytes     
    Max resident set          unlimited            unlimited            bytes     
    Max processes             1024                 14864                processes 
    Max open files            4096                 4096                 files     
    Max locked memory         65536                65536                bytes     
    Max address space         unlimited            unlimited            bytes     
    Max file locks            unlimited            unlimited            locks     
    Max pending signals       14864                14864                signals   
    Max msgqueue size         819200               819200               bytes     
    Max nice priority         0                    0                    
    Max realtime priority     0                    0                    
    Max realtime timeout      unlimited            unlimited            us        
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/[pid]/maps&lt;br&gt;
内存映射的地址和权限。如:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    [heidong@HEIDONGVM 3890]$ cat maps 
    00400000-00410000 r-xp 00000000 fd:00 1072484                            /usr/bin/groff
    0060f000-00610000 rw-p 0000f000 fd:00 1072484                            /usr/bin/groff
    00610000-00614000 rw-p 00000000 00:00 0 
    0080f000-00811000 rw-p 0000f000 fd:00 1072484                            /usr/bin/groff
    01c6f000-01c90000 rw-p 00000000 00:00 0                                  [heap]
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/[pid]/mem&lt;br&gt;
进程对应的内存，可以通过&lt;code&gt;open&lt;/code&gt;, &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;lseek&lt;/code&gt;访问。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/apm&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/bus&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/cmdline&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/config.gz&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/cpuinfo&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/devices&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/diskstats&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/dma&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/driver&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/execdomains&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/fb&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/filesystems&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/fs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/ide&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/interrupts&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/iomem&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/ioports&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/kallsyms&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/kcore&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/kmsg&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/ksyms&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/loadavg&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/locks&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/malloc&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/meminfo&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/modules&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/mounts&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/mtrr&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/net&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/partitions&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/pci&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/scsi&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/self&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/slabinfo&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/stat&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/swaps&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/sys&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/sysrq-trigger&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/sysvipc&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/tty&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/uptime&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/version&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/vmstat&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/proc/zoneinfo&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>

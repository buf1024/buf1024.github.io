<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>coroutine on BUF1024!!!</title>
    <link>https://luoguochun.cn/tags/coroutine/</link>
    <description>Recent content in coroutine on BUF1024!!!</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>Copyletf buf2024</copyright>
    <lastBuildDate>Thu, 21 Aug 2014 16:46:46 +0000</lastBuildDate><atom:link href="https://luoguochun.cn/tags/coroutine/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>coroutine协程</title>
      <link>https://luoguochun.cn/post/2014-08-21-coroutine/</link>
      <pubDate>Thu, 21 Aug 2014 16:46:46 +0000</pubDate>
      
      <guid>https://luoguochun.cn/post/2014-08-21-coroutine/</guid>
      <description>&lt;p&gt;如果你接触过lua这种小巧的脚本语言，你就会经常接触到一个叫做&lt;code&gt;协程&lt;/code&gt;的神奇概念。大多数脚本语言都有对&lt;code&gt;协程&lt;/code&gt;不同程度的支持。但是大多编译语言，如C/C++，根本就不知道这样的东西存在。当然也很多人研究如何在编译语言实现&lt;code&gt;协程&lt;/code&gt;的实现，轮子一个又一个的被发明。&lt;a href=&#34;http://coolshell.cn/&#34;&gt;酷壳&lt;/a&gt; 这篇文章&lt;a href=&#34;http://coolshell.cn/articles/10975.html&#34;&gt;《一个“蝇量级” C 语言协程库》&lt;/a&gt;说的很详细，但对于文中介绍的协程库&lt;a href=&#34;http://dunkels.com/adam/pt/&#34;&gt;protothread&lt;/a&gt;，很难看的懂。&lt;a href=&#34;http://blog.codingnow.com/&#34;&gt;云风大哥&lt;/a&gt;在搜索无满意结果后也重新发明轮子，实现自己版本的一个协程库&lt;a href=&#34;http://blog.codingnow.com/2012/07/c_coroutine.html&#34;&gt;《C 的 coroutine 库》&lt;/a&gt;, 云风版本的&lt;code&gt;coroutine&lt;/code&gt;是常规的根据&lt;code&gt;getcontext/swapcontext&lt;/code&gt;的非常传统的方法，没有用到其他什么奇淫技巧。同时他接口几乎和lua&lt;code&gt;协程&lt;/code&gt;的接口一样，比较容易看的懂，但是貌似和CPU构架相关，下面详细说。这篇文章就是主要写看云风的代码的，代码注释放到github上面&lt;a href=&#34;https://github.com/buf1024/coroutine&#34;&gt;coroutine&lt;/a&gt;，当然因为代码本身很精练和简单，注释也就非常少的。关于&lt;code&gt;协程&lt;/code&gt;，可参考百度百科：&lt;a href=&#34;http://baike.baidu.com/view/2665148.htm?fr=aladdin&#34;&gt;&lt;code&gt;协程&lt;/code&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;开始之前，看看unix/linux下面的&lt;code&gt;context系列函数&lt;/code&gt;（&lt;a href=&#34;http://blog.codingnow.com/&#34;&gt;云风大哥&lt;/a&gt;说，windows下面可以用&lt;code&gt;纤程&lt;/code&gt;实现，以前看《windows核心编程》的时候，了解过这个概念，但是实际上编程运用的只限于进程/线程，没有用到过&lt;code&gt;纤程&lt;/code&gt;这高级货，现在接触&lt;code&gt;windows api&lt;/code&gt;也相对少，所以这个就不详细展开）。&lt;code&gt;context系列函数&lt;/code&gt;大约就以下函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    #include &amp;lt;ucontext.h&amp;gt;        

    int getcontext(ucontext_t *ucp);        
    int setcontext(const ucontext_t *ucp);        

    void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...);        
    int swapcontext(ucontext_t *oucp, ucontext_t *ucp);        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据linux手册页，&lt;code&gt;getcontext&lt;/code&gt;返回的是当前执行进程的上下文信息，包括信号掩码，执行栈，寄存器等信息。比较值得注意的是&lt;code&gt;makecontext&lt;/code&gt;，该函数除了传递&lt;code&gt;ucp&lt;/code&gt;外，还传递一个通用的函数指针&lt;code&gt;func&lt;/code&gt;和一个&lt;code&gt;argc&lt;/code&gt;，传递给&lt;code&gt;func&lt;/code&gt;的函数原型并不一定是&lt;code&gt;void(*)()&lt;/code&gt;类型的，参数的个数由&lt;code&gt;argc&lt;/code&gt;确定。当调用&lt;code&gt;makecontext&lt;/code&gt;成功后，如果对这个上下文进行切换(&lt;code&gt;swapcontext&lt;/code&gt;)或用这个上下文设置(&lt;code&gt;setcontext&lt;/code&gt;)，内核就会调用该&lt;code&gt;func&lt;/code&gt;函数。&lt;code&gt;协程&lt;/code&gt;的实现就是用到这个重要的原理。linux手册页有个详细的例子介绍&lt;code&gt;makecontext&lt;/code&gt;怎么用的，请参考之。&lt;/p&gt;
&lt;p&gt;我们来看&lt;a href=&#34;http://blog.codingnow.com/&#34;&gt;云风大哥&lt;/a&gt;的协程库:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    // 协程调度大小        
    struct schedule {        
        char stack[STACK_SIZE]; // 当前运行的协程的栈
        ucontext_t main; // 下个协程切换的上下文状态
        int nco; // 当前协程
        int cap; // 容量
        int running; // 当前运行的协程
        struct coroutine **co; // 协程数组
    };

    struct coroutine {
        coroutine_func func; // 调用函数
        void *ud;      // 用户数据
        ucontext_t ctx; // 保存的协程上下文状态
        struct schedule * sch; // 保存struct schedule指针
        ptrdiff_t cap; // 上下文切换时保存的栈的容量
        ptrdiff_t size; // 上下文切换时保存的栈的大小 size &amp;lt;= cap
        int status; // 协程状态
        char *stack; // 保存的协程栈大小
    };  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义的结构体够简洁的，除了&lt;code&gt;struct coroutine&lt;/code&gt;里面的&lt;code&gt;cap&lt;/code&gt;和&lt;code&gt;size&lt;/code&gt;，感觉作用不大。上下文信息是在&lt;code&gt;coroutine_resume&lt;/code&gt;里面设置的，这里将栈设置为自己定义的区域，大小也限定了，还设置了下个上下文切换的地址（在&lt;code&gt;swapcontext&lt;/code&gt;里为他赋初始值）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    getcontext(&amp;amp;C-&amp;gt;ctx);
	C-&amp;gt;ctx.uc_stack.ss_sp = S-&amp;gt;stack; // 设置栈
	C-&amp;gt;ctx.uc_stack.ss_size = STACK_SIZE; // 设置栈大小
	C-&amp;gt;ctx.uc_link = &amp;amp;S-&amp;gt;main; // 下个切换的上下文状态，由swapcontext设置其值
	S-&amp;gt;running = id;
	C-&amp;gt;status = COROUTINE_RUNNING;
	uintptr_t ptr = (uintptr_t)S;
	makecontext(&amp;amp;C-&amp;gt;ctx, (void (*)(void)) mainfunc, 2, (uint32_t)ptr, (uint32_t)(ptr&amp;gt;&amp;gt;32));
	swapcontext(&amp;amp;S-&amp;gt;main, &amp;amp;C-&amp;gt;ctx);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;http://blog.codingnow.com/&#34;&gt;云风大哥&lt;/a&gt;的协程库有点不好的地方就是这个协程库或许是与CPU的构架相关的，做成与CPU无关应该不难。看保存上下文信息的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    static void
    _save_stack(struct coroutine *C, char *top) {
        char dummy = 0;
     	//这里做了一个特定的假设(事实上大部分CPU也是如此)
        assert(top - &amp;amp;dummy &amp;lt;= STACK_SIZE); // stack大小
        if (C-&amp;gt;cap &amp;lt; top - &amp;amp;dummy) {
	        free(C-&amp;gt;stack); // 首次C-&amp;gt;stack为NULL,free(NULL)是OK的
	        C-&amp;gt;cap = top-&amp;amp;dummy;
	        C-&amp;gt;stack = malloc(C-&amp;gt;cap);
        }
        C-&amp;gt;size = top - &amp;amp;dummy;
        memcpy(C-&amp;gt;stack, &amp;amp;dummy, C-&amp;gt;size);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;传递的参数&lt;code&gt;top&lt;/code&gt;指向的是栈顶，栈顶与新定义的变量相减&lt;code&gt;top - &amp;amp;dummy&lt;/code&gt;得到栈的大小。这里做了一个特定的假设，栈由高地址向低地址方向增长(这是非常典型的程序布局方式，虽然我不知道那种CPU不是用这种布局，但是觉得肯定有有低地址向高地址增长的)，这种程序布局的CPU一般是X86构架的，所以这个库时与CPU结构相关的。&lt;/p&gt;
&lt;p&gt;总的来说，这个协程库写的非常精简。&lt;a href=&#34;http://dunkels.com/adam/pt/&#34;&gt;protothread&lt;/a&gt;这种高级货，暂时不看了。粗略的介绍完毕，如有错误，请批评指正。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;2016-04-28 补充：&lt;br&gt;
&amp;ldquo;&amp;ldquo;&amp;ldquo;根据linux手册页，&lt;code&gt;getcontext&lt;/code&gt;返回的是当前执行进程的上下文信息，包括信号掩码，执行栈，寄存器等信息。比较值得注意的是&lt;code&gt;makecontext&lt;/code&gt;，该函数除了传递&lt;code&gt;ucp&lt;/code&gt;外，还传递一个通用的函数指针&lt;code&gt;func&lt;/code&gt;和一个&lt;code&gt;argc&lt;/code&gt;，传递给&lt;code&gt;func&lt;/code&gt;的函数原型并不一定是&lt;code&gt;void(*)()&lt;/code&gt;类型的，参数的个数由&lt;code&gt;argc&lt;/code&gt;确定。当调用&lt;code&gt;makecontext&lt;/code&gt;成功后，如果对这个上下文进行切换(&lt;code&gt;swapcontext&lt;/code&gt;)或用这个上下文设置(&lt;code&gt;setcontext&lt;/code&gt;)，内核就会调用该&lt;code&gt;func&lt;/code&gt;函数。&lt;code&gt;协程&lt;/code&gt;的实现就是用到这个重要的原理。linux手册页有个详细的例子介绍&lt;code&gt;makecontext&lt;/code&gt;怎么用的，请参考之。&amp;rdquo;&amp;rdquo;&amp;rdquo;&lt;br&gt;
上面一段说明说的比较笼统，再简单补充不使用这个库的例子：&lt;br&gt;
main -&amp;gt; co_resume -&amp;gt; func -&amp;gt; co_yield -&amp;gt; main&lt;br&gt;
调用co_resume 后，执行上下文切换，调用协程函数func，在协程函数func里面，调用co_yield, 执行上下文切换，返回main，下次co_resume时，func从co_yield后面继续执行(因为之前保存了上下文的切换信息)。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/buf1024/coroutine&#34;&gt;例子&lt;/a&gt;输出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    main        
    main fun: 0        
    test_func: 0        
    main fun: 1        
    test_func: 1        
    main fun: 2        
    test_func: 2        
    main fun: 3        
    test_func: 3        
    ^Csignal int        
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>

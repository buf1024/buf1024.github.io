
<!DOCTYPE html>
<html lang="zh-cn" data-figures=""  class="page"   >

<head>
<title>BUF1024</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">





<meta property="og:locale" content="zh-cn" />

<meta property="og:type" content="article">
<meta name="description" content="闭包 Save the environment! Create a closure today! ——Cormac Flanagan 排序一个整数的vector非常简单： 1 integers.sort(); 然而一个悲伤的事实是，当我们想要对一些数据排序时，它们基本从来都" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:creator" content="">
<meta name="twitter:title" content="" />
<meta name="twitter:image" content="https://luoguochun.cn"/>
<meta property="og:url" content="https://luoguochun.cn/prust/ch14/" />
<meta property="og:title" content="" />
<meta property="og:description" content="闭包 Save the environment! Create a closure today! ——Cormac Flanagan 排序一个整数的vector非常简单： 1 integers.sort(); 然而一个悲伤的事实是，当我们想要对一些数据排序时，它们基本从来都" />
<meta property="og:image" content="https://luoguochun.cn" />
  <meta name="keywords" content="blog,computer,luoguochun" />

<link rel="apple-touch-icon" sizes="180x180" href="https://luoguochun.cn/icons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://luoguochun.cn/icons/favicon-32x32.png">
<link rel="manifest" href="https://luoguochun.cn/icons/site.webmanifest">

<link rel="canonical" href="https://luoguochun.cn/prust/ch14/">



<link rel="preload" href="https://luoguochun.cn/css/styles.42e2c5f6d8cf9c52872666f8d8b2678ad0c426978b9d78aff3c33b7a1e7f6f97f54bcdaf0518a25fb0fe26367d04f8b07c683b3b38b331cb098daadee06b1f3e.css" integrity = "sha512-QuLF9tjPnFKHJmb42LJnitDEJpeLnXiv88M7eh5/b5f1S82vBRiiX7D&#43;JjZ9BPiwfGg7OzizMcsJjare4GsfPg==" as="style" crossorigin="anonymous">



<link rel="preload" href="https://luoguochun.cn/zh-cn/js/bundle.884eccc71c2848fb4aeb15945329b5a857717f0313da00cb46b765b5734cfa64b08ce2609627167129c2de17d9b47ed210682f96a2502ebb3aadc73191740211.js" as="script" integrity=
"sha512-iE7MxxwoSPtK6xWUUym1qFdxfwMT2gDLRrdltXNM&#43;mSwjOJglicWcSnC3hfZtH7SEGgvlqJQLrs6rccxkXQCEQ==" crossorigin="anonymous">


<link rel="stylesheet" type="text/css" href="https://luoguochun.cn/css/styles.42e2c5f6d8cf9c52872666f8d8b2678ad0c426978b9d78aff3c33b7a1e7f6f97f54bcdaf0518a25fb0fe26367d04f8b07c683b3b38b331cb098daadee06b1f3e.css" integrity="sha512-QuLF9tjPnFKHJmb42LJnitDEJpeLnXiv88M7eh5/b5f1S82vBRiiX7D&#43;JjZ9BPiwfGg7OzizMcsJjare4GsfPg==" crossorigin="anonymous">

</head>

<body data-code="100" data-lines="false" id="documentTop"
  data-lang="zh-cn">

<header class="nav_header" >
  <nav class="nav"><a href='https://luoguochun.cn' class="nav_brand nav_item" title="BUF1024">BUF1024
  <div class="nav_close">
    <div><svg class="icon">
  <title>open-menu</title>
  <use xlink:href="#open-menu"></use>
</svg>
<svg class="icon">
  <title>closeme</title>
  <use xlink:href="#closeme"></use>
</svg>
</div>
  </div>
</a>

    <div class='nav_body nav_body_left'>
      
      
      
        

  <div class="nav_parent">
    <a href="https://luoguochun.cn/" class="nav_item" title="主页">主页 </a>
  </div>
  <div class="nav_parent">
    <a href="https://luoguochun.cn" class="nav_item" title="链接">链接 <img src='https://luoguochun.cn/icons/caret-icon.svg' alt="icon" class="nav_icon"></a>
    <div class="nav_sub">
      <span class="nav_child"></span>
        <a href="https://luoguochun.cn/talib-doc/" class="nav_child nav_item" title="TA 技术分析库">TA 技术分析库</a>
        <a href="https://luoguochun.cn/hiqradio" class="nav_child nav_item" title="hiqadio网络收音机">hiqadio网络收音机</a>
    </div>
  </div>
  <div class="nav_parent">
    <a href="https://luoguochun.cn/about/" class="nav_item" title="关于">关于 </a>
  </div>
      
<div class='follow'>
<div class="color_mode">
  <input type="checkbox" class="color_choice" id="mode">
</div>

</div>

    </div>
  </nav>
</header>

  <main>
  
<div class="grid-inverse wrap content">
  <article class="post_content">
    <h1 class="post_title"></h1>
  <div class="post_meta">
    <span><svg class="icon">
  <title>calendar</title>
  <use xlink:href="#calendar"></use>
</svg>
</span>
    <span class="post_date">
      Jan 1, 0001</span>
    <span class="post_time"> · 21 min read</span>
    <span class="page_only">&nbsp;·
  <div class="post_share">
    分享到:
    <a href="https://twitter.com/intent/tweet?text=&url=https%3a%2f%2fluoguochun.cn%2fprust%2fch14%2f&tw_p=tweetbutton" class="twitter" title="分享到 Twitter" target="_blank" rel="nofollow">
      <svg class="icon">
  <title>twitter</title>
  <use xlink:href="#twitter"></use>
</svg>

    </a>
    <a href="https://www.facebook.com/sharer.php?u=https%3a%2f%2fluoguochun.cn%2fprust%2fch14%2f&t=" class="facebook" title="分享到 Facebook" target="_blank" rel="nofollow">
      <svg class="icon">
  <title>facebook</title>
  <use xlink:href="#facebook"></use>
</svg>

    </a>
    <a href="#linkedinshare" id = "linkedinshare" class="linkedin" title="分享到 LinkedIn" rel="nofollow">
      <svg class="icon">
  <title>linkedin</title>
  <use xlink:href="#linkedin"></use>
</svg>

    </a>
    <a href="https://luoguochun.cn/prust/ch14/" title="Copy Link" class="link link_yank">
      <svg class="icon">
  <title>copy</title>
  <use xlink:href="#copy"></use>
</svg>

    </a>
  </div>
  </span>
  </div>

    <div class="post_body"><h1 id="闭包">闭包</h1>
<p><em>Save the environment! Create a closure today!</em></p>
<p align="right">
    ——Cormac Flanagan
</p>
<p>排序一个整数的vector非常简单：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="n">integers</span><span class="p">.</span><span class="n">sort</span><span class="p">();</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>然而一个悲伤的事实是，当我们想要对一些数据排序时，它们基本从来都不只是整数。我们通常要排序某种记录，内建的<code>sort</code>方法通常不能工作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">struct</span> <span class="nc">City</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">name</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">population</span>: <span class="kt">i64</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">country</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">sort_cities</span><span class="p">(</span><span class="n">cities</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">City</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">cities</span><span class="p">.</span><span class="n">sort</span><span class="p">();</span><span class="w">  </span><span class="c1">// 错误：你想让它们怎么排序？
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>Rust会报错<code>City</code>没有实现<code>std::cmp::Ord</code>。我们需要像这样指明排序的顺序：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="sd">/// 按照人口排序城市的辅助函数
</span><span class="sd"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">city_population_descending</span><span class="p">(</span><span class="n">city</span>: <span class="kp">&amp;</span><span class="nc">City</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i64</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">-</span><span class="n">city</span><span class="p">.</span><span class="n">population</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">sort_cities</span><span class="p">(</span><span class="n">cities</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">City</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">cities</span><span class="p">.</span><span class="n">sort_by_key</span><span class="p">(</span><span class="n">city_population_descending</span><span class="p">);</span><span class="w"> </span><span class="c1">// ok
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这个辅助函数<code>city_population_descending</code>，获取一个<code>City</code>记录并提取出 <em>key</em> ，我们根据这个字段来排序数据。（它返回一个负数是因为<code>sort</code>以递增顺序排序，但我们想以降序排序：人多最多的城市优先。）<code>sort_by_key</code>方法以这个返回key的函数为参数。</p>
<p>它可以很好地工作，但如果将辅助函数写成一个 <em>闭包(closure)</em> （一个匿名的函数表达式）会更简洁：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">sort_cities</span><span class="p">(</span><span class="n">cities</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">City</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">cities</span><span class="p">.</span><span class="n">sort_by_key</span><span class="p">(</span><span class="o">|</span><span class="n">city</span><span class="o">|</span><span class="w"> </span><span class="o">-</span><span class="n">city</span><span class="p">.</span><span class="n">population</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这里的闭包是<code>|city| -city.population</code>，它的参数是<code>city</code>，返回值是<code>-city.population</code>。Rust会从闭包的使用中推断出参数和返回值的类型。</p>
<p>标准库中其他接受闭包的特性的例子包括：</p>
<ul>
<li><code>Iterator</code>的方法例如<code>map</code>和<code>filter</code>。我们将在”第15章”介绍这些方法。</li>
<li>线程的API例如<code>thread::spawn</code>，它会创建一个新的系统线程。并发就是把工作移动到其他的线程，闭包能方便地表示这种工作单元。我们将在”第19章”中介绍这些特性。</li>
<li>一些需要根据条件计算默认值的方法，例如<code>HashMap</code>条目的<code>or_insert_with</code>方法。这个方法获取一个<code>HashMap</code>的表项，或者创建一个表项，当计算默认值有很大开销时会使用这个方法。只有当必须创建一个新表项的时候作为闭包传入的默认值才会被调用。</li>
</ul>
<p>当然，现在匿名函数随处可见，即使像Java、C#、Python、C++这些一开始没有的语言现在也有了。从现在开始我们将假设你已经见过匿名函数，并专注于介绍Rust的闭包的独特之处。本章中，你将学习到三种不同类型的闭包、如何将闭包和标准库方法一起使用、一个闭包如何“捕获”作用域内的变量、如何编写自己的以闭包为参数的函数和方法、以及如何存储闭包以待之后用于回调。我们将解释Rust的闭包是怎么实现的，以及为什么它们比你想象的更加快速。</p>
<h2 id="捕获变量">捕获变量</h2>
<p>一个闭包可以使用封闭函数内的数据。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="sd">/// 根据统计数据排序
</span><span class="sd"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">sort_by_statistic</span><span class="p">(</span><span class="n">cities</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">City</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">stat</span>: <span class="nc">Statistic</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">cities</span><span class="p">.</span><span class="n">sort_by_key</span><span class="p">(</span><span class="o">|</span><span class="n">city</span><span class="o">|</span><span class="w"> </span><span class="o">-</span><span class="n">city</span><span class="p">.</span><span class="n">get_statistic</span><span class="p">(</span><span class="n">stat</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这里的闭包使用了<code>stat</code>，它属于当前的封闭函数<code>sort_by_statistic</code>。我们说这个闭包“捕获”了<code>stat</code>。这是闭包最经典的特性之一。Rust自然支持它，但在Rust中，这个特性有很多需要注意的地方。</p>
<p>在大多数有闭包的语言中，垃圾收集扮演了重要的角色。例如，考虑这段JavaScript代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="c1">// 开始一段动画，重新排序表格中的城市
</span><span class="c1"></span><span class="w">    </span><span class="n">function</span><span class="w"> </span><span class="n">startSortingAnimation</span><span class="p">(</span><span class="n">cities</span><span class="p">,</span><span class="w"> </span><span class="n">stat</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// 排序表格时用到的辅助函数。
</span><span class="c1"></span><span class="w">        </span><span class="c1">// 注意这个函数用到了stat
</span><span class="c1"></span><span class="w">        </span><span class="n">function</span><span class="w"> </span><span class="n">keyfn</span><span class="p">(</span><span class="n">city</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">city</span><span class="p">.</span><span class="n">get_statistic</span><span class="p">(</span><span class="n">stat</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pendingSort</span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="n">pendingSort</span><span class="p">.</span><span class="n">cancel</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="c1">// 现在开始动画，向它传递keyfn。
</span><span class="c1"></span><span class="w">        </span><span class="c1">// 排序算法之后将会调用keyfn。
</span><span class="c1"></span><span class="w">        </span><span class="n">pendingSort</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">SortingAnimation</span><span class="p">(</span><span class="n">cities</span><span class="p">,</span><span class="w"> </span><span class="n">keyfn</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这个闭包<code>keyfn</code>被存储在新的<code>SortingAnimation</code>对象中。这意味着它可能会在<code>startSortingAnimation</code>返回之后被调用。通常来讲当一个函数返回时，它的所有变量和参数都会离开作用域并且被丢弃。但这里，JavaScript引擎必须一直保留<code>stat</code>，因为闭包中用到了它。大多数JavaScript引擎通过在堆上分配<code>stat</code>，然后让垃圾收集器之后再回收它来做到这一点。</p>
<p>Rust没有垃圾收集。那么这样的代码会如何运作？为了回答这个问题，我们先看两个例子。</p>
<h3 id="借用值的闭包">借用值的闭包</h3>
<p>首先，让我们重复这一节开始时的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="sd">/// 根据统计数据排序
</span><span class="sd"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">sort_by_statistic</span><span class="p">(</span><span class="n">cities</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">City</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">stat</span>: <span class="nc">Statistic</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">cities</span><span class="p">.</span><span class="n">sort_by_key</span><span class="p">(</span><span class="o">|</span><span class="n">city</span><span class="o">|</span><span class="w"> </span><span class="o">-</span><span class="n">city</span><span class="p">.</span><span class="n">get_statistic</span><span class="p">(</span><span class="n">stat</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>在这个例子中，当Rust创建闭包时，它会自动借用一个<code>stat</code>的引用。按理来说，闭包用到了<code>stat</code>，所以它必须有一个指向它的引用。</p>
<p>剩余的部分就很简单了。闭包仍然遵循我们在”第5章”中介绍的有关借用和生命周期的规则。另外，因为闭包包含一个<code>stat</code>的引用，所以Rust不允许它比<code>stat</code>活得更长。因为这个闭包只在排序中使用，所以这个例子没有问题。</p>
<p>简单来说，Rust通过使用生命周期代替垃圾收集来保证安全性。Rust的方式更加快速：即使是一个很快的GC分配器也比Rust这种把<code>stat</code>存在栈上的方式慢。</p>
<h3 id="偷取值的闭包">偷取值的闭包</h3>
<p>第二个例子更加棘手：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">thread</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">start_sorting_thread</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">cities</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">City</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">stat</span>: <span class="nc">Statistic</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">thread</span>::<span class="n">JoinHandle</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">City</span><span class="o">&gt;&gt;</span><span class="w">
</span><span class="w">    </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">key_fn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">city</span>: <span class="kp">&amp;</span><span class="nc">City</span><span class="o">|</span><span class="w"> </span>-&gt; <span class="kt">i64</span> <span class="p">{</span><span class="w"> </span><span class="o">-</span><span class="n">city</span><span class="p">.</span><span class="n">get_statistic</span><span class="p">(</span><span class="n">stat</span><span class="p">)</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="n">thread</span>::<span class="n">spawn</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">cities</span><span class="p">.</span><span class="n">sort_by_key</span><span class="p">(</span><span class="n">key_fn</span><span class="p">);</span><span class="w">
</span><span class="w">            </span><span class="n">cities</span><span class="w">
</span><span class="w">        </span><span class="p">})</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这和我们上面的JavaScript的例子有一些像：<code>thread::spawn</code>获取闭包并且在一个新的系统线程中调用它。注意<code>||</code>是闭包的空参数列表。</p>
<p>新的线程和调用者并行运行。当闭包返回时，新的线程也会退出。（闭包的返回值会通过一个<code>JoinHandle</code>值返还给调用者。我们将在”第19章”中讨论它）。</p>
<p>闭包<code>key_fn</code>仍然包含一个<code>stat</code>的引用。但这一次，Rust不能保证引用会被安全使用。因此Rust会拒绝这个程序：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-mysql" data-lang="mysql"><span class="w">    </span><span class="n">error</span><span class="p">[</span><span class="n">E0373</span><span class="p">]:</span><span class="w"> </span><span class="n">closure</span><span class="w"> </span><span class="n">may</span><span class="w"> </span><span class="n">outlive</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="n">function</span><span class="p">,</span><span class="w"> </span><span class="n">but</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">borrows</span><span class="w"> </span><span class="o">`</span><span class="n">stat</span><span class="o">`</span><span class="p">,</span><span class="w">
</span><span class="w">                  </span><span class="n">which</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">owned</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="n">function</span><span class="w">
</span><span class="w">      </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">closures_sort_thread</span><span class="p">.</span><span class="n">rs</span><span class="p">:</span><span class="mi">33</span><span class="p">:</span><span class="mi">18</span><span class="w">
</span><span class="w">       </span><span class="o">|</span><span class="w">
</span><span class="w">    </span><span class="mi">33</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">let</span><span class="w"> </span><span class="n">key_fn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">city</span><span class="p">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">City</span><span class="o">|</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">i64</span><span class="w"> </span><span class="err">{</span><span class="w"> </span><span class="o">-</span><span class="n">city</span><span class="p">.</span><span class="nf">get_statistic</span><span class="p">(</span><span class="n">stat</span><span class="p">)</span><span class="w"> </span><span class="err">}</span><span class="p">;</span><span class="w">
</span><span class="w">       </span><span class="o">|</span><span class="w">              </span><span class="o">^^^^^^^^^^^^^^^^^^^^</span><span class="w">                       </span><span class="o">^^^^</span><span class="w">
</span><span class="w">       </span><span class="o">|</span><span class="w">              </span><span class="o">|</span><span class="w">                                      </span><span class="o">`</span><span class="n">stat</span><span class="o">`</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">borrowed</span><span class="w"> </span><span class="n">here</span><span class="w">
</span><span class="w">       </span><span class="o">|</span><span class="w">              </span><span class="n">may</span><span class="w"> </span><span class="n">outlive</span><span class="w"> </span><span class="n">borrowed</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">`</span><span class="n">stat</span><span class="o">`</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>（事实上，这里有两个问题，因为<code>cities</code>也被不安全地共享。）简单来说，<code>thread::spawn</code>新创建的线程不能保证在<code>cities</code>和<code>stat</code>被销毁之前完成工作。</p>
<p>解决这两个问题的方法是一样的：告诉Rust把<code>cities</code>和<code>stat</code> <em>移动(move)</em> 进新的闭包，而不是借用它们的引用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">start_sorting_thread</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">cities</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">City</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">stat</span>: <span class="nc">Statistic</span><span class="p">)</span><span class="w">
</span><span class="w">        </span>-&gt; <span class="nc">thread</span>::<span class="n">JoinHandle</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">City</span><span class="o">&gt;&gt;</span><span class="w">
</span><span class="w">    </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">key_fn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="n">city</span>: <span class="kp">&amp;</span><span class="nc">City</span><span class="o">|</span><span class="w"> </span>-&gt; <span class="kt">i64</span> <span class="p">{</span><span class="w"> </span><span class="o">-</span><span class="n">city</span><span class="p">.</span><span class="n">get_statistic</span><span class="p">(</span><span class="n">stat</span><span class="p">)</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="n">thread</span>::<span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">cities</span><span class="p">.</span><span class="n">sort_by_key</span><span class="p">(</span><span class="n">key_fn</span><span class="p">);</span><span class="w">
</span><span class="w">            </span><span class="n">cities</span><span class="w">
</span><span class="w">        </span><span class="p">})</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>我们唯一修改的地方就是在两个闭包前面都加上了<code>move</code>关键字。<code>move</code>关键字告诉Rust闭包并不是借用它用到的值，而是偷取它们。</p>
<p>第一个闭包<code>key_fn</code>，获取了<code>stat</code>的所有权。然后第二个闭包获取了<code>cities</code>和<code>key_fn</code>的所有权。</p>
<p>因此Rust为闭包提供了两种从封闭作用域中获取数据的方式：移动和借用。实话说没有什么更多要说的了，闭包遵守我们在”第4章”和”第5章”中提到的移动和借用的规则。这里还有一些情况的解释：</p>
<ul>
<li>就像语言中其他任何部分一样，如果一个闭包<code>move</code>一个可拷贝类型，例如<code>i32</code>，那么它会拷贝这个值。因此如果<code>Statistic</code>恰巧是个可拷贝类型，那么即使创建了使用了它的<code>move</code>闭包之后，我们仍然可以继续使用<code>stat</code>。</li>
<li>非拷贝类型，例如<code>Vec&lt;City&gt;</code>，会真的被移动：上面的代码会通过<code>move</code>闭包把<code>cities</code>移动到新线程。Rust不允许我们在创建了这个闭包之后再访问<code>cities</code>。</li>
<li>这里，在闭包移动<code>cities</code>之后，我们不需要再使用<code>cities</code>。如果我们还需要用到它，那么我们可以先克隆<code>cities</code>并把拷贝存储到不同的变量中。闭包将只偷取拷贝中的一个——不管它用的是哪一个。</li>
</ul>
<p>Rust的严格规则给我们带来了很重要的一个保证：线程安全。正因为vector被移动了，而不是在线程之间共享，所以我们可以知道旧的线程不会在新的线程修改vector时释放它。</p>
<h2 id="函数和闭包类型">函数和闭包类型</h2>
<p>在本章中，我们已经见到过一些用作值的函数和闭包。自然地，这意味着它们也有类型。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">city_population_descending</span><span class="p">(</span><span class="n">city</span>: <span class="kp">&amp;</span><span class="nc">City</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i64</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">-</span><span class="n">city</span><span class="p">.</span><span class="n">population</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这个函数接受一个参数（一个<code>&amp;City</code>），然后返回一个<code>i64</code>。所以它的类型是<code>fn(&amp;City) -&gt; i64</code>。</p>
<p>你可以像操作其他值一样对函数进行各种操作。你可以将它们存储在变量中。你可以使用通常的Rust语法来计算函数值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">my_key_fn</span>: <span class="nc">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">City</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="mi">64</span><span class="w"> </span><span class="o">=</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">user</span><span class="p">.</span><span class="n">prefs</span><span class="p">.</span><span class="n">by_population</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">city_population_descending</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">city_monster_attack_risk_descending</span><span class="w">
</span><span class="w">        </span><span class="p">};</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="n">cities</span><span class="p">.</span><span class="n">sort_by_key</span><span class="p">(</span><span class="n">my_key_fn</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>结构体也可以有函数类型的字段。泛型类型例如<code>Vec</code>可以存储函数，只要它们有相同的<code>fn</code>类型。而且一个函数类型的值非常小：一个<code>fn</code>值只是函数的机器码的内存地址，就像C++中的函数指针一样。</p>
<p>一个函数可以获取另一个函数作为参数。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="sd">/// 给定一个城市的列表和一个测试函数，
</span><span class="sd"></span><span class="w">    </span><span class="sd">/// 返回有多少城市通过了测试。
</span><span class="sd"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">count_selected_cities</span><span class="p">(</span><span class="n">cities</span>: <span class="kp">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">City</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">                             </span><span class="n">test_fn</span>: <span class="nc">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">City</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span>
    <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">city</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">cities</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">test_fn</span><span class="p">(</span><span class="n">city</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="n">count</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="n">count</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="sd">/// 一个测试函数的例子。注意这个函数的类型是
</span><span class="sd"></span><span class="w">    </span><span class="sd">/// `fn(&amp;City) -&gt; bool`，和`count_selected_cities`
</span><span class="sd"></span><span class="w">    </span><span class="sd">/// 的`test_fn`参数的类型一样。
</span><span class="sd"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">has_monster_attacks</span><span class="p">(</span><span class="n">city</span>: <span class="kp">&amp;</span><span class="nc">City</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">city</span><span class="p">.</span><span class="n">monster_attack_risk</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// 有多少城市面临被怪物袭击的危险？
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">count_selected_cities</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_cities</span><span class="p">,</span><span class="w"> </span><span class="n">has_monster_attacks</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>如果你熟悉C/C++中的函数指针，你会发现Rust的函数类型的值其实就是一样的东西。</p>
<p>除了这些之外，你可能会很惊讶闭包的类型和函数 <em>不同</em> ：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">limit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">preferences</span><span class="p">.</span><span class="n">acceptable_monster_risk</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">count_selected_cities</span><span class="p">(</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="n">my_cities</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="o">|</span><span class="n">city</span><span class="o">|</span><span class="w"> </span><span class="n">city</span><span class="p">.</span><span class="n">monster_attack_risk</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">limit</span><span class="p">);</span><span class="w">   </span><span class="c1">// 错误：类型不匹配
</span></code></pre></td></tr></table>
</div>
</div><p>第二个参数会导致类型错误。为了支持闭包，我们必须修改函数的签名。它需要看起来像这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">count_selected_cities</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cities</span>: <span class="kp">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">City</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">test_fn</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span>
        <span class="nc">where</span><span class="w"> </span><span class="n">F</span>: <span class="nb">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">City</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">city</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">cities</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">test_fn</span><span class="p">(</span><span class="n">city</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="n">count</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="n">count</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>我们只修改了<code>count_selected_cities</code>的类型签名，没有修改函数体。新的版本是泛型的。它接受任何<code>F</code>类型的参数<code>test_fn</code>，只要<code>F</code>实现了特殊的trait <code>Fn(&amp;City) -&gt; bool</code>。接受单个<code>&amp;City</code>并返回一个布尔值的所有函数和大部分闭包会自动实现这个trait：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">City</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>   <span class="c1">// fn 类型（只限函数）
</span><span class="c1"></span><span class="w">    </span><span class="nb">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">City</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>   <span class="c1">// Fn trait（函数和闭包）
</span></code></pre></td></tr></table>
</div>
</div><p>这个特殊的语法是语言内建的。<code>-&gt;</code>和返回类型是可选的。如果省略，返回类型是<code>()</code>。</p>
<p>新版本的<code>count_selected_cities</code>接受一个函数或者闭包：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="n">count_selected_cities</span><span class="p">(</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="n">my_cities</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">has_monster_attacks</span><span class="p">);</span><span class="w">   </span><span class="c1">// ok
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="n">count_selected_cities</span><span class="p">(</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="n">my_cities</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="o">|</span><span class="n">city</span><span class="o">|</span><span class="w"> </span><span class="n">city</span><span class="p">.</span><span class="n">monster_attack_risk</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">limit</span><span class="p">);</span><span class="w">   </span><span class="c1">// 也ok
</span></code></pre></td></tr></table>
</div>
</div><p>为什么第一次尝试不能工作？这是因为闭包虽然可以调用，但它不是一个<code>fn</code>。闭包<code>|city| city.monster_attack_risk &gt; limit</code>有自己的类型，不是一个<code>fn</code>类型。</p>
<p>事实上，你写的每一个闭包都有自己的类型，因为一个闭包可能包含数据：从作用域中借用或偷取的值。这可能是任意数量、任意类型的变量。因此每一个闭包都有一个编译器创建的特定的类型，大到足够存储数据。没有类型完全相同的两个闭包。但每一个闭包都实现了<code>Fn</code> trait；我们的例子中的闭包实现了<code>Fn(&amp;City) -&gt; i64</code>。</p>
<p>因为每一个闭包都有自己的类型，所以处理闭包的代码通常要是泛型的，比如<code>count_selected_cities</code>。每次都要写出这种泛型类型有些笨拙，但要了解这种设计的优点，请继续阅读。</p>
<h2 id="闭包的性能">闭包的性能</h2>
<p>Rust的闭包被设计得很快：比函数指针更快，快到你可以在调用非常频繁、性能敏感的代码中使用它们。如果你熟悉C++的lambda，你将会发现Rust的闭包和它一样快和紧凑，但更安全。</p>
<p>在大多数语言中，闭包都在堆上分配、动态分发、被垃圾收集器回收。因此创建、调用、回收每个闭包都需要消耗额外的CPU时间。更糟的是，闭包常常会排除 <em>内联(inline)</em> ，这是一种编译器用于消除函数调用的开销并为其它优化提供支持的关键技术。总的来说，那些语言中的闭包太慢，以至于需要从紧密的内层循环中手动移除它们。</p>
<p>Rust的闭包没有任何这些性能缺陷。它们没有垃圾回收。和Rust中的其他所有东西一样，除非你把它们放在<code>Box</code>、<code>Vec</code>或其他容器中，否则它们不会在堆上分配。并且因为每个闭包都有不同的类型，任何时候Rust编译器都知道你要调用的闭包的类型，它可以为那个特殊的闭包内联代码。这让闭包完全可以在紧密的循环中使用，并且Rsut程序通常确实会踊跃地这么做，正如你将在”第15章”中看到的一样。</p>
<p>”图14-1”展示了Rust闭包在内存中的布局。在图片的顶部，我们展示了我们的闭包引用的两个局部变量：一个字符串<code>food</code>和一个简单的枚举<code>weather</code>，它的数字值恰好是27。</p>
<p><figure>
  <picture>

    
      
        
        
        
        
        
        
    <img
      loading="lazy"
      decoding="async"
      alt="闭包的内存布局"
      
        class="image_figure image_internal image_unprocessed"
        src="../img/f14-1.png"
      
      
    />

    </picture>
</figure>
</p>
<p align="center">图14-1 闭包的内存布局</p>
<p>闭包(a)使用了两个变量。显然我们在查找同时有炸玉米和龙卷风的城市。在内存中，这个闭包看起来像一个包含两个引用的结构体。</p>
<p>注意并没有一个指向它的代码的指针！这没有必要：只要Rust知道闭包的类型，它就知道当你调用闭包时要运行哪里的代码。</p>
<p>闭包(b)基本相同，除了它是一个<code>move</code>闭包，因此它包含值而不是引用。</p>
<p>闭包(c)并没有使用环境中的任何变量。结构体是空的，因此这个闭包不会占用任何内存。</p>
<p>正如图中所示，这些闭包并不会占用太多空间。但在实践中即使这一点空间有时候也不需要。通常，编译器可以内联一个闭包的所有调用，并且即使上面的图中展示的小结构体也可能被优化掉。</p>
<p>在“回调”中，我们将展示怎么在堆上分配闭包并使用trait对象动态地调用它们。这样会稍微慢一点，但它仍然和其他的trait对象的方法一样快。</p>
<h2 id="闭包和安全性">闭包和安全性</h2>
<p>本章中到目前为止，我们已经讨论了Rust怎么保证闭包在借用或者移动环境中的值时遵循语言的安全规则。但还有更多不明显的情况。在这一节中，我们会解释当一个闭包drop或修改一个捕获的值时会发生什么。</p>
<h3 id="杀死值的闭包">杀死值的闭包</h3>
<p>我们已经看到过借用值和偷取值的闭包，但只有它们还不够，还需要更多种类的闭包。</p>
<p>当然， <em>杀死(kill)</em> 并不是真正正确的术语。在Rust中，我们 <em>丢弃(drop)</em> 值。最直观的方法是调用<code>drop()</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">my_str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;hello&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nb">drop</span><span class="p">(</span><span class="n">my_str</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>当调用<code>f</code>时，<code>my_str</code>会被drop。</p>
<p>所以如果我们调用它两次会发生什么？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="n">f</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">f</span><span class="p">();</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>让我们深入思考它。第一次调用<code>f</code>时，它drop了<code>my_str</code>，这意味着存储字符串的内存已经被释放了，返还给了系统。第二次调用<code>f</code>时，会发生同样的事情。这是 <em>两次释放(double free)</em> ，在C++编程中这是一种会导致未定义行为的经典错误。</p>
<p>drop一个<code>String</code>两次在Rust中也是同样的错误行为。幸运的是，Rust不会这么简单就被骗过：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="n">f</span><span class="p">();</span><span class="w">    </span><span class="c1">// ok
</span><span class="c1"></span><span class="w">    </span><span class="n">f</span><span class="p">();</span><span class="w">    </span><span class="c1">// 错误：使用了被move的值
</span></code></pre></td></tr></table>
</div>
</div><p>Rust知道这个闭包不能被调用两次。</p>
<p>一个只能被调用一次的闭包看起来像是一个很特殊的东西，但是我们已经在整本书中都讨论过所有权和生命周期了。值被消耗（即move）的idea是Rust的核心概念之一。它在闭包中的表现和在其他情况中一样。</p>
<h3 id="fnonce"><code>FnOnce</code></h3>
<p>让我们再一次尝试骗过Rust、丢弃一个<code>String</code>两次。这次，我们使用这个泛型函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">cal_twice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">closure</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">F</span>: <span class="nb">Fn</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">closure</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">closure</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这个函数可能被传入任何实现了<code>Fn()</code> trait的闭包：即没有参数并且返回<code>()</code>的闭包。（和函数一样，当返回值是<code>()</code>时可以省略；<code>Fn()</code>是<code>Fn() -&gt; ()</code>的缩写。）</p>
<p>现在如果我们把我们的不安全的闭包传递给这个泛型函数会发生什么？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">my_str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;hello&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nb">drop</span><span class="p">(</span><span class="n">my_str</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">call_twice</span><span class="p">(</span><span class="n">f</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这个闭包仍然在调用时drop <code>my_str</code>。调用它两次将是两次释放。不过Rust仍然没有被迷惑：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-mysql" data-lang="mysql"><span class="w">    </span><span class="n">error</span><span class="p">[</span><span class="n">E0525</span><span class="p">]:</span><span class="w"> </span><span class="n">expected</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">closure</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">implements</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="o">`</span><span class="n">Fn</span><span class="o">`</span><span class="w"> </span><span class="n">trait</span><span class="p">,</span><span class="w"> </span><span class="n">but</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">closure</span><span class="w"> </span><span class="n">only</span><span class="w"> </span><span class="n">implements</span><span class="w"> </span><span class="o">`</span><span class="n">FnOnce</span><span class="o">`</span><span class="w">
</span><span class="w">      </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">closure_twice</span><span class="p">.</span><span class="n">rs</span><span class="p">:</span><span class="mi">12</span><span class="p">:</span><span class="mi">13</span><span class="w">
</span><span class="w">        </span><span class="o">|</span><span class="w">
</span><span class="w">      </span><span class="mi">8</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="k">drop</span><span class="p">(</span><span class="n">my_str</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="o">|</span><span class="w">         </span><span class="o">^^^^^^^^</span><span class="n">______</span><span class="o">^</span><span class="w">
</span><span class="w">        </span><span class="o">|</span><span class="w">         </span><span class="o">|</span><span class="w">       </span><span class="o">|</span><span class="w">
</span><span class="w">        </span><span class="o">|</span><span class="w">         </span><span class="o">|</span><span class="w">       </span><span class="n">closure</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="o">`</span><span class="n">FnOnce</span><span class="o">`</span><span class="w"> </span><span class="n">because</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">moves</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">variable</span><span class="w"> </span><span class="o">`</span><span class="n">my_str</span><span class="o">`</span><span class="w">
</span><span class="w">        </span><span class="o">|</span><span class="w">         </span><span class="o">|</span><span class="w">       </span><span class="k">out</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">its</span><span class="w"> </span><span class="n">environment</span><span class="w">
</span><span class="w">        </span><span class="o">|</span><span class="w">         </span><span class="n">this</span><span class="w"> </span><span class="n">closure</span><span class="w"> </span><span class="n">implements</span><span class="w"> </span><span class="o">`</span><span class="n">FnOnce</span><span class="o">`</span><span class="p">,</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="o">`</span><span class="n">Fn</span><span class="o">`</span><span class="w">
</span><span class="w">      </span><span class="mi">9</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nf">call_twice</span><span class="p">(</span><span class="n">f</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="o">|</span><span class="w"> </span><span class="o">--------</span><span class="c1">-- the requirement to implement `Fn` derives from here
</span></code></pre></td></tr></table>
</div>
</div><p>错误信息告诉了我们更多有关Rust如何处理“杀死值的闭包”的信息。原本Rust可以直接禁止这类闭包，它们有时也是有用的。因此，Rust限制了它们的使用：drop值的闭包，例如<code>f</code>，不允许实现<code>Fn</code>（它们显然也不应该是<code>Fn</code>）。它们实现了一个相对弱一些的trait <code>FnOnce</code>，表示只能调用一次的闭包。</p>
<p>当你第一次调用<code>FnOnce</code>闭包时， <em>闭包本身会被消耗掉(the closure itself is used up)</em> 。<code>Fn</code>和<code>FnOnce</code>这两个trait就好像是以如下方式定义的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="c1">// 没有参数的`Fn`和`FnOnce` trait的伪代码
</span><span class="c1"></span><span class="w">    </span><span class="k">trait</span><span class="w"> </span><span class="nb">Fn</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">R</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">call</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">R</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">trait</span><span class="w"> </span><span class="nb">FnOnce</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">R</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">call_once</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">R</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>就像算术表达式例如<code>a + b</code>是方法调用<code>Add::add(a, b)</code>的缩写一样，Rust把<code>closure()</code>看做是上面的例子中展示的两个闭包方法之一。对于一个<code>Fn</code>闭包，<code>closure()</code>会展开为<code>closure.call()</code>。这个方法以引用获取<code>self</code>，因此闭包本身没有被移动。但如果闭包只有第一次调用时是安全的，那么<code>closure()</code>会展开为<code>closure.call_once()</code>。这个方法以值获取<code>self</code>参数，因此闭包会被消耗掉。</p>
<p>当然，我们一直在故意使用<code>drop</code>制造麻烦。在实际中，你只会偶尔遇到这种情况。它并不会经常发生，但偶尔你会不经意间编写出消耗掉一个值的闭包代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">dict</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">produce_glossary</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">debug_dump_dict</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">dict</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// oops!
</span><span class="c1"></span><span class="w">            </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{:?} - {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>然后，当你调用<code>debug_dump_dict()</code>不止一次时，你会得到一个类似这样的错误信息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-mysql" data-lang="mysql"><span class="w">    </span><span class="n">error</span><span class="p">[</span><span class="n">E0382</span><span class="p">]:</span><span class="w"> </span><span class="k">use</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">moved</span><span class="w"> </span><span class="n">value</span><span class="p">:</span><span class="w"> </span><span class="o">`</span><span class="n">debug_dump_dict</span><span class="o">`</span><span class="w">
</span><span class="w">      </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">closures_debug_dump_dict</span><span class="p">.</span><span class="n">rs</span><span class="p">:</span><span class="mi">18</span><span class="p">:</span><span class="mi">5</span><span class="w">
</span><span class="w">       </span><span class="o">|</span><span class="w">
</span><span class="w">    </span><span class="mi">19</span><span class="w"> </span><span class="o">|</span><span class="w">     </span><span class="nf">debug_dump_dict</span><span class="p">();</span><span class="w">
</span><span class="w">       </span><span class="o">|</span><span class="w">     </span><span class="o">---------------</span><span class="c1">-- `debug_dump_dict` moved due to this call
</span><span class="c1"></span><span class="w">    </span><span class="mi">20</span><span class="w"> </span><span class="o">|</span><span class="w">     </span><span class="nf">debug_dump_dict</span><span class="p">();</span><span class="w">
</span><span class="w">       </span><span class="o">|</span><span class="w">     </span><span class="o">^^^^^^^^^^^^^^^</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="n">used</span><span class="w"> </span><span class="n">here</span><span class="w"> </span><span class="n">after</span><span class="w"> </span><span class="n">move</span><span class="w">
</span><span class="w">    </span><span class="n">note</span><span class="p">:</span><span class="w"> </span><span class="n">closure</span><span class="w"> </span><span class="n">cannot</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">invoked</span><span class="w"> </span><span class="n">more</span><span class="w"> </span><span class="n">than</span><span class="w"> </span><span class="n">once</span><span class="w"> </span><span class="n">because</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">moves</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">variable</span><span class="w">
</span><span class="w">    </span><span class="o">`</span><span class="n">dict</span><span class="o">`</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">its</span><span class="w"> </span><span class="n">environment</span><span class="w">
</span><span class="w">      </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span><span class="p">:</span><span class="mi">13</span><span class="p">:</span><span class="mi">29</span><span class="w">
</span><span class="w">       </span><span class="o">|</span><span class="w">
</span><span class="w">    </span><span class="mi">13</span><span class="w"> </span><span class="o">|</span><span class="w">         </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">key</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">dict</span><span class="w"> </span><span class="err">{</span><span class="w">
</span><span class="w">       </span><span class="o">|</span><span class="w">                             </span><span class="o">^^^^</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>为了调试这个错误，我们需要搞清楚为什么这个闭包是<code>FnOnce</code>。这里什么值被消耗了？编译器友好地指出了是<code>dict</code>，在这个例子中，它也是我们唯一使用的变量。哦，这个bug是：我们直接迭代<code>dict</code>消耗了它。我们应该迭代<code>&amp;dict</code>，以引用访问值，而不是迭代<code>dict</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">debug_dump_dict</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dict</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 不会消耗dict
</span><span class="c1"></span><span class="w">            </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{:?} - {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这样就修复了错误；这个函数现在是<code>Fn</code>，可以被调用任意次。</p>
<h3 id="fnmut"><code>FnMut</code></h3>
<p>还有一种闭包，这种闭包包含可变的数据或者<code>mut</code>引用。</p>
<p>Rust认为non-<code>mut</code>的值可以安全在线程间共享。但在线程间共享包含<code>mut</code>数据的non-<code>mut</code>闭包不是安全的：在多个线程中调用这种闭包可能会导致各种数据竞争，就和多个线程同时读写同一份数据一样。</p>
<p>因此，Rust又分出了一种闭包类别<code>FnMut</code>，这个类别用于有写入操作的闭包。<code>FnMut</code>闭包以<code>mut</code>引用调用，就好像它们被定义为这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="c1">// `Fn`, `FnMut`, `FnOnce` trait的伪代码。
</span><span class="c1"></span><span class="w">    </span><span class="k">trait</span><span class="w"> </span><span class="nb">Fn</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">R</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">call</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">R</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">trait</span><span class="w"> </span><span class="nb">FnMut</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">R</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">call_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">R</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">trait</span><span class="w"> </span><span class="nb">FnOnce</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">R</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">call_once</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">R</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>所有需要值的<code>mut</code>方法，但不会drop任何值的闭包，都是一个<code>FnMut</code>闭包。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">incr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// incr借用了i的一个可变引用
</span><span class="c1"></span><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;Ding! i is now: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="n">call_twice</span><span class="p">(</span><span class="n">incr</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>我们编写的<code>call_twice</code>需要一个<code>Fn</code>。因为<code>incr</code>是一个<code>FnMut</code>而不是<code>Fn</code>，所以这段代码会编译失败。然而，有一种简单的修复方法。为了理解这种修复方法，让我们后退一步，总结一下你学到的有关Rust的三种闭包的知识：</p>
<ul>
<li><code>Fn</code>是你可以没有限制地调用多次的闭包和函数家族。这个最高的类别还包括所有的<code>fn</code>函数。</li>
<li><code>FnMut</code>是如果闭包本身被声明为<code>mut</code>时可以调用多次的闭包家族。</li>
<li><code>FnOnce</code>是当调用者拥有它时可以调用一次的闭包家族。</li>
</ul>
<p>每一个<code>Fn</code>都满足<code>FnMut</code>的要求，每一个<code>FnMut</code>都满足<code>FnOnce</code>的要求。如”图14-2”所示，它们并不是独立的三个类别。</p>
<p><code>Fn()</code>是<code>FnMut()</code>的一个子集，<code>FnMut()</code>又是<code>FnOnce()</code>的一个子集。这使得<code>Fn</code>是最独特和强大的分类。<code>FnMut</code>和<code>FnOnce</code>是范围更广一些的分类，它们包含有一些使用限制的闭包。</p>
<p><figure>
  <picture>

    
      
        
        
        
        
        
        
    <img
      loading="lazy"
      decoding="async"
      alt="三种闭包类别的维恩图"
      
        class="image_figure image_internal image_unprocessed"
        src="../img/f14-2.png"
      
      
    />

    </picture>
</figure>
</p>
<p align="center">图14-2 三种闭包类别的维恩图</p>
<p>现在我们已经梳理了我们所知的内容，显然为了尽可能接受更多的闭包类型，我们的<code>call_twice</code>实际上应该接受所有的<code>FnMut</code>闭包，像这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">call_twice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">closure</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">closure</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">closure</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>原本第一行的约束是<code>F: Fn()</code>，现在是<code>F: FnMut()</code>。有了这个修改之后，我们仍然可以接受所有的<code>Fn</code>闭包，并且现在还可以对可变的数据调用<code>call_twice</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">call_twice</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">  </span><span class="c1">// ok!
</span><span class="c1"></span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="闭包的copy和clone">闭包的<code>Copy</code>和<code>Clone</code></h3>
<p>正如Rust能自动分辨出哪些闭包只能调用一次一样，它也能分辨出哪些闭包可以实现<code>Copy</code>和<code>Clone</code>，哪些不能。</p>
<p>正如我们之前解释的一样，闭包被表示为包含它们捕获的值（<code>move</code>闭包）或者引用（non-<code>move</code>闭包）的结构体。闭包的<code>Copy</code>和<code>Clone</code>的规则就类似于普通结构体的<code>Copy</code>和<code>Clone</code>的规则。一个没有可变变量的non-<code>move</code>的闭包只有共享引用，共享引用是<code>Clone</code>和<code>Copy</code>，所以这种闭包也是<code>Clone</code>和<code>Copy</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">add_y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">copy_of_add_y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">add_y</span><span class="p">;</span><span class="w">                  </span><span class="c1">// 这个闭包是`Copy`，因此...
</span><span class="c1"></span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">add_y</span><span class="p">(</span><span class="n">copy_of_add_y</span><span class="p">(</span><span class="mi">22</span><span class="p">)),</span><span class="w"> </span><span class="mi">42</span><span class="p">);</span><span class="w">   </span><span class="c1">// ...我们可以使用这两个。
</span></code></pre></td></tr></table>
</div>
</div><p>另一方面，一个 <em>有</em> 可变值的non-<code>move</code>闭包在内部的表示中包含可变引用。可变引用既不是<code>Clone</code>也不是<code>Copy</code>，因此这样的一个闭包既不是<code>Copy</code>也不是<code>Clone</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">add_to_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">n</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">copy_of_add_to_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">add_to_x</span><span class="p">;</span><span class="w">                </span><span class="c1">// 移动，而不是拷贝
</span><span class="c1"></span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">add_to_x</span><span class="p">(</span><span class="n">copy_of_add_to_x</span><span class="p">(</span><span class="mi">1</span><span class="p">)),</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w">   </span><span class="c1">// 错误：使用了被移动的值
</span></code></pre></td></tr></table>
</div>
</div><p>对于<code>move</code>闭包来说，规则变得更简单了。如果一个<code>move</code>闭包捕获的所有值都是<code>Copy</code>，那么它也是<code>Copy</code>。如果它捕获的所有值都是<code>Clone</code>，那么它也是<code>Clone</code>。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">greeting</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;Hello, &#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">greet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="n">name</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">greeting</span><span class="p">.</span><span class="n">push_str</span><span class="p">(</span><span class="n">name</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">greeting</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="n">greet</span><span class="p">.</span><span class="n">clone</span><span class="p">()(</span><span class="s">&#34;Alfred&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">greet</span><span class="p">.</span><span class="n">clone</span><span class="p">()(</span><span class="s">&#34;Bruce&#34;</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这个<code>.clone()(...)</code>语法有一点奇怪，但它只是因为我们克隆了闭包然后调用它。这个程序输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="n">Hello</span><span class="p">,</span><span class="w"> </span><span class="n">Alfred</span><span class="w">
</span><span class="w">    </span><span class="n">Hello</span><span class="p">,</span><span class="w"> </span><span class="n">Bruce</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>当<code>greeting</code>在<code>greet</code>中被用到时，它会被移动进表示<code>greet</code>的内部结构体里，因为它是<code>move</code>闭包。因此，当我们克隆<code>greet</code>时，它里面的所有内容都会被克隆。这里有两个<code>greeting</code>的拷贝，当调用克隆的<code>greet</code>时它们会被独立地修改。它本身用处不大，但当你需要把同样的闭包传递给不止一个函数时，它会很有用。</p>
<h2 id="回调">回调</h2>
<p>很多库使用 <em>回调(callback)</em> 作为部分API：一种由用户提供、之后会被库调用的函数。事实上，你已经在这本书中看到过一些这样的API了。回顾”第2章”，我们使用了<code>actix-web</code>框架编写了一个简单的web服务器。程序中很重要的一部分就是路由，看起来像这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="n">App</span>::<span class="n">new</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">route</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">web</span>::<span class="n">get</span><span class="p">().</span><span class="n">to</span><span class="p">(</span><span class="n">get_index</span><span class="p">))</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">route</span><span class="p">(</span><span class="s">&#34;/gcd&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">web</span>::<span class="n">post</span><span class="p">().</span><span class="n">to</span><span class="p">(</span><span class="n">post_gcd</span><span class="p">))</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>路由的目的是把到来的网络请求发送到处理特定请求的函数。在这个例子中，<code>get_index</code>和<code>post_gcd</code>是我们在程序里其他地方用<code>fn</code>关键字声明的函数的名字，但我们也可以传递一个闭包，像这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="n">App</span>::<span class="n">new</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">route</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">web</span>::<span class="n">get</span><span class="p">().</span><span class="n">to</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">HttpResponse</span>::<span class="nb">Ok</span><span class="p">()</span><span class="w">
</span><span class="w">                </span><span class="p">.</span><span class="n">content_type</span><span class="p">(</span><span class="s">&#34;text/html&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">                </span><span class="p">.</span><span class="n">body</span><span class="p">(</span><span class="s">&#34;&lt;title&gt;GCD Calculator&lt;/title&gt;...&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">}))</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">route</span><span class="p">(</span><span class="s">&#34;/gcd&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">web</span>::<span class="n">post</span><span class="p">().</span><span class="n">to</span><span class="p">(</span><span class="o">|</span><span class="n">form</span>: <span class="nc">web</span>::<span class="n">Form</span><span class="o">&lt;</span><span class="n">GcdParameters</span><span class="o">&gt;|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">HttpResponse</span>::<span class="nb">Ok</span><span class="p">()</span><span class="w">
</span><span class="w">                </span><span class="p">.</span><span class="n">content_type</span><span class="p">(</span><span class="s">&#34;text/html&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">                </span><span class="p">.</span><span class="n">body</span><span class="p">(</span><span class="fm">format!</span><span class="p">(</span><span class="s">&#34;The GCD of {} and {} is {}.&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">                              </span><span class="n">form</span><span class="p">.</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">form</span><span class="p">.</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">gcd</span><span class="p">(</span><span class="n">form</span><span class="p">.</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">form</span><span class="p">.</span><span class="n">m</span><span class="p">)))</span><span class="w">
</span><span class="w">        </span><span class="p">}))</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这是因为<code>actix-web</code>被设计为可以接受任何线程安全的<code>Fn</code>作为参数。</p>
<p>那么我们怎么在自己的程序中做到这一点呢？让我们尝试写出我们自己的简单的路由，不使用任何<code>actix-web</code>的代码。我们首先声明一些表示HTTP请求和响应的类型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">struct</span> <span class="nc">Request</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">method</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">url</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">headers</span>: <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span><span class="o">&gt;</span><span class="w">
</span><span class="w">        </span><span class="n">body</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">struct</span> <span class="nc">Response</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">code</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">headers</span>: <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span><span class="o">&gt;</span><span class="w">
</span><span class="w">        </span><span class="n">body</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>现在一个路由器的任务就是简单地存储一个把URL映射到回调函数的表，这样可以按需调用正确的回调函数。（为了简单起见，我们只允许用户创建匹配单个具体URL的路由。）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">struct</span> <span class="nc">BasicRouter</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">C</span>: <span class="nb">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Request</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Response</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">routes</span>: <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">impl</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="w"> </span><span class="n">BasicRouter</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">C</span>: <span class="nb">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Request</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Response</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="sd">/// 创建一个空的路由器。
</span><span class="sd"></span><span class="w">        </span><span class="k">fn</span> <span class="nf">new</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">BasicRouter</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">BasicRouter</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">routes</span>: <span class="nc">HashMap</span>::<span class="n">new</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="sd">/// 向路由器中添加一条路由。
</span><span class="sd"></span><span class="w">        </span><span class="k">fn</span> <span class="nf">add_route</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">url</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">callback</span>: <span class="nc">C</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">routes</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">url</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w"> </span><span class="n">callback</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>不幸的是，我们犯了一个错误。你注意到它了吗？</p>
<p>如果我们只添加一个路由，那么这个路由器可以工作的很好：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">router</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BasicRouter</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">router</span><span class="p">.</span><span class="n">add_route</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="n">get_form_response</span><span class="p">());</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这可以正常编译并运行。然而，如果我们添加另一个路由：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="n">router</span><span class="p">.</span><span class="n">add_route</span><span class="p">(</span><span class="s">&#34;/gcd&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">req</span><span class="o">|</span><span class="w"> </span><span class="n">get_gcd_response</span><span class="p">(</span><span class="n">req</span><span class="p">));</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>那我们会得到错误：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">    error[E0308]: mismatched types
      --&gt; closures_bad_router.rs:41:30
       |
    41 |     router.add_route(&#34;/gcd&#34;, |req| get_gcd_response(req));
       |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^
       |                              expected closure, found a different closure
       |
       = note: expected type `[closure@closures_bad_router.rs:40:27: 40:50]`
                  found type `[closure@closures_bad_router.rs:41:30: 41:57]`
    note: no two closures, even if identical, have the same type
    help: consider boxing your closure and/or using it as a trait object
</code></pre></td></tr></table>
</div>
</div><p>我们的错误在于定义<code>BasicRouter</code>类型的方式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">struct</span> <span class="nc">BasicRouter</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">C</span>: <span class="nb">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Request</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Response</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">routes</span>: <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>我们不知不觉中声明了每个<code>BasicRouter</code>都只有单个回调类型<code>C</code>，并且<code>HashMap</code>里的所有回调函数都是这个类型。回顾“选择哪一种”，我们展示了一个有同样问题的<code>Salad</code>类型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">struct</span> <span class="nc">Salad</span><span class="o">&lt;</span><span class="n">V</span>: <span class="nc">Vegetable</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">veggies</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这里的解决方法和沙拉问题的解决方法一样：因为我们想支持很多类型，我们需要使用box和trait对象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">type</span> <span class="nc">BoxedCallback</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="nb">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Request</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Response</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">struct</span> <span class="nc">BasicRouter</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">routes</span>: <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">BoxedCallback</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>每一个box都可以包含一个不同类型的闭包，因此一个<code>HashMap</code>可以包含很多种类的回调函数。注意类型参数<code>C</code>消失了。</p>
<p>这需要对方法进行一些调整：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="n">BasicRouter</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// 创建一个空的路由器。
</span><span class="c1"></span><span class="w">        </span><span class="k">fn</span> <span class="nf">new</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">BasicRouter</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">BasicRouter</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">routes</span>: <span class="nc">HashMap</span>::<span class="n">new</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="c1">// 向路由器中添加一条路由。
</span><span class="c1"></span><span class="w">        </span><span class="k">fn</span> <span class="nf">add_route</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">url</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">callback</span>: <span class="nc">C</span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="k">where</span><span class="w"> </span><span class="n">C</span>: <span class="nb">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Request</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Response</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">&#39;</span><span class="nb">static</span><span class="w">
</span><span class="w">        </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">routes</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">url</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">callback</span><span class="p">));</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>注意<code>add_route</code>的类型签名中<code>C</code>的两个约束：一个特定的<code>Fn</code> trait和一个<code>'static</code>生命周期。Rust让我们添加这个<code>'static</code>约束。如果没有它，<code>Box::new(callback)</code>的调用将会导致错误，因为如果一个闭包包含可能会离开作用域的变量的引用，那么存储这样的闭包是不安全的。</p>
</blockquote>
<p>最后，我们的简单路由已经准备好处理到来的请求：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="n">BasicRouter</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">handle_request</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">request</span>: <span class="kp">&amp;</span><span class="nc">Request</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Response</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">routes</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">request</span><span class="p">.</span><span class="n">url</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">not_found_response</span><span class="p">(),</span><span class="w">
</span><span class="w">                </span><span class="nb">Some</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">callback</span><span class="p">(</span><span class="n">request</span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>作为灵活性的代价，我们也可以使用 <em>函数指针(function pointer)</em> 或者<code>fn</code>类型来代替trait对象，这样空间效率会高一点。像<code>fn(u32) -&gt; u32</code>这样的类型，和闭包很像：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">add_ten</span><span class="p">(</span><span class="n">x</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">10</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">fn_ptr</span>: <span class="nc">fn</span><span class="p">(</span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="o">=</span><span class="w"> </span><span class="n">add_ten</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">eleven</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fn_ptr</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// 11
</span></code></pre></td></tr></table>
</div>
</div><p>事实上，不捕获环境中任何变量的闭包和函数指针完全相同，因为它们不需要存储关于被捕获变量的额外信息。如果你指定了合适的<code>fn</code>类型，不管是在绑定中还是在函数签名中，编译器都会乐于让你使用它们：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">closure_ptr</span>: <span class="nc">fn</span><span class="p">(</span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">two</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">closure_ptr</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">   </span><span class="c1">// 2
</span></code></pre></td></tr></table>
</div>
</div><p>与那些捕获的闭包不同，这些函数指针只占据一个<code>usize</code>的空间。</p>
<p>函数指针也可以用于实现我们自己的动态分发，而不是使用编译器建议的<code>Box dyn Fn()</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">struct</span> <span class="nc">FnPointerRouter</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">routes</span>: <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Request</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Response</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这里，<code>HashMap</code>只为每一个<code>String</code>存储一个<code>usize</code>，这里没有<code>Box</code>。除了<code>HashMap</code>自身，没有任何动态分配。当然，这些方法也需要被调整：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="n">FnPointerRouter</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// 创建一个空的路由器。
</span><span class="c1"></span><span class="w">        </span><span class="k">fn</span> <span class="nf">new</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">FnPointerRouter</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">FnPointerRouter</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">routes</span>: <span class="nc">HashMap</span>::<span class="n">new</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="c1">// 向路由器中添加一条路由。
</span><span class="c1"></span><span class="w">        </span><span class="k">fn</span> <span class="nf">add_route</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">url</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">callback</span>: <span class="nc">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Request</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Response</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">routes</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">url</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w"> </span><span class="n">callback</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>如”图14-1”所示，闭包会有单独的类型是因为每一个闭包都捕获了不同的变量，因此它们每一个的大小都不同。如果它们不捕获任何内容，就没有任何东西需要存储。在接受回调的函数中使用<code>fn</code>指针，可以限制调用只能使用没有捕获东西的闭包，这样在代码内能获取一些性能和灵活性的改善，但对于使用你的API的用户来说要付出灵活性的代价。</p>
<h2 id="高效地使用闭包">高效地使用闭包</h2>
<p>正如我们所见，Rust的闭包和大多数其他语言的闭包不同。最大的不同是在有GC的语言中，你可以在闭包中使用局部变量，并且不需要考虑生命周期和所有权。没有了GC，事情就变得不一样了。一些在Java、C#、JavaScript中很普遍的设计模式在Rust中如果不做修改将不能工作。</p>
<p>以”图14-3”中的模型-视图-控制器设计模式（简称为MVC）为例。对于用户界面的每一个元素，MVC框架会创建三个对象：一个 <em>模型(model)</em> 表示UI元素的状态，一个 <em>视图(view)</em> 负责它的外观，一个 <em>控制器(controller)</em> 处理用户的交互。过去这些年里有不计其数的MVC的变体被实现，但总体思路都是三个对象以某种方式分配UI职责。</p>
<p><figure>
  <picture>

    
      
        
        
        
        
        
        
    <img
      loading="lazy"
      decoding="async"
      alt="模型-视图-控制器设计模式"
      
        class="image_figure image_internal image_unprocessed"
        src="../img/f14-3.png"
      
      
    />

    </picture>
</figure>
</p>
<p align="center">图14-3 模型-视图-控制器设计模式</p>
<p>这就是问题。通常来讲，如”图14-3”所示，每个对象有另外一个或者另外两个的引用，直接的或者是通过回调函数的。当其中一个发生了变化时，它会通知其他的两个，因此它们也会一起更新。哪一个对象“拥有”其他两个对象的问题永远不会出现。</p>
<p>在Rust中如果不做修改将不能实现这个模式。必须明确所有权，必须消除循环引用。模型和控制器不能有直接到彼此的引用。</p>
<p>Rust的赌注是有更好的替代设计。有时你可以让每一个闭包接受引用作为参数来解决闭包的所有权和生命周期的问题。有时你可以给系统中的每个部分赋予一个数字，然后传递这些数字来代替引用。或者你可以实现一种其中的对象并不是都有彼此引用的MVC的变体。或者将你的工具集建模成单向的数据流架构的非MVC系统，例如Facebook的Flux架构，如”图14-4”所示。</p>
<p><figure>
  <picture>

    
      
        
        
        
        
        
        
    <img
      loading="lazy"
      decoding="async"
      alt="Flux架构，MVC的一个替代"
      
        class="image_figure image_internal image_unprocessed"
        src="../img/f14-4.png"
      
      
    />

    </picture>
</figure>
</p>
<p align="center">图14-4 Flux架构，MVC的一个替代</p>
<p>简单来说，如果你尝试使用Rust的闭包来制造一个“对象之海”，你会遇到很多困难。但有替代的方案。在例子中的这个场景，软件工程这门学科已经开始倾向于替代方案，因为它们更简单。</p>
<p>在下一章中，我们将开始一个闭包真正闪耀的话题。我们将书写一种充分利用Rust闭包的简洁、快速、高效的优势的代码。并且它们写起来很有趣、读起来很轻松、非常实用。下一章：Rust迭代器。</p>

    </div>
<div class="post_comments">
  
  
  
</div>




    <hr>

<div id="gitalk-container"></div>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js" crossorigin="anonymous"></script>
    <script type="text/javascript">
      var gitalk = new Gitalk({
        id: '0001-01-01 00:00:00 \u002b0000 UTC',
        title: '',
        clientID: '72786bf87c19beec6abe',
        clientSecret: '93ce647699b49ea6434332d36b0122a4ad8281ad',
        repo: 'buf1024.github.io',
        owner: 'buf1024',
        admin: ['buf1024'],
        body: decodeURI(location.href)
      });
      gitalk.render('gitalk-container');
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/gitalk/gitalk">comments powered by gitalk.</a></noscript>

  </article>
<aside class="sidebar">
  <section class="sidebar_inner">
    <br>
    


    
    
    <h2 class="mt-4">最新文章</h2>
    <ul class="flex-column">
      <li>
        <a href="https://luoguochun.cn/post/2024-01-13-rust-sqlx-sqlbuilder/" class="nav-link" title="Rust sqlx SQLBuilder">Rust sqlx SQLBuilder</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2024-01-08-vite-engineering-config/" class="nav-link" title="前端工程化配置保姆级教程">前端工程化配置保姆级教程</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-12-26-rust-proc-macro/" class="nav-link" title="rust 过程宏">rust 过程宏</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-09-21-rust-panic/" class="nav-link" title="一行代码让 rustc panic">一行代码让 rustc panic</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-07-19-flutter-muti-window/" class="nav-link" title="Flutter 桌面端多窗口支持">Flutter 桌面端多窗口支持</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-07-04-hiqradio/" class="nav-link" title="hiqradio 一个简单的收音机软件">hiqradio 一个简单的收音机软件</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-03-21-android-https/" class="nav-link" title="android https 抓包">android https 抓包</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-03-16-love-for-insterest/" class="nav-link" title="为爱发电终是不能长久的……">为爱发电终是不能长久的……</a>
      </li>
    </ul>
    <div>
      <h2 class="mt-4 taxonomy" id="categories-section">分类</h2>
      <nav class="tags_nav">
        <a href='https://luoguochun.cn/categories/misc/' class="post_tag button button_translucent" title="misc">
          MISC
          <span class="button_tally">11</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/linux/' class="post_tag button button_translucent" title="linux">
          LINUX
          <span class="button_tally">8</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/tcp/' class="post_tag button button_translucent" title="tcp">
          TCP
          <span class="button_tally">8</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/c/' class="post_tag button button_translucent" title="c">
          C
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/flutter/' class="post_tag button button_translucent" title="flutter">
          FLUTTER
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/rust/' class="post_tag button button_translucent" title="rust">
          RUST
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/python/' class="post_tag button button_translucent" title="python">
          PYTHON
          <span class="button_tally">6</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/c&#43;&#43;/' class="post_tag button button_translucent" title="c&#43;&#43;">
          C&#43;&#43;
          <span class="button_tally">4</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/web/' class="post_tag button button_translucent" title="web">
          WEB
          <span class="button_tally">4</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/gcc/' class="post_tag button button_translucent" title="gcc">
          GCC
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/git/' class="post_tag button button_translucent" title="git">
          GIT
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/reactjs/' class="post_tag button button_translucent" title="reactjs">
          REACTJS
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/unittest/' class="post_tag button button_translucent" title="unittest">
          UNITTEST
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/vim/' class="post_tag button button_translucent" title="vim">
          VIM
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/%E6%9E%84%E6%9E%B6/' class="post_tag button button_translucent" title="构架">
          构架
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/asm/' class="post_tag button button_translucent" title="asm">
          ASM
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/docker/' class="post_tag button button_translucent" title="docker">
          DOCKER
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/go/' class="post_tag button button_translucent" title="go">
          GO
          <span class="button_tally">1</span>
        </a>
        
        
      </nav>
    </div>
    <div>
      <h2 class="mt-4 taxonomy" id="tags-section">标签</h2>
      <nav class="tags_nav">
        <a href='https://luoguochun.cn/tags/c/' class="post_tag button button_translucent" title="c">
          C
          <span class="button_tally">21</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/linux/' class="post_tag button button_translucent" title="linux">
          LINUX
          <span class="button_tally">16</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/c&#43;&#43;/' class="post_tag button button_translucent" title="c&#43;&#43;">
          C&#43;&#43;
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/python/' class="post_tag button button_translucent" title="python">
          PYTHON
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/tcp/' class="post_tag button button_translucent" title="tcp">
          TCP
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/dart/' class="post_tag button button_translucent" title="dart">
          DART
          <span class="button_tally">6</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/flutter/' class="post_tag button button_translucent" title="flutter">
          FLUTTER
          <span class="button_tally">6</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/rust/' class="post_tag button button_translucent" title="rust">
          RUST
          <span class="button_tally">4</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/tdd/' class="post_tag button button_translucent" title="tdd">
          TDD
          <span class="button_tally">4</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/android/' class="post_tag button button_translucent" title="android">
          ANDROID
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/git/' class="post_tag button button_translucent" title="git">
          GIT
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/gtest/' class="post_tag button button_translucent" title="gtest">
          GTEST
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/js/' class="post_tag button button_translucent" title="js">
          JS
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/rust-lib/' class="post_tag button button_translucent" title="rust-lib">
          RUST-LIB
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/vcs/' class="post_tag button button_translucent" title="vcs">
          VCS
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/vim/' class="post_tag button button_translucent" title="vim">
          VIM
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/asm/' class="post_tag button button_translucent" title="asm">
          ASM
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/css/' class="post_tag button button_translucent" title="css">
          CSS
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/gas/' class="post_tag button button_translucent" title="gas">
          GAS
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/gcc/' class="post_tag button button_translucent" title="gcc">
          GCC
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/http/' class="post_tag button button_translucent" title="http">
          HTTP
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/libevent/' class="post_tag button button_translucent" title="libevent">
          LIBEVENT
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/macos/' class="post_tag button button_translucent" title="macos">
          MACOS
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/react-native/' class="post_tag button button_translucent" title="react-native">
          REACT-NATIVE
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/redis/' class="post_tag button button_translucent" title="redis">
          REDIS
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/%E6%9E%84%E6%9E%B6/' class="post_tag button button_translucent" title="构架">
          构架
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/api/' class="post_tag button button_translucent" title="api">
          API
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/bt/' class="post_tag button button_translucent" title="bt">
          BT
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/c&#43;/' class="post_tag button button_translucent" title="c&#43;">
          C&#43;
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/coroutine/' class="post_tag button button_translucent" title="coroutine">
          COROUTINE
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/database/' class="post_tag button button_translucent" title="database">
          DATABASE
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/docker/' class="post_tag button button_translucent" title="docker">
          DOCKER
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/endian/' class="post_tag button button_translucent" title="endian">
          ENDIAN
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/frontend/' class="post_tag button button_translucent" title="frontend">
          FRONTEND
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/gdb/' class="post_tag button button_translucent" title="gdb">
          GDB
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/go/' class="post_tag button button_translucent" title="go">
          GO
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/html/' class="post_tag button button_translucent" title="html">
          HTML
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/https/' class="post_tag button button_translucent" title="https">
          HTTPS
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/jquery/' class="post_tag button button_translucent" title="jquery">
          JQUERY
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/ld/' class="post_tag button button_translucent" title="ld">
          LD
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/logger/' class="post_tag button button_translucent" title="logger">
          LOGGER
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/makefile/' class="post_tag button button_translucent" title="makefile">
          MAKEFILE
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/misc/' class="post_tag button button_translucent" title="misc">
          MISC
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/orm/' class="post_tag button button_translucent" title="orm">
          ORM
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/os/' class="post_tag button button_translucent" title="os">
          OS
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/process/' class="post_tag button button_translucent" title="process">
          PROCESS
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/react/' class="post_tag button button_translucent" title="react">
          REACT
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/rpm/' class="post_tag button button_translucent" title="rpm">
          RPM
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/rsa/' class="post_tag button button_translucent" title="rsa">
          RSA
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/server/' class="post_tag button button_translucent" title="server">
          SERVER
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/sqlalchemy/' class="post_tag button button_translucent" title="sqlalchemy">
          SQLALCHEMY
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/ssh/' class="post_tag button button_translucent" title="ssh">
          SSH
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/ssl/tls/' class="post_tag button button_translucent" title="ssl/tls">
          SSL/TLS
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/vc/' class="post_tag button button_translucent" title="vc">
          VC
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/vite/' class="post_tag button button_translucent" title="vite">
          VITE
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/vue/' class="post_tag button button_translucent" title="vue">
          VUE
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/webui/' class="post_tag button button_translucent" title="webui">
          WEBUI
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/wechat/' class="post_tag button button_translucent" title="wechat">
          WECHAT
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/win32/' class="post_tag button button_translucent" title="win32">
          WIN32
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/windows/' class="post_tag button button_translucent" title="windows">
          WINDOWS
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/wireshark/' class="post_tag button button_translucent" title="wireshark">
          WIRESHARK
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/' class="post_tag button button_translucent" title="微服务">
          微服务
          <span class="button_tally">1</span>
        </a>
        
        
      </nav>
    </div>
  </section>
</aside>

  
</div>
  </main><svg width="0" height="0" class="hidden">
  <symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="facebook">
    <path d="M437 0H75C33.648 0 0 33.648 0 75v362c0 41.352 33.648 75 75 75h151V331h-60v-90h60v-61c0-49.629 40.371-90 90-90h91v90h-91v61h91l-15 90h-76v181h121c41.352 0 75-33.648 75-75V75c0-41.352-33.648-75-75-75zm0 0"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18.001 18.001" id="twitter">
    <path d="M15.891 4.013c.808-.496 1.343-1.173 1.605-2.034a8.68 8.68 0 0 1-2.351.861c-.703-.756-1.593-1.14-2.66-1.14-1.043 0-1.924.366-2.643 1.078a3.56 3.56 0 0 0-1.076 2.605c0 .309.039.585.117.819-3.076-.105-5.622-1.381-7.628-3.837-.34.601-.51 1.213-.51 1.846 0 1.301.549 2.332 1.645 3.089-.625-.053-1.176-.211-1.645-.47 0 .929.273 1.705.82 2.388a3.623 3.623 0 0 0 2.115 1.291c-.312.08-.641.118-.979.118-.312 0-.533-.026-.664-.083.23.757.664 1.371 1.291 1.841a3.652 3.652 0 0 0 2.152.743C4.148 14.173 2.625 14.69.902 14.69c-.422 0-.721-.006-.902-.038 1.697 1.102 3.586 1.649 5.676 1.649 2.139 0 4.029-.542 5.674-1.626 1.645-1.078 2.859-2.408 3.639-3.974a10.77 10.77 0 0 0 1.172-4.892v-.468a7.788 7.788 0 0 0 1.84-1.921 8.142 8.142 0 0 1-2.11.593z"
      ></path>
  </symbol>
  <symbol aria-hidden="true" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="mail">
    <path  d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="calendar">
    <path d="M452 40h-24V0h-40v40H124V0H84v40H60C26.916 40 0 66.916 0 100v352c0 33.084 26.916 60 60 60h392c33.084 0 60-26.916 60-60V100c0-33.084-26.916-60-60-60zm20 412c0 11.028-8.972 20-20 20H60c-11.028 0-20-8.972-20-20V188h432v264zm0-304H40v-48c0-11.028 8.972-20 20-20h24v40h40V80h264v40h40V80h24c11.028 0 20 8.972 20 20v48z"></path>
    <path d="M76 230h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zM76 310h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zM76 390h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zm80-80h40v40h-40z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="github">
    <path d="M255.968 5.329C114.624 5.329 0 120.401 0 262.353c0 113.536 73.344 209.856 175.104 243.872 12.8 2.368 17.472-5.568 17.472-12.384 0-6.112-.224-22.272-.352-43.712-71.2 15.52-86.24-34.464-86.24-34.464-11.616-29.696-28.416-37.6-28.416-37.6-23.264-15.936 1.728-15.616 1.728-15.616 25.696 1.824 39.2 26.496 39.2 26.496 22.848 39.264 59.936 27.936 74.528 21.344 2.304-16.608 8.928-27.936 16.256-34.368-56.832-6.496-116.608-28.544-116.608-127.008 0-28.064 9.984-51.008 26.368-68.992-2.656-6.496-11.424-32.64 2.496-68 0 0 21.504-6.912 70.4 26.336 20.416-5.696 42.304-8.544 64.096-8.64 21.728.128 43.648 2.944 64.096 8.672 48.864-33.248 70.336-26.336 70.336-26.336 13.952 35.392 5.184 61.504 2.56 68 16.416 17.984 26.304 40.928 26.304 68.992 0 98.72-59.84 120.448-116.864 126.816 9.184 7.936 17.376 23.616 17.376 47.584 0 34.368-.32 62.08-.32 70.496 0 6.88 4.608 14.88 17.6 12.352C438.72 472.145 512 375.857 512 262.353 512 120.401 397.376 5.329 255.968 5.329z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 212 212" id="gitlab">
    <path d="M12.3 74.7h54L43.3 3c-1-3.6-6.4-3.6-7.6 0L12.3 74.8z" />
    <path d="M12.3 74.7L.5 111c-1 3.2 0 6.8 3 8.8l101.6 74-92.5-119z"/>
    <path d="M105 193.7l-38.6-119h-54l92.7 119z"/>
    <path d="M105 193.7l38.7-119H66.4l38.7 119z"/>
    <path d="M105 193.7l38.7-119H198l-93 119z"/>
    <path d="M198 74.7l11.6 36.2c1 3 0 6.6-3 8.6l-101.5 74 93-119z"/>
    <path d="M198 74.7h-54.3L167 3c1.2-3.6 6.4-3.6 7.6 0L198 74.8z"/>
  </symbol>
  <symbol viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="rss">
    <circle cx="3.429" cy="20.571" r="3.429"></circle>
    <path d="M11.429 24h4.57C15.999 15.179 8.821 8.001 0 8v4.572c6.302.001 11.429 5.126 11.429 11.428z"></path>
    <path d="M24 24C24 10.766 13.234 0 0 0v4.571c10.714 0 19.43 8.714 19.43 19.429z"></path>
  </symbol>
  <symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="linkedin">
    <path d="M437 0H75C33.648 0 0 33.648 0 75v362c0 41.352 33.648 75 75 75h362c41.352 0 75-33.648 75-75V75c0-41.352-33.648-75-75-75zM181 406h-60V196h60zm0-240h-60v-60h60zm210 240h-60V286c0-16.54-13.46-30-30-30s-30 13.46-30 30v120h-60V196h60v11.309C286.719 202.422 296.93 196 316 196c40.691.043 75 36.547 75 79.688zm0 0"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 612 612" id="to-top">
    <path d="M604.501 440.509L325.398 134.956c-5.331-5.357-12.423-7.627-19.386-7.27-6.989-.357-14.056 1.913-19.387 7.27L7.499 440.509c-9.999 10.024-9.999 26.298 0 36.323s26.223 10.024 36.222 0l262.293-287.164L568.28 476.832c9.999 10.024 26.222 10.024 36.221 0 9.999-10.023 9.999-26.298 0-36.323z"></path>
  </symbol>
  <symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="carly">
    <path d="M504.971 239.029L448 182.059V84c0-46.317-37.682-84-84-84h-44c-13.255 0-24 10.745-24 24s10.745 24 24 24h44c19.851 0 36 16.149 36 36v108c0 6.365 2.529 12.47 7.029 16.971L454.059 256l-47.029 47.029A24.002 24.002 0 0 0 400 320v108c0 19.851-16.149 36-36 36h-44c-13.255 0-24 10.745-24 24s10.745 24 24 24h44c46.318 0 84-37.683 84-84v-98.059l56.971-56.971c9.372-9.372 9.372-24.568 0-33.941zM112 192V84c0-19.851 16.149-36 36-36h44c13.255 0 24-10.745 24-24S205.255 0 192 0h-44c-46.318 0-84 37.683-84 84v98.059l-56.971 56.97c-9.373 9.373-9.373 24.568 0 33.941L64 329.941V428c0 46.317 37.682 84 84 84h44c13.255 0 24-10.745 24-24s-10.745-24-24-24h-44c-19.851 0-36-16.149-36-36V320c0-6.365-2.529-12.47-7.029-16.971L57.941 256l47.029-47.029A24.002 24.002 0 0 0 112 192z"></path>
  </symbol>
  <symbol viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="copy">
    <path d="M23 2.75A2.75 2.75 0 0 0 20.25 0H8.75A2.75 2.75 0 0 0 6 2.75v13.5A2.75 2.75 0 0 0 8.75 19h11.5A2.75 2.75 0 0 0 23 16.25zM18.25 14.5h-7.5a.75.75 0 0 1 0-1.5h7.5a.75.75 0 0 1 0 1.5zm0-3h-7.5a.75.75 0 0 1 0-1.5h7.5a.75.75 0 0 1 0 1.5zm0-3h-7.5a.75.75 0 0 1 0-1.5h7.5a.75.75 0 0 1 0 1.5z"></path>
    <path d="M8.75 20.5a4.255 4.255 0 0 1-4.25-4.25V2.75c0-.086.02-.166.025-.25H3.75A2.752 2.752 0 0 0 1 5.25v16A2.752 2.752 0 0 0 3.75 24h12a2.752 2.752 0 0 0 2.75-2.75v-.75z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512.001 512.001" id="closeme">
    <path d="M284.286 256.002L506.143 34.144c7.811-7.811 7.811-20.475 0-28.285-7.811-7.81-20.475-7.811-28.285 0L256 227.717 34.143 5.859c-7.811-7.811-20.475-7.811-28.285 0-7.81 7.811-7.811 20.475 0 28.285l221.857 221.857L5.858 477.859c-7.811 7.811-7.811 20.475 0 28.285a19.938 19.938 0 0 0 14.143 5.857 19.94 19.94 0 0 0 14.143-5.857L256 284.287l221.857 221.857c3.905 3.905 9.024 5.857 14.143 5.857s10.237-1.952 14.143-5.857c7.811-7.811 7.811-20.475 0-28.285L284.286 256.002z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="open-menu">
    <path d="M492 236H20c-11.046 0-20 8.954-20 20s8.954 20 20 20h472c11.046 0 20-8.954 20-20s-8.954-20-20-20zm0-160H20C8.954 76 0 84.954 0 96s8.954 20 20 20h472c11.046 0 20-8.954 20-20s-8.954-20-20-20zm0 320H20c-11.046 0-20 8.954-20 20s8.954 20 20 20h472c11.046 0 20-8.954 20-20s-8.954-20-20-20z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="instagram">
    <path d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948 0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072 3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.163 6.162 6.163 6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zm0 10.162c-2.209 0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796 0-1.441.645-1.441 1.44s.645 1.44 1.441 1.44c.795 0 1.439-.645 1.439-1.44s-.644-1.44-1.439-1.44z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id=youtube>
    <path d="M19.615 3.184c-3.604-.246-11.631-.245-15.23 0-3.897.266-4.356 2.62-4.385 8.816.029 6.185.484 8.549 4.385 8.816 3.6.245 11.626.246 15.23 0 3.897-.266 4.356-2.62 4.385-8.816-.029-6.185-.484-8.549-4.385-8.816zm-10.615 12.816v-8l8 3.993-8 4.007z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="stackoverflow">
    <path d="M21 27v-8h3v11H0V19h3v8h18z"></path><path d="M17.1.2L15 1.8l7.9 10.6 2.1-1.6L17.1.2zm3.7 14.7L10.6 6.4l1.7-2 10.2 8.5-1.7 2zM7.2 12.3l12 5.6 1.1-2.4-12-5.6-1.1 2.4zm-1.8 6.8l13.56 1.96.17-2.38-13.26-2.55-.47 2.97zM19 25H5v-3h14v3z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="xing">
    <path d="M18.188 0c-.517 0-.741.325-.927.66 0 0-7.455 13.224-7.702 13.657.015.024 4.919 9.023 4.919 9.023.17.308.436.66.967.66h3.454c.211 0 .375-.078.463-.22.089-.151.089-.346-.009-.536l-4.879-8.916c-.004-.006-.004-.016 0-.022L22.139.756c.095-.191.097-.387.006-.535C22.056.078 21.894 0 21.686 0h-3.498zM3.648 4.74c-.211 0-.385.074-.473.216-.09.149-.078.339.02.531l2.34 4.05c.004.01.004.016 0 .021L1.86 16.051c-.099.188-.093.381 0 .529.085.142.239.234.45.234h3.461c.518 0 .766-.348.945-.667l3.734-6.609-2.378-4.155c-.172-.315-.434-.659-.962-.659H3.648v.016z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 71 55" id="discord">
    <path d="M60.1045 4.8978C55.5792 2.8214 50.7265 1.2916 45.6527 0.41542C45.5603 0.39851 45.468 0.440769 45.4204 0.525289C44.7963 1.6353 44.105 3.0834 43.6209 4.2216C38.1637 3.4046 32.7345 3.4046 27.3892 4.2216C26.905 3.0581 26.1886 1.6353 25.5617 0.525289C25.5141 0.443589 25.4218 0.40133 25.3294 0.41542C20.2584 1.2888 15.4057 2.8186 10.8776 4.8978C10.8384 4.9147 10.8048 4.9429 10.7825 4.9795C1.57795 18.7309 -0.943561 32.1443 0.293408 45.3914C0.299005 45.4562 0.335386 45.5182 0.385761 45.5576C6.45866 50.0174 12.3413 52.7249 18.1147 54.5195C18.2071 54.5477 18.305 54.5139 18.3638 54.4378C19.7295 52.5728 20.9469 50.6063 21.9907 48.5383C22.0523 48.4172 21.9935 48.2735 21.8676 48.2256C19.9366 47.4931 18.0979 46.6 16.3292 45.5858C16.1893 45.5041 16.1781 45.304 16.3068 45.2082C16.679 44.9293 17.0513 44.6391 17.4067 44.3461C17.471 44.2926 17.5606 44.2813 17.6362 44.3151C29.2558 49.6202 41.8354 49.6202 53.3179 44.3151C53.3935 44.2785 53.4831 44.2898 53.5502 44.3433C53.9057 44.6363 54.2779 44.9293 54.6529 45.2082C54.7816 45.304 54.7732 45.5041 54.6333 45.5858C52.8646 46.6197 51.0259 47.4931 49.0921 48.2228C48.9662 48.2707 48.9102 48.4172 48.9718 48.5383C50.038 50.6034 51.2554 52.5699 52.5959 54.435C52.6519 54.5139 52.7526 54.5477 52.845 54.5195C58.6464 52.7249 64.529 50.0174 70.6019 45.5576C70.6551 45.5182 70.6887 45.459 70.6943 45.3942C72.1747 30.0791 68.2147 16.7757 60.1968 4.9823C60.1772 4.9429 60.1437 4.9147 60.1045 4.8978ZM23.7259 37.3253C20.2276 37.3253 17.3451 34.1136 17.3451 30.1693C17.3451 26.225 20.1717 23.0133 23.7259 23.0133C27.308 23.0133 30.1626 26.2532 30.1066 30.1693C30.1066 34.1136 27.28 37.3253 23.7259 37.3253ZM47.3178 37.3253C43.8196 37.3253 40.9371 34.1136 40.9371 30.1693C40.9371 26.225 43.7636 23.0133 47.3178 23.0133C50.9 23.0133 53.7545 26.2532 53.6986 30.1693C53.6986 34.1136 50.9 37.3253 47.3178 37.3253Z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 17 18" id="mastodon">
    <path
    fill="#ffffff"
    d="m 15.054695,9.8859583 c -0.22611,1.1632697 -2.02517,2.4363497 -4.09138,2.6830797 -1.0774504,0.12856 -2.1382704,0.24673 -3.2694704,0.19484 -1.84996,-0.0848 -3.30971,-0.44157 -3.30971,-0.44157 0,0.1801 0.0111,0.35157 0.0333,0.51194 0.24051,1.82571 1.81034,1.93508 3.29737,1.98607 1.50088,0.0514 2.8373104,-0.37004 2.8373104,-0.37004 l 0.0617,1.35686 c 0,0 -1.0498104,0.56374 -2.9199404,0.66742 -1.03124,0.0567 -2.3117,-0.0259 -3.80308,-0.42069 -3.23454998,-0.85613 -3.79081998,-4.304 -3.87592998,-7.8024197 -0.026,-1.03871 -0.01,-2.01815 -0.01,-2.83732 0,-3.57732 2.34385998,-4.62587996 2.34385998,-4.62587996 1.18184,-0.54277 3.20976,-0.77101 5.318,-0.7882499985409 h 0.0518 C 9.8267646,0.01719834 11.856025,0.24547834 13.037775,0.78824834 c 0,0 2.34377,1.04855996 2.34377,4.62587996 0,0 0.0294,2.63937 -0.32687,4.47183"/>
 <path
    fill="#000000"
    d="m 12.616925,5.6916583 v 4.3315297 h -1.71607 V 5.8189683 c 0,-0.88624 -0.37289,-1.33607 -1.1187604,-1.33607 -0.82467,0 -1.23799,0.53361 -1.23799,1.58875 v 2.30122 h -1.70594 v -2.30122 c 0,-1.05514 -0.4134,-1.58875 -1.23808,-1.58875 -0.74587,0 -1.11876,0.44983 -1.11876,1.33607 v 4.2042197 h -1.71607 V 5.6916583 c 0,-0.88527 0.22541,-1.58876 0.67817,-2.10922 0.46689,-0.52047 1.07833,-0.78727 1.83735,-0.78727 0.87816,0 1.54317,0.33752 1.98288,1.01267 l 0.42744,0.71655 0.42753,-0.71655 c 0.43961,-0.67515 1.10463,-1.01267 1.9828704,-1.01267 0.75893,0 1.37037,0.2668 1.83735,0.78727 0.45268,0.52046 0.67808,1.22395 0.67808,2.10922"/>
  </symbol>
</svg>

<footer class="footer">
  <div class="footer_inner wrap pale">
    <img src='https://luoguochun.cn/icons/apple-touch-icon.png' class="icon icon_2 transparent" alt="BUF1024">
    <p>Copyright&nbsp;2011-&nbsp;<span class="year"></span>&nbsp;BUF1024. All Rights Reserved</p><a class="to_top" href="#documentTop">
  <svg class="icon">
  <title>to-top</title>
  <use xlink:href="#to-top"></use>
</svg>

</a>

  </div>
</footer>

<script type="text/javascript" src="https://luoguochun.cn/zh-cn/js/bundle.884eccc71c2848fb4aeb15945329b5a857717f0313da00cb46b765b5734cfa64b08ce2609627167129c2de17d9b47ed210682f96a2502ebb3aadc73191740211.js" integrity="sha512-iE7MxxwoSPtK6xWUUym1qFdxfwMT2gDLRrdltXNM&#43;mSwjOJglicWcSnC3hfZtH7SEGgvlqJQLrs6rccxkXQCEQ==" crossorigin="anonymous"></script>
</body>

</html>

<!DOCTYPE html>
<html lang="zh-cn" data-figures=""  class="page"   >

<head>
<title>BUF1024</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">





<meta property="og:locale" content="zh-cn" />

<meta property="og:type" content="article">
<meta name="description" content="trait与泛型 [A] computer scientist tends to be able to deal with nonuniform structures—case 1, case 2, case 3—while a mathematician will tend to want one unifying …" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:creator" content="">
<meta name="twitter:title" content="" />
<meta name="twitter:image" content="https://luoguochun.cn"/>
<meta property="og:url" content="https://luoguochun.cn/prust/ch11/" />
<meta property="og:title" content="" />
<meta property="og:description" content="trait与泛型 [A] computer scientist tends to be able to deal with nonuniform structures—case 1, case 2, case 3—while a mathematician will tend to want one unifying …" />
<meta property="og:image" content="https://luoguochun.cn" />
  <meta name="keywords" content="blog,computer,luoguochun" />

<link rel="apple-touch-icon" sizes="180x180" href="https://luoguochun.cn/icons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://luoguochun.cn/icons/favicon-32x32.png">
<link rel="manifest" href="https://luoguochun.cn/icons/site.webmanifest">

<link rel="canonical" href="https://luoguochun.cn/prust/ch11/">



<link rel="preload" href="https://luoguochun.cn/css/styles.42e2c5f6d8cf9c52872666f8d8b2678ad0c426978b9d78aff3c33b7a1e7f6f97f54bcdaf0518a25fb0fe26367d04f8b07c683b3b38b331cb098daadee06b1f3e.css" integrity = "sha512-QuLF9tjPnFKHJmb42LJnitDEJpeLnXiv88M7eh5/b5f1S82vBRiiX7D&#43;JjZ9BPiwfGg7OzizMcsJjare4GsfPg==" as="style" crossorigin="anonymous">



<link rel="preload" href="https://luoguochun.cn/zh-cn/js/bundle.884eccc71c2848fb4aeb15945329b5a857717f0313da00cb46b765b5734cfa64b08ce2609627167129c2de17d9b47ed210682f96a2502ebb3aadc73191740211.js" as="script" integrity=
"sha512-iE7MxxwoSPtK6xWUUym1qFdxfwMT2gDLRrdltXNM&#43;mSwjOJglicWcSnC3hfZtH7SEGgvlqJQLrs6rccxkXQCEQ==" crossorigin="anonymous">


<link rel="stylesheet" type="text/css" href="https://luoguochun.cn/css/styles.42e2c5f6d8cf9c52872666f8d8b2678ad0c426978b9d78aff3c33b7a1e7f6f97f54bcdaf0518a25fb0fe26367d04f8b07c683b3b38b331cb098daadee06b1f3e.css" integrity="sha512-QuLF9tjPnFKHJmb42LJnitDEJpeLnXiv88M7eh5/b5f1S82vBRiiX7D&#43;JjZ9BPiwfGg7OzizMcsJjare4GsfPg==" crossorigin="anonymous">

</head>

<body data-code="100" data-lines="false" id="documentTop"
  data-lang="zh-cn">

<header class="nav_header" >
  <nav class="nav"><a href='https://luoguochun.cn' class="nav_brand nav_item" title="BUF1024">BUF1024
  <div class="nav_close">
    <div><svg class="icon">
  <title>open-menu</title>
  <use xlink:href="#open-menu"></use>
</svg>
<svg class="icon">
  <title>closeme</title>
  <use xlink:href="#closeme"></use>
</svg>
</div>
  </div>
</a>

    <div class='nav_body nav_body_left'>
      
      
      
        

  <div class="nav_parent">
    <a href="https://luoguochun.cn/" class="nav_item" title="主页">主页 </a>
  </div>
  <div class="nav_parent">
    <a href="https://luoguochun.cn" class="nav_item" title="链接">链接 <img src='https://luoguochun.cn/icons/caret-icon.svg' alt="icon" class="nav_icon"></a>
    <div class="nav_sub">
      <span class="nav_child"></span>
        <a href="https://luoguochun.cn/talib-doc/" class="nav_child nav_item" title="TA 技术分析库">TA 技术分析库</a>
        <a href="https://luoguochun.cn/hiqradio" class="nav_child nav_item" title="hiqadio网络收音机">hiqadio网络收音机</a>
    </div>
  </div>
  <div class="nav_parent">
    <a href="https://luoguochun.cn/about/" class="nav_item" title="关于">关于 </a>
  </div>
      
<div class='follow'>
<div class="color_mode">
  <input type="checkbox" class="color_choice" id="mode">
</div>

</div>

    </div>
  </nav>
</header>

  <main>
  
<div class="grid-inverse wrap content">
  <article class="post_content">
    <h1 class="post_title"></h1>
  <div class="post_meta">
    <span><svg class="icon">
  <title>calendar</title>
  <use xlink:href="#calendar"></use>
</svg>
</span>
    <span class="post_date">
      Jan 1, 0001</span>
    <span class="post_time"> · 39 min read</span>
    <span class="page_only">&nbsp;·
  <div class="post_share">
    分享到:
    <a href="https://twitter.com/intent/tweet?text=&url=https%3a%2f%2fluoguochun.cn%2fprust%2fch11%2f&tw_p=tweetbutton" class="twitter" title="分享到 Twitter" target="_blank" rel="nofollow">
      <svg class="icon">
  <title>twitter</title>
  <use xlink:href="#twitter"></use>
</svg>

    </a>
    <a href="https://www.facebook.com/sharer.php?u=https%3a%2f%2fluoguochun.cn%2fprust%2fch11%2f&t=" class="facebook" title="分享到 Facebook" target="_blank" rel="nofollow">
      <svg class="icon">
  <title>facebook</title>
  <use xlink:href="#facebook"></use>
</svg>

    </a>
    <a href="#linkedinshare" id = "linkedinshare" class="linkedin" title="分享到 LinkedIn" rel="nofollow">
      <svg class="icon">
  <title>linkedin</title>
  <use xlink:href="#linkedin"></use>
</svg>

    </a>
    <a href="https://luoguochun.cn/prust/ch11/" title="Copy Link" class="link link_yank">
      <svg class="icon">
  <title>copy</title>
  <use xlink:href="#copy"></use>
</svg>

    </a>
  </div>
  </span>
  </div>

    <div class="post_body"><h1 id="trait与泛型">trait与泛型</h1>
<p><em>[A] computer scientist tends to be able to deal with nonuniform structures—case 1, case 2, case 3—while a mathematician will tend to want one unifying axiom that governs an entire system.</em></p>
<p align="right">
    ——Donald Knuth
</p>
<p>编程界中最伟大的发现之一就是可以编写处理多种不同类型的代码， <em>即使是还没有定义出来的类型也可以</em> 。这里有两个例子：</p>
<ul>
<li><code>Vec&lt;T&gt;</code>是泛型的：你可以创建一个任意类型的vector，包括你自己定义的类型，即使<code>Vec</code>的作者完全不知道这个类型。</li>
<li>很多类型都有<code>.write()</code>方法，包括<code>File</code>和<code>TcpStream</code>。你的代码可以通过引用获取一个writer(任意的writer)，并向它写入数据。你的代码不需要关心那个writer到底是什么类型。然后，如果有人添加了一个新的writer类型，你的代码将会自动支持它。</li>
</ul>
<p>当然，这并不是什么新鲜的功能。它被称为 <em>多态(polymorphism)</em> ，是20世纪70年代很热门的新的编程语言技术。但现在它已经非常普遍了。Rust使用两个相关的特性来支持多态：trait和泛型。很多程序员可能已经很熟悉这两个概念了，但Rust采用了一种受Haskell的typeclass启发的新方法。</p>
<p><em>trait</em> 是Rust中的接口或抽象基类。首先，它们看起来很像Java或C#中的接口。用于写入字节的trait叫做<code>std::io::Write</code>，它在标准库中的定义看起来像这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">trait</span><span class="w"> </span><span class="n">Write</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">write</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">flush</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">write_all</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这个trait提供了几个方法，我们只展示了前三个。</p>
<p>标准类型<code>File</code>和<code>TcpStream</code>都实现了<code>std::io::Write</code>。<code>Vec&lt;u8&gt;</code>也是。这三个类型都提供<code>.write()</code>、<code>.flush()</code>等方法。使用writer的代码不需要关心它的类型，像这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Write</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">say_hello</span><span class="p">(</span><span class="n">out</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="k">dyn</span><span class="w"> </span><span class="n">Write</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">std</span>::<span class="n">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">out</span><span class="p">.</span><span class="n">write_all</span><span class="p">(</span><span class="s">b&#34;hello world</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="n">out</span><span class="p">.</span><span class="n">flush</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>out</code>的类型是<code>&amp;mut dyn Write</code>，意思是“任何实现了<code>Write</code> trait的值的可变引用”。我们可以把任何这样的值的可变引用传递给<code>say_hello</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">local_file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">create</span><span class="p">(</span><span class="s">&#34;hello.txt&#34;</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">say_hello</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">local_file</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">    </span><span class="c1">// 可以工作
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">bytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[];</span><span class="w">
</span><span class="w">    </span><span class="n">say_hello</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">bytes</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">         </span><span class="c1">// 也可以工作
</span><span class="c1"></span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span><span class="w"> </span><span class="s">b&#34;hello world</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这一章首先展示trait怎么使用、怎么工作、怎么定义自己的trait。但trait的用途比我们目前提到的更多。我们将使用它们给现有类型添加扩展的方法，甚至像<code>str</code>和<code>bool</code>这种内建类型也可以。我们将会解释为什么给一个类型添加trait不会消耗多余的内存，以及如何在没有虚方法开销的情况下使用trait。我们将看到一些Rust提供的用于操作符重载和其他特性的语言内建的trait。我们还将介绍<code>Self</code>类型、关联函数、关联类型。Rust从Haskell中提取了这三个特性，它们可以优雅地解决其他语言中需要通过变通的方法或者hack才能解决的问题。</p>
<p><em>泛型</em> 是Rust中另一种形式的多态。类似于C++的模板，一个泛型函数或类型可以用于多种不同的类型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="sd">/// 给定两个值，找出较小的那个
</span><span class="sd"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">min</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Ord</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value1</span>: <span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">value2</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">T</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">value1</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">value2</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">value1</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">value2</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这个函数中的<code>&lt;T: Ord&gt;</code>意味着<code>min</code>可以用于任何实现了<code>Ord</code> trait的类型<code>T</code>——也就是，任何有序的类型。这样的一个要求被称为 <em>约束(bound)</em> ，因为它列举出了类型<code>T</code>需要满足的限制。编译器会为你实际使用的每一个类型<code>T</code>生成自定义的机器代码。</p>
<p>泛型和trait紧密相关：泛型函数在约束中使用trait来表明它可以用于哪些类型的参数。所以我们还会讨论<code>&amp;mut dyn Write</code>和<code>&lt;T: Write&gt;</code>有哪些相似和不同之处，以及如何在这种两种使用trait的方式中选择。</p>
<h2 id="使用trait">使用trait</h2>
<p>一个trait就是一个给定的类型可能支持也可能不支持的特性。通常，一个trait代表一种能力：一个类型可以做的事情。</p>
<ul>
<li>一个实现了<code>std::io::Write</code>的值可以写入字节。</li>
<li>一个实现了<code>std::iter::Iterator</code>的值可以产生值的序列。</li>
<li>一个实现了<code>std::clone::Clone</code>的值可以产生自身在内存中的克隆。</li>
<li>一个实现了<code>std::fmt::Debug</code>可以使用<code>println!()</code>的<code>{:?}</code>格式说明符进行打印。</li>
</ul>
<p>这4个trait都是Rust标准库的一部分，有很多标准类型都实现了它们。例如：</p>
<ul>
<li><code>std::fs::File</code>实现了<code>Write</code> trait，它把字节写入到本地文件。<code>std::net::TcpStream</code>写入到网络连接。<code>Vec&lt;u8&gt;</code>也实现了<code>Write</code>。在字节vector上调用<code>.write()</code>会往尾部添加数据。</li>
<li><code>Range&lt;i32&gt;</code>(<code>0..10</code>的类型)实现了<code>Iterator</code> trait，一些和切片、哈希表等相关联的迭代器类型也实现了这个trait。</li>
<li>大多数标准库类型实现了<code>Clone</code>。一些例外主要是像<code>TcpStream</code>这样的不仅仅表示内存中的数据的类型。</li>
<li>大多数标准库类型支持<code>Debug</code>。</li>
</ul>
<p>有关trait方法有一个不寻常的规则：trait自身必须在作用域里。否则，所有它的方法都会被隐藏：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">buf</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[];</span><span class="w">
</span><span class="w">    </span><span class="n">buf</span><span class="p">.</span><span class="n">write_all</span><span class="p">(</span><span class="s">b&#34;hello&#34;</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">   </span><span class="c1">// 错误：没有叫`write_all`的方法
</span></code></pre></td></tr></table>
</div>
</div><p>这种情况下，编译器会打印出友好的错误消息建议你添加<code>std::io::Write</code>，然后确实能修复这个问题：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Write</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">buf</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[];</span><span class="w">
</span><span class="w">    </span><span class="n">buf</span><span class="p">.</span><span class="n">write_all</span><span class="p">(</span><span class="s">b&#34;hello&#34;</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">   </span><span class="c1">// ok
</span></code></pre></td></tr></table>
</div>
</div><p>Rust会有这个规则是因为，正如我们稍后会在本章中看到的，你可以使用trait来给任意类型添加新的方法——即使是标准库的类型例如<code>u32</code>和<code>str</code>。第三方的crate也可以做同样的事情。显然，这会导致名称冲突！但因为Rust让你自己导入你需要使用的trait，所以crate可以轻松地利用这种强大的功能。要想导致冲突，你需要导入两个trait，这两个trait要给同一个类型添加相同名称的方法。这在实践中是很少见的。（如果你确实陷入了冲突中，你可以使用本章稍后会介绍的“完全限定方法调用”来指明你想要使用哪一个。）</p>
<p><code>Clone</code>和<code>Iterator</code>的方法不需要特殊的导入是因为它们默认总是在作用域里，它们是标准prelude的一部分：Rust会自动导入每个模块中的名称。事实上，prelude就是一个精心挑选的trait的集合。我们将在”第13章”中介绍更多有关它们的内容。</p>
<p>C++和C#程序员可能已经注意到了trait方法很像虚方法。然而，类似上面的函数调用速度很快，与任何其他方法调用一样快。简单来说，这里面并没有多态性。显然<code>buf</code>是一个vector，不是一个文件或者网络连接，所以编译器可以简单地生成一个<code>Vec&lt;u8&gt;::write()</code>的调用。它甚至可以内联这个方法。（C++和C#通常也会这样，尽管子类化的可能性有时会排除这一点。）只有通过<code>&amp;mut dyn Write</code>的调用才会有动态分发的开销，这种调用也被称为虚方法调用，类型里的<code>dyn</code>关键字暗示了这一点。<code>dyn Write</code>被称为 <em>trait对象(trait object)</em> ；我们将会在接下来的小节中看到trait对象的技术细节，以及它们与泛型函数的比较。</p>
<h3 id="trait对象">trait对象</h3>
<p>在Rust中有两种使用trait来编写多态代码的方式：trait对象和泛型。我们将会首先介绍trait对象，在下一节中介绍泛型。</p>
<p>Rust不允许<code>dyn Write</code>类型的变量：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Write</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">buf</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[];</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">writer</span>: <span class="nc">dyn</span><span class="w"> </span><span class="n">Write</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buf</span><span class="p">;</span><span class="w"> </span><span class="c1">// 错误：`Write`并没有固定的大小
</span></code></pre></td></tr></table>
</div>
</div><p>一个变量的大小必须在编译期时已知，然而实现了<code>Write</code>的类型可以是任何大小。</p>
<p>如果你来自C#或者Java的话可能会感觉很惊讶，但原因其实很简单。在Java中，一个<code>OutputStream</code>（Java中类似<code>std::io::Write</code>的标准接口）类型的变量是一个任何实现了<code>OutputStream</code>的对象的引用。它是一个引用的事实不言而喻，C#以及其他大多数语言中的接口也是一样。</p>
<p>我们在Rust中想要的也是一样的，但是在Rust中引用是显式的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">buf</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[];</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">writer</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="k">dyn</span><span class="w"> </span><span class="n">Write</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">buf</span><span class="p">;</span><span class="w">  </span><span class="c1">// ok
</span></code></pre></td></tr></table>
</div>
</div><p>一个trait类型的引用，例如<code>writer</code>，被称为一个 <em>trait对象</em> 。和其他引用一样，一个trait对象指向某个值、它有生命周期、它可以是可变的或者是共享的。</p>
<p>让一个trait对象与众不同的是Rust在编译期通常不知道被引用值的类型是什么。因此一个trait对象包括一点额外的有关被引用值的类型信息。类型信息被严格限制为只有Rust自己可以在幕后使用：当你调用<code>writer.write(data)</code>时，Rust需要这个类型信息来依据<code>*writer</code>的类型动态调用正确的<code>write</code>方法。你不能直接查询类型信息，Rust也不支持将trait对象<code>&amp;mut dyn Write</code>向下转换回精确的类型例如<code>Vec&lt;u8&gt;</code>。</p>
<h4 id="trait对象的布局">trait对象的布局</h4>
<p>在内存中，一个trait对象是一个胖指针，由指向值的指针加上一个指向表示该值类型的表的指针组成。因此每一个trait对象要占两个机器字，如”图11-1”所示。</p>
<p><figure>
  <picture>

    
      
        
        
        
        
        
        
    <img
      loading="lazy"
      decoding="async"
      alt="内存中的trait对象"
      
        class="image_figure image_internal image_unprocessed"
        src="../img/f11-1.png"
      
      
    />

    </picture>
</figure>
</p>
<p align="center">图11-1 内存中的trait对象</p>
<p>C++也有这种运行时的类型信息。它被称为 <em>虚表</em> 或者 <em>vtable</em> 。在Rust中和在C++中一样，vtable只会在编译期生成一次，然后被所有相同类型的对象共享。”图11-1”中较深颜色的阴影显示的内容，包括vtable，都是Rust的私有实现。这些字段和数据结构你不能直接访问。当你调用trait对象的方法时语言本身会自动使用vtable来决定要调用哪个实现。</p>
<p>熟练的C++程序员可能会注意到Rust和C++采取的内存策略有些不同。在C++中，虚表指针或者称为 <em>vptr</em> 被存储为结构体的一部分，而Rust使用胖指针来代替。结构体本身不包含任何自身字段之外的东西。这样，一个结构体可以实现一大堆trait而不需要包含一大堆vptr。即使像<code>i32</code>这样的大小还不足以容纳一个vptr的类型，也可以实现trait。</p>
<p>当需要时Rust会自动把普通引用转换为trait对象。这就是为什么我们能在这个例子中直接把<code>&amp;mut local_file</code>传递给<code>say_hello</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">local_file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">create</span><span class="p">(</span><span class="s">&#34;hello.txt&#34;</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">say_hello</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">local_file</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>&amp;mut local_file</code>的类型是<code>&amp;mut File</code>，而<code>say_hello</code>的参数类型是<code>&amp;mut dyn Write</code>。因为<code>File</code>是一种writer，所以Rust允许这种普通引用到trait对象的转换。</p>
<p>同样的，Rust也乐于把<code>Box&lt;File&gt;</code>转换成<code>Box&lt;dyn Write&gt;</code>，它拥有一个在堆上的writer：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">w</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">Write</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">local_file</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>Box&lt;dyn Write&gt;</code>和<code>&amp;mut dyn Write</code>一样是一个胖指针：它包含writer自身的地址和vtable的地址。其他指针类型例如<code>Rc&lt;dyn Write&gt;</code>也一样。</p>
<p>这种转换是唯一创建trait对象的方法。编译器做的工作其实很简单，当转换发生时，Rust知道被引用值的真正类型（这个例子中是<code>File</code>），因此它只是加上了正确的vtable的地址、把普通指针变成了胖指针。</p>
<h3 id="泛型函数和类型参数">泛型函数和类型参数</h3>
<p>在这一章的开始处，我们展示了<code>say_hello()</code>函数，它以trait对象为参数。让我们把这个函数重写为泛型函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">say_hello</span><span class="o">&lt;</span><span class="n">W</span>: <span class="nc">Write</span><span class="o">&gt;</span><span class="p">(</span><span class="n">out</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">W</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">std</span>::<span class="n">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">out</span><span class="p">.</span><span class="n">write_all</span><span class="p">(</span><span class="s">b&#34;hello world</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="n">out</span><span class="p">.</span><span class="n">flush</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>只有类型签名改变了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">say_hello</span><span class="p">(</span><span class="n">out</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="k">dyn</span><span class="w"> </span><span class="n">Write</span><span class="p">)</span><span class="w">   </span><span class="c1">// 普通函数
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">say_hello</span><span class="o">&lt;</span><span class="n">W</span>: <span class="nc">Write</span><span class="o">&gt;</span><span class="p">(</span><span class="n">out</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">W</span><span class="p">)</span><span class="w"> </span><span class="c1">// 泛型函数
</span></code></pre></td></tr></table>
</div>
</div><p>让函数变为泛型函数的正是<code>&lt;W: Write&gt;</code>短语，它是一个 <em>类型参数</em> 。它意味着在整个函数体内，<code>W</code>代表任何实现了<code>Write</code> trait的类型。按照习惯，类型参数通常是大写字母。</p>
<p>类型<code>W</code>到底是什么取决于泛型函数如何被调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="n">say_hello</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">local_file</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">    </span><span class="c1">// 调用say_hello::&lt;File&gt;
</span><span class="c1"></span><span class="w">    </span><span class="n">say_hello</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">bytes</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">         </span><span class="c1">// 调用say_hello::&lt;Vec&lt;u8&gt;&gt;
</span></code></pre></td></tr></table>
</div>
</div><p>当你把<code>&amp;mut local_file</code>传递给泛型的<code>say_hello()</code>函数时，你实际是在调用<code>say_hello::&lt;File&gt;()</code>。Rust会为这个函数生成机器码，机器码里还会调用<code>File::write_all()</code>和<code>File::flush()</code>。当你传递<code>&amp;mut bytes</code>时，你实际是在调用<code>say_hello::&lt;Vec&lt;u8&gt;&gt;()</code>。Rust会为这个版本的函数生成单独的机器码，然后调用相应的<code>Vec&lt;u8&gt;</code>的方法。在这两种情况下，Rust都从参数的类型推导出类型<code>W</code>，这个过程被称为 <em>单态化(monomorphization)</em> ，编译器会自动进行处理。</p>
<p>你也可以指明类型参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="n">say_hello</span>::<span class="o">&lt;</span><span class="n">File</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">local_file</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>很少情况下才需要显式写出参数，因为Rust通常可以通过参数推断出类型参数。这里，<code>say_hello</code>泛型函数期望一个<code>&amp;mut W</code>参数，而我们传入了一个<code>&amp;mut File</code>，因此Rust推断出<code>W = File</code>。</p>
<p>如果你正在调用的泛型函数并没有足以推断出参数的线索，你需要显式地指明：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="c1">// 调用一个没有参数的泛型方法collect&lt;C&gt;()
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="mi">1000</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w">     </span><span class="c1">// 错误：不能推断出类型
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="mi">1000</span><span class="p">).</span><span class="n">collect</span>::<span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;&gt;</span><span class="p">();</span><span class="w"> </span><span class="c1">// ok
</span></code></pre></td></tr></table>
</div>
</div><p>有时我们需要一个类型参数可以支持多种功能。例如，如果我们想打印出一个vector中出现次数最多的10个值，我们需要这些值可以打印：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span>::<span class="n">Debug</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">top_ten</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Debug</span><span class="o">&gt;</span><span class="p">(</span><span class="n">values</span>: <span class="kp">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>但这还不够。我们怎么判断哪个值是出现次数最多的？通常的办法是把每个值当作键存入一个哈希表。这意味着这些值需要支持<code>Hash</code>和<code>Eq</code>操作。<code>T</code>的约束还必须包括<code>Debug</code>。这种情况下应该使用的语法是<code>+</code>号：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>:#<span class="err">️⃣</span>:<span class="nc">Hash</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span>::<span class="n">Debug</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">top_ten</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Debug</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Hash</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Eq</span><span class="o">&gt;</span><span class="p">(</span><span class="n">values</span>: <span class="kp">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>一些类型实现了<code>Debug</code>、一些实现了<code>Hash</code>、一些支持<code>Eq</code>，还有少数类型例如<code>u32</code>和<code>String</code>，实现了这三个trait，如”图11-2”所示。</p>
<p><figure>
  <picture>

    
      
        
        
        
        
        
        
    <img
      loading="lazy"
      decoding="async"
      alt="trait作为类型的集合"
      
        class="image_figure image_internal image_unprocessed"
        src="../img/f11-2.png"
      
      
    />

    </picture>
</figure>
</p>
<p align="center">图11-2 trait作为类型的集合</p>
<p>也可以不给类型参数指定任何约束，但这样的话你几乎不能对它进行任何操作。你只能移动它、将它放在box或vector里。</p>
<p>泛型函数可以有多个类型参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="sd">/// 在一个大规模的分区数据集上进行查询。
</span><span class="sd"></span><span class="w">    </span><span class="sd">/// 见&lt;http://research.google.com/archive/mapreduce.html&gt;。
</span><span class="sd"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">run_query</span><span class="o">&lt;</span><span class="n">M</span>: <span class="nc">Mapper</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Serialize</span><span class="p">,</span><span class="w"> </span><span class="n">R</span>: <span class="nc">Reducer</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Serialize</span><span class="o">&gt;</span><span class="p">(</span><span class="w">
</span><span class="w">        </span><span class="n">data</span>: <span class="kp">&amp;</span><span class="nc">DataSet</span><span class="p">,</span><span class="w"> </span><span class="n">map</span>: <span class="nc">M</span><span class="p">,</span><span class="w"> </span><span class="n">reduce</span>: <span class="nc">R</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Results</span><span class="w">
</span><span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>正如这个例子展示的一样，约束可能太长以至于很难阅读。Rust提供了使用关键字<code>where</code>的替代语法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">run_query</span><span class="o">&lt;</span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span>: <span class="kp">&amp;</span><span class="nc">DataSet</span><span class="p">,</span><span class="w"> </span><span class="n">map</span>: <span class="nc">M</span><span class="p">,</span><span class="w"> </span><span class="n">reduce</span>: <span class="nc">R</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Results</span><span class="w">
</span><span class="w">        </span><span class="k">where</span><span class="w"> </span><span class="n">M</span>: <span class="nc">Mapper</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Serialize</span><span class="p">,</span><span class="w">
</span><span class="w">              </span><span class="n">R</span>: <span class="nc">Reducer</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Serialize</span><span class="w">
</span><span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>类型参数<code>M</code>和<code>R</code>仍然在前边声明，但约束被移动到单独的行。这种<code>where</code>语法可以用于泛型结构体、泛型枚举、类型别名以及方法——任何允许约束的地方。</p>
<p>当然，<code>where</code>语法的一个替代是保持简单：寻找一种不需要大量使用泛型的方法来编写程序。</p>
<p>“引用作为函数参数”介绍了生命周期的语法。一个泛型函数可以同时有生命周期参数和类型参数。生命周期参数在前：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="sd">/// 返回`candidates`中距离`target`最近的点的引用。
</span><span class="sd"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">nearest</span><span class="o">&lt;&#39;</span><span class="na">t</span><span class="p">,</span><span class="w"> </span><span class="o">&#39;</span><span class="na">c</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="n">target</span>: <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">t</span> <span class="nc">P</span><span class="p">,</span><span class="w"> </span><span class="n">candidates</span>: <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">c</span> <span class="p">[</span><span class="n">P</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">c</span> <span class="nc">P</span><span class="w">
</span><span class="w">        </span><span class="k">where</span><span class="w"> </span><span class="n">P</span>: <span class="nc">MeasureDistance</span><span class="w">
</span><span class="w">    </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这个函数有两个参数：<code>target</code>和<code>candidates</code>。它们都是引用，但我们给了它们不同的生命周期<code>'t</code>和<code>'c</code>（正如在“不同的生命周期参数”中讨论的那样）。这个函数可以用于任何实现了<code>MeasureDistance</code> trait的类型<code>P</code>，因此我们可以在一个程序中用<code>Point2d</code>值调用它，而在另一个程序中用<code>Point3d</code>值调用它。</p>
<p>生命周期绝不会影响到机器码。两个<code>P</code>的类型相同但生命周期不同的<code>nearest()</code>的调用，将会调用同一个编译好的函数。只有不同的类型才会导致Rust编译一个泛型函数的多个拷贝。</p>
<p>当然，函数并不是Rust中唯一的泛型代码：</p>
<ul>
<li>我们已经在“泛型结构体”和“泛型枚举”中介绍过泛型类型了。</li>
<li>一个单独的方法也可以是泛型的，就算定义它的类型不是泛型的：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="k">impl</span><span class="w"> </span><span class="n">PancakeStack</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">push</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Topping</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">goop</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">PancakeResult</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">goop</span><span class="p">.</span><span class="n">pour</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">absorb_topping</span><span class="p">(</span><span class="n">goop</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>类型别名也可以是泛型的：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="k">type</span> <span class="nc">PancakeResult</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">PancakeError</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>我们将在本章稍后介绍泛型trait。</li>
</ul>
<p>所有这一节中介绍的特性——约束、<code>where</code>子句、生命周期参数等——可以被用于所有泛型item，而不仅仅是函数。</p>
<h3 id="选择哪一种">选择哪一种</h3>
<p>选择trait对象还是泛型代码是一件很微妙的事情。因为它们都基于trait，有很多相似之处。</p>
<p>任何当你需要一个混合类型的值的集合的情况下trait对象都是正确的选择。从技术上讲创建泛型的沙拉是可行的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">trait</span><span class="w"> </span><span class="n">Vegetable</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">struct</span> <span class="nc">Salad</span><span class="o">&lt;</span><span class="n">V</span>: <span class="nc">Vegetable</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">veggies</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>然而，这是一个非常糟糕的设计。每一个这样的沙拉都全部是由单一类型的蔬菜组成的。不是所有人都适合这么做，本书的作者之一曾经为一个<code>Salad&lt;IcebergLettuce&gt;</code>支付了$14美元，并且直到现在也没有忘记那次经历。</p>
<p>然而我们怎么构建一个更好的沙拉呢？因为<code>Vegetable</code>值可能是不同大小的，我们不能要求Rust创建一个<code>Vec&lt;dyn Vegetable&gt;</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">struct</span> <span class="nc">Salad</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">veggies</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">Vegetable</span><span class="o">&gt;</span><span class="w"> </span><span class="c1">// 错误：`dyn Vegetable`并
</span><span class="c1"></span><span class="w">                                    </span><span class="c1">// 没有固定大小
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>trait对象就是解决方案:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">struct</span> <span class="nc">Salad</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">veggies</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">Vegetable</span><span class="o">&gt;&gt;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>每一个<code>Box&lt;dyn Vegetable&gt;</code>可以持有任何类型的蔬菜，但box自身的大小是固定的——两个指针——因此可以存储在vector中。除了在食物里放盒子这个不幸的比喻之外，它确实就是我们需要的。它也同样适用于绘图应用中的形状、游戏中的怪物、网络路由器中的可插拔路由算法等等。</p>
<p>另一个使用trait对象的可能的原因是减小编译出的代码的体积。Rust可能需要编译一个泛型函数很多次，因为它要为每一个用到的类型都编译一次。这可能导致生成的二进制文件很大，这种现象在C++圈子里称为 <em>代码膨胀(code bloat)</em> 。近年来内存越来越充裕，因此我们中的大多数人可以忽略代码的体积，但确实还有一些受限制的环境。</p>
<p>除了涉及到沙拉或者资源受限的环境之外，泛型与trait对象相比有三个优势。因此在Rust中泛型是更加普遍的选择。</p>
<p>第一个优势是速度。注意泛型函数签名中没有<code>dyn</code>关键字。因为你在编译期指明了确切的类型，不管是显式还是通过类型推导，编译器都知道实际上调用了哪个<code>write</code>。没有使用<code>dyn</code>关键字是因为没有trait对象——因此也没有涉及动态分发。</p>
<p>引言中展示的泛型<code>min()</code>函数就和我们单独编写<code>min_u8</code>、<code>min_i64</code>、<code>min_string</code>等函数一样快。编译器还可以像其他函数一样内联它，因此在release构建中，一个对<code>min::&lt;i32&gt;</code>的调用可能只有两三条指令。对于常量的调用，例如<code>min(5, 3)</code>可能会更快：Rust可以在编译期对它进行求值，因此不会有任何运行时开销。</p>
<p>或者考虑这个泛型函数调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">sink</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">sink</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">say_hello</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">sink</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>std::io::sink()</code>返回一个<code>Sink</code>类型的writer，它会偷偷丢弃掉所有写入的字节。</p>
<p>当Rust为此生成机器码的时候，它可以产生先调用<code>Sink::write_all</code>、再检查错误、最后调用<code>Sink::flush</code>的代码。这正是泛型函数体的内容。</p>
<p>或者，Rust可以查看那些方法，然后意识到下列情况：</p>
<ul>
<li><code>Sink::write_all()</code>什么也不做。</li>
<li><code>Sink:flush()</code>什么也不做。</li>
<li>两个方法都不可能返回错误。</li>
</ul>
<p>简单来说，Rust拥有所有优化掉这个函数调用所需的信息。</p>
<p>相比与trait对象的行为，Rust直到运行时才能知道一个trait对象指向的值到底是什么类型。因此即使你传递了一个<code>Sink</code>，虚方法的调用开销和检查错误的开销仍然不可避免。</p>
<p>泛型的第二个优势是有的trait不支持trait对象。trait只支持一部分特性，例如关联函数只能使用泛型，这样就完全排除了trait对象。当我们讲到这些特性时会指出它们。</p>
<p>泛型的第三个优势是可以很容易地一次给泛型类型参数添加多个trait约束，例如我们的<code>top_ten</code>函数就要求它的参数<code>T</code>要实现<code>Debug + Hash + Eq</code>。trait对象不能这么做：Rust不支持类似<code>&amp;mut (dyn Debug + Hash + Eq)</code>这样的类型。（你可以用本章中稍后会讲到的”子trait”来实现类似的功能，但这样有点复杂。）</p>
<h2 id="定义和实现trait">定义和实现trait</h2>
<p>定义一个trait很简单，只需要给出名字和trait方法的签名类型。假设我们在编写一个游戏，我们可能会定义像这样的trait：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="sd">/// 一个角色、物品、风景等
</span><span class="sd"></span><span class="w">    </span><span class="sd">/// 任何可以显示在屏幕上的游戏世界的物体。
</span><span class="sd"></span><span class="w">    </span><span class="k">trait</span><span class="w"> </span><span class="n">Visible</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="sd">/// 在给定的画布上渲染这个对象。
</span><span class="sd"></span><span class="w">        </span><span class="k">fn</span> <span class="nf">draw</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">canvas</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Canvas</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="sd">/// 如果点击(x, y)会选中这个对象就返回true。
</span><span class="sd"></span><span class="w">        </span><span class="k">fn</span> <span class="nf">hit_test</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>为了实现一个trait，需要使用语法<code>impl TraitName for Type</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="n">Visible</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Broom</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">draw</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">canvas</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Canvas</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="n">canvas</span><span class="p">.</span><span class="n">write_at</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;|&#39;</span><span class="p">);</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">            </span><span class="n">canvas</span><span class="p">.</span><span class="n">write_at</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="o">&#39;</span><span class="na">M</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">hit_test</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">x</span><span class="w">
</span><span class="w">            </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">y</span><span class="w">
</span><span class="w">            </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>注意<code>impl</code>包含了一份<code>Visible</code> trait中每个方法的实现，除此之外没有别的内容。在trait <code>impl</code>中定义的任何东西都必须是trait的特性。如果我们想要添加一个<code>Broom::draw()</code>的帮助函数，我们必须在单独的<code>impl</code>块中定义它：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="n">Broom</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="sd">/// 下面的Broom::draw()用到的帮助函数。
</span><span class="sd"></span><span class="w">        </span><span class="k">fn</span> <span class="nf">broomstick_range</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Range</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这些帮助函数可以在trait <code>impl</code>块中使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="n">Visible</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Broom</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">draw</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">canvas</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Canvas</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">broomstick_range</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">            </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="默认方法">默认方法</h3>
<p>我们之前讨论的<code>Sink</code> writer可以用少数几行代码实现。首先，我们定义如下类型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="sd">/// 一个忽略写入数据的writer
</span><span class="sd"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Sink</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>Sink</code>是一个空结构体，因为我们不需要在里面存储任何数据。接下来，我们为<code>Sink</code>提供了一份<code>Write</code> trait的实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="p">{</span><span class="n">Write</span><span class="p">,</span><span class="w"> </span><span class="nb">Result</span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="n">Write</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Sink</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">write</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="c1">// 假装成功写入了整个缓冲区
</span><span class="c1"></span><span class="w">            </span><span class="nb">Ok</span><span class="p">(</span><span class="n">buf</span><span class="p">.</span><span class="n">len</span><span class="p">())</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">flush</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>到目前为止，这和<code>Visible</code> trait很像。但是我们展示过<code>Write</code> trait还有一个<code>write_all</code>方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Sink</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">out</span><span class="p">.</span><span class="n">write_all</span><span class="p">(</span><span class="s">b&#34;hello world</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>为什么Rust允许我们<code>impl Write for Sink</code>时不定义<code>write_all</code>方法？答案就是标准库中<code>Write</code> trait的定义中包含了一个<code>write_all</code>的 <em>默认实现</em> ：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">trait</span><span class="w"> </span><span class="n">Write</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">write</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">flush</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">        
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">write_all</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="mi">8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">bytes_written</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="k">while</span><span class="w"> </span><span class="n">bytes_written</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">buf</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="n">bytes_written</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">bytes_written</span><span class="o">..</span><span class="p">])</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">            </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">            
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>write</code>和<code>flush</code>方法是每一个writer必须实现的基本方法。一个writer可能也实现了<code>write_all</code>，但如果没有，将会使用我们上边展示的默认实现。</p>
<p>你自己的trait也可以使用相同的语法包含默认实现。</p>
<p>默认方法最有戏剧性的使用是在标准库的<code>Iterator</code> trait，它只有一个需要实现的方法<code>.next()</code>，和一堆默认实现的方法。”第15章”中会解释原因。</p>
<h3 id="trait和其他人的类型">trait和其他人的类型</h3>
<p>Rust允许你在任意类型上实现任意trait，只要trait或者类型是在当前crate中定义的。</p>
<p>这意味着任何时候如果你想给任何类型添加一个方法，你都可以用trait来做到这一点：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">trait</span><span class="w"> </span><span class="n">IsEmoji</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">is_emoji</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="sd">/// 为内建的字符类型实现IsEmoji方法
</span><span class="sd"></span><span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="n">IsEmoji</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">is_emoji</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="sc">&#39;$&#39;</span><span class="p">.</span><span class="n">is_emoji</span><span class="p">(),</span><span class="w"> </span><span class="kc">false</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>类似于其他trait方法，只有当<code>IsEmoji</code>在作用域中时新的<code>is_emoji</code>方法才可见。</p>
<p>这个trait的唯一目的就是给现有类型<code>char</code>添加一个方法。这被称为 <em>扩展trait(extension trait)</em> 。当然，你可以把这个trait添加给其他类型，例如<code>impl IsEmoji for str { ... }</code>等。</p>
<p>你甚至可以使用泛型<code>impl</code>块来一次性给一整个家族的类型添加一个扩展trait。这个trait可以在任何类型上实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="p">{</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">Write</span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="sd">/// trait for values to which you can send HTML.
</span><span class="sd"></span><span class="w">    </span><span class="k">trait</span><span class="w"> </span><span class="n">WriteHtml</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">write_html</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">html</span>: <span class="kp">&amp;</span><span class="nc">HtmlDocument</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>为所有writer实现这个trait，可以为所有Rust writer添加这个方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="sd">/// 你可以向任意std::io writer写入HTML
</span><span class="sd"></span><span class="w">    </span><span class="k">impl</span><span class="o">&lt;</span><span class="n">W</span>: <span class="nc">Write</span><span class="o">&gt;</span><span class="w"> </span><span class="n">WriteHtml</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">W</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">write_html</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">html</span>: <span class="kp">&amp;</span><span class="nc">HtmlDocument</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="n">Reuslt</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>impl&lt;W: Write&gt; WriteHtml for W</code>这一行意思是“对于任何实现了<code>Write</code>的类型<code>W</code>，这里有一个为<code>W</code>编写的<code>WriteHtml</code>的实现”。</p>
<p><code>serde</code>库提供了一个很好的例子，它展示了可以在标准类型上实现用户自定义trait这种能力的重要作用。<code>serde</code>是一个序列化库。也就是说，你可以使用它把任何Rust数据结构写入到磁盘，并在稍后加载它们。这个库定义了一个trait <code>Serialize</code>，库支持所有实现了这个trait的数据类型。因此在<code>serde</code>的源码中，为<code>bool, i8, i16, i32</code>，数组和元组类型等，包括标准数据结构例如<code>Vec</code>和<code>HashMap</code>都实现了<code>Serialize</code> trait。</p>
<p>这样的结果是<code>serde</code>为所有这些类型添加了一个<code>.serialize()</code>方法。它可以像这样使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">serde</span>::<span class="n">Serialize</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">serde_json</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">save_configuration</span><span class="p">(</span><span class="n">config</span>: <span class="kp">&amp;</span><span class="nc">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> 
</span><span class="w">        </span>-&gt; <span class="nc">std</span>::<span class="n">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// 创建一个JSON序列化器来把数据写入到文件。
</span><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">writer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">create</span><span class="p">(</span><span class="n">config_filename</span><span class="p">())</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">serializer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">serde_json</span>::<span class="n">Serializer</span>::<span class="n">new</span><span class="p">(</span><span class="n">writer</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="c1">// serde的`.serialize()`方法负责剩余的内容。
</span><span class="c1"></span><span class="w">        </span><span class="n">config</span><span class="p">.</span><span class="n">serialize</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">serializer</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>我们之前说过当你实现一个tarit时，trait和类型至少有一个必须是在当前crate中新定义的。这被称为 <em>孤儿规则(orphan rule)</em> 。它帮助确保tarit的实现是唯一的。你的代码不能<code>impl Write for u8</code>，因为<code>Write</code>和<code>u8</code>都是在标准库中定义的。如果Rust允许crate这么做，那么不同的crate中可能会有不同的<code>u8</code>类型的<code>Write</code> trait实现。Rust将不知道为一个方法调用选择哪种实现。</p>
<p>（C++也有一个类似的唯一性约束：一次定义规则。在传统的C++风格中，除了最简单的情况之外，编译器并不会强制这一点，如果你打破了这个规则会遇到未定义行为。）</p>
<h3 id="trait中的self">trait中的<code>Self</code></h3>
<p>trait中可以将<code>Self</code>关键字用作类型。例如标准的<code>Clone</code> trait，看起来像这样（简化版）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="nb">Clone</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这里使用<code>Self</code>作为返回类型意味着<code>x.clone()</code>的返回值类型和<code>x</code>的类型相同，不管<code>x</code>是什么。如果<code>x</code>是一个<code>String</code>，那么<code>x.clone()</code>的类型就是<code>String</code>——不是<code>dyn Clone</code>或者别的可克隆的类型。</p>
<p>同样，如果我们定义了这个trait：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Spliceable</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">splice</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>还有两个实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="n">Spliceable</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">CherryTree</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">splice</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="n">Spliceable</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Mammoth</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">splice</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">    
</span></code></pre></td></tr></table>
</div>
</div><p>在第一个<code>impl</code>中，<code>Self</code>就是<code>CherryTree</code>的别名；而在第二个<code>impl</code>中，它是<code>Mammoth</code>的别名。这意味着我们可以把两棵樱桃树或者两只猛犸象拼接在一起，而不能创建出樱桃树-猛犸象杂交种。<code>self</code>的类型和<code>other</code>的类型必须相同。</p>
<p>一个使用了<code>Self</code>类型的trait和trait对象不兼容：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="c1">// 错误：trait `Spliceable`不能转变为一个对象
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">splice_anything</span><span class="p">(</span><span class="n">left</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Spliceable</span><span class="p">,</span><span class="w"> </span><span class="n">right</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Spliceable</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">combo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">left</span><span class="p">.</span><span class="n">splice</span><span class="p">(</span><span class="n">right</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="c1">// ...
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>当我们在深入研究trait的高级特性时会多次看到原因。Rust拒绝这段代码是因为它没有办法对<code>left.splice(right)</code>调用进行类型检查。关键点在于trait对象的类型直到运行时才能知道。Rust没有办法在编译期知道<code>left</code>和<code>right</code>是不是相同的类型。</p>
<p>trait对象实际上是为最简单的trait设计的，就是那种可以用Java中的接口或者C++中的抽象基类实现的那种trait。trait的还有更多有用的高级特性，但它们不能和现有的trait对象共存。因为使用trait对象时，你会丢失Rust对程序进行类型检查时必须的类型信息。</p>
<p>现在，假设我们想要一个从基因上讲不可能的拼接，我们可以设计一个trait对象友好的trait：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">MegaSpliceable</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">splice</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">MegaSpliceable</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">MegaSpliceable</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这个trait可以和trait对象兼容。调用<code>.splice()</code>方法时的类型检查不会有问题，因此参数<code>other</code>的类型不需要和<code>self</code>的类型相同，尽管它们的类型都是<code>MegaSpliceable</code>。</p>
<h3 id="子trait">子trait</h3>
<p>我们可以定义一个trait作为另一个trait的扩展：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="sd">/// 游戏世界中的某个生物，可能是玩家或者
</span><span class="sd"></span><span class="w">    </span><span class="sd">/// 小精灵、石像鬼、松鼠、食人魔等。
</span><span class="sd"></span><span class="w">    </span><span class="k">trait</span><span class="w"> </span><span class="n">Creature</span>: <span class="nc">Visible</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">position</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">facing</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Direction</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>短语<code>trait Creature: Visible</code>意味着所有的生物都是可视的。每一个实现了<code>Creature</code>的类型都必须实现<code>Visible</code> trait：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="n">Visible</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Broom</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="n">Creature</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Broom</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>我们可以以任何顺序实现这两个trait，但为一个没有实现<code>Visible</code>的类型实现<code>Creature</code>是错误的。这里，我们说<code>Creature</code>是<code>Visible</code>的一个 <em>子trait(subtrait)</em> ，而<code>Visible</code>是<code>Creature</code>的 <em>父trait(supertrait)</em> 。</p>
<p>子trait类似Java或者C#中的子接口，用户可以假定任何实现了子trait的值一定也实现了它的父trait。但在Rust中，一个子trait不会继承父trait中的相关item，如果你想调用方法的话仍然要确保每个trait都在作用域中。</p>
<p>事实上，Rust的子trait只是对<code>Self</code>的约束的缩写。<code>Creature</code>的定义和下面这个完全等价：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">trait</span><span class="w"> </span><span class="n">Creature</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="bp">Self</span>: <span class="nc">Visible</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="类型关联函数">类型关联函数</h3>
<p>在大多数面向对象语言中，接口不能包含静态方法或者构造函数，但trait可以包含类型关联函数，Rust中的关联函数类似于静态方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">trait</span><span class="w"> </span><span class="n">StringSet</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="sd">/// 返回一个空的集合。
</span><span class="sd"></span><span class="w">        </span><span class="k">fn</span> <span class="nf">new</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w">
</span><span class="w">        
</span><span class="w">        </span><span class="sd">/// 返回一个包含`strings`中所有字符串的集合。
</span><span class="sd"></span><span class="w">        </span><span class="k">fn</span> <span class="nf">from_slice</span><span class="p">(</span><span class="n">strings</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="o">&amp;</span><span class="kt">str</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="sd">/// 查找集合是否包含`string`。
</span><span class="sd"></span><span class="w">        </span><span class="k">fn</span> <span class="nf">contains</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">string</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="sd">/// 向集合中添加一个字符串。
</span><span class="sd"></span><span class="w">        </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">string</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>每一个实现了<code>StringSet</code> trait的类型都必须实现这四个关联函数。前两个函数<code>new()</code>和<code>from_slice()</code>，没有<code>self</code>参数。它们充当构造函数。在非泛型代码中，这些函数可以使用<code>::</code>语法调用，就像其他类型关联函数一样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="c1">// 创建两个impl StringSet的多态类型：
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">set1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SortedStringSet</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">set2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">HashedStringSet</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>在泛型代码中也是一样的。除了类型是一个类型变量，因此这里需要调用<code>S::new()</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="sd">/// 返回`document`中有但`wordlist`中没有的单词的集合。
</span><span class="sd"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">unknown_words</span><span class="o">&lt;</span><span class="n">S</span>: <span class="nc">StringSet</span><span class="o">&gt;</span><span class="p">(</span><span class="n">document</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="nb">String</span><span class="p">],</span><span class="w"> </span><span class="n">wordlist</span>: <span class="kp">&amp;</span><span class="nc">S</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">S</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">unknowns</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">S</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">word</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">document</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">wordlist</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">word</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="n">unknowns</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">word</span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="n">unknowns</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>类似Java和C#的接口，trait对象不支持类型关联函数。如果你想使用<code>&amp;dyn StringSet</code> trait对象，那你必须修改trait，给那些不接受<code>self</code>参数的关联函数加上<code>where Self: Sized</code>约束：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">trait</span><span class="w"> </span><span class="n">StringSet</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">new</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w">
</span><span class="w">            </span><span class="k">where</span><span class="w"> </span><span class="bp">Self</span>: <span class="nb">Sized</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">from_slice</span><span class="p">(</span><span class="n">strings</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="o">&amp;</span><span class="kt">str</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w">
</span><span class="w">            </span><span class="k">where</span><span class="w"> </span><span class="bp">Self</span>: <span class="nb">Sized</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">contains</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">string</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">string</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这个约束告诉Rust trait对象不支持这个关联函数。加上之后，你可以创建<code>StringSet</code>的trait对象了，但仍然不能使用<code>new</code>和<code>from_slice</code>，不过你可以使用它们调用<code>.contains()</code>和<code>.add()</code>。同样的技巧也适用于其他和trait对象不兼容的方法。（从技术上解释为什么会这样是相当乏味的，因此我们不会解释。不过<code>Sized</code> trait将会在”第13章”介绍。）</p>
<h2 id="完全限定方法调用">完全限定方法调用</h2>
<p>目前为止我们展示过的所有调用trait方法的方式都需要Rust自动为我们填充一些缺失的东西。例如，假设你写了如下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="s">&#34;hello&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">();</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>显然这里的<code>to_string</code>指的是<code>ToString</code> trait的<code>to_string</code>方法，而我们调用的是<code>str</code>类型的实现。因此这场游戏中出现了四个玩家：trait、trait方法、trait方法的实现、调用trait方法实现的值。我们不需要每次调用方法时都完全写出这四个部分是一件好事，但有些情况下你也可能会需要一种精确的方式来表达你的意思。这种情况下就要用到完全限定方法调用。</p>
<p>首先，要知道方法只是一种特殊的函数。这两种调用是等价的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="s">&#34;hello&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">()</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kt">str</span>::<span class="n">to_string</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>第二种形式看起来很像一个关联函数的调用，即使<code>to_string</code>方法以<code>self</code>为参数也没有问题，只会简单的传递<code>self</code>作为函数的第一个参数。</p>
<p>因为<code>to_string</code>是标准的<code>ToString</code> trait的方法，所以还有两种调用方式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="nb">ToString</span>::<span class="n">to_string</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="o">&lt;</span><span class="kt">str</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">ToString</span><span class="o">&gt;</span>::<span class="n">to_string</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这四种方法调用功能完全相同。通常你最可能写<code>value.method()</code>。其他的形式是 <em>限定(qualified)</em> 方法调用。它们指明了方法关联到的类型或者trait。最后一种带尖括号的形式同时指明了类型和trait，这种形式被称为 <em>完全限定(fully qualified)</em> 方法调用。</p>
<p>当你写<code>&quot;hello&quot;.to_string()</code>时候，使用<code>.</code>运算符，你不需要精确地说明你要调用哪个<code>to_string</code>方法。Rust有一个依据类型、强制解引用等机制的查找算法来确定是哪个方法。使用完全限定调用，你可以精确地说明你想要调用哪个方法，这可以在一些罕见的情况下有所帮助：</p>
<ul>
<li>
<p>当两个方法的名称相同时。经典的例子是<code>Outlaw</code>有两个来自不同trait的<code>.draw()</code>方法，一个用于在屏幕上绘制它，另一个用于和law交互：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="n">outlaw</span><span class="p">.</span><span class="n">draw</span><span class="p">();</span><span class="w">              </span><span class="c1">// error: draw on screen or draw pistol?
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="n">Visible</span>::<span class="n">draw</span><span class="p">(</span><span class="o">&amp;</span><span class="n">outlaw</span><span class="p">);</span><span class="w">     </span><span class="c1">// ok: draw on screen
</span><span class="c1"></span><span class="n">HasPistol</span>::<span class="n">draw</span><span class="p">(</span><span class="o">&amp;</span><span class="n">outlaw</span><span class="p">);</span><span class="w">   </span><span class="c1">// ok: corral
</span></code></pre></td></tr></table>
</div>
</div><p>通常你可能更愿意重命名其中一个方法，但有时你不能这么做。</p>
</li>
<li>
<p>当<code>self</code>参数的类型不能被推断出来时：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="kd">let</span><span class="w"> </span><span class="n">zero</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">   </span><span class="c1">// 类型为定义：可能是`i8`，`u8`，...
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="n">zero</span><span class="p">.</span><span class="n">abs</span><span class="p">();</span><span class="w">     </span><span class="c1">// 错误：不能在有歧义的数字类型
</span><span class="c1"></span><span class="w">                </span><span class="c1">// 上调用方法`abs`
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="kt">i64</span>::<span class="n">abs</span><span class="p">(</span><span class="n">zero</span><span class="p">);</span><span class="w"> </span><span class="c1">// ok
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>当使用函数本身作为函数类型的值的时候：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="kd">let</span><span class="w"> </span><span class="n">words</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w">
</span><span class="w">    </span><span class="n">line</span><span class="p">.</span><span class="n">split_whitespace</span><span class="p">()</span><span class="w">         </span><span class="c1">// 迭代器会产生&amp;str值
</span><span class="c1"></span><span class="w">        </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="nb">ToString</span>::<span class="n">to_string</span><span class="p">)</span><span class="w">   </span><span class="c1">// ok
</span><span class="c1"></span><span class="w">        </span><span class="p">.</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>当在宏中调用trait方法时。我们将在”第21章”中解释。</p>
</li>
</ul>
<p>完全限定语法也可以用于关联函数。在之前的小节中，我们用了<code>S::new()</code>在泛型函数中创建一个新的集合。我们还可以写成<code>StringSet::new()</code>或者<code>&lt;S as StringSet&gt;::new()</code>。</p>
<h2 id="定义类型关系的trait">定义类型关系的trait</h2>
<p>到目前为止，我们看到过的每个trait都是独立的：一个trait就是一些可以实现的方法的集合。trait也可以用于需要多个类型协同工作的场景。它们可以描述类型之间的关系：</p>
<ul>
<li><code>std::iter::Iterator</code> trait将迭代器类型和产生的值的类型联系在了一起。</li>
<li><code>std::ops::Mul</code> trait将可以做乘法的类型联系了起来。在表达式<code>a * b</code>中，值<code>a</code>和<code>b</code>可以是相同类型，也可以是不同的类型。</li>
<li><code>rand</code> crate包含一个代表随机数生成器的trait(<code>rand::Rng</code>)，和一个代表可以被随机生成的类型的trait(<code>rand::Distribution</code>)。这些trait定义了这些类型怎么协同工作。</li>
</ul>
<p>日常编程中你可能并不需要创建这样的trait，但你会在标准库和第三方crate中看到它们。在这一节中，我们将展示这些例子是怎么实现的、根据需要介绍相关的Rust的语言特性。这里最核心的技能就是读懂trait和方法签名、并搞清楚它们到底想表达什么意思。</p>
<h3 id="关联类型或迭代器是如何工作的">关联类型(或迭代器是如何工作的)</h3>
<p>我们将以迭代器开始。到目前为止每一门面向对象的语言都有内建的对迭代器的支持，迭代器是表示遍历一系列值的对象。</p>
<p>Rust有一个标准的<code>Iterator</code> trait，它的定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="nb">Iterator</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">type</span> <span class="nc">Item</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这个trait的第一个特性<code>type Item</code>，是一个 <em>关联类型(associated tepe)</em> 。每一个实现了<code>Iterator</code>的类型都必须指明它产生什么类型的值。</p>
<p>第二个特性<code>next()</code>方法，在返回值类型中使用了关联类型。<code>next()</code>返回一个<code>Option&lt;Self::Item&gt;</code>：要么是<code>Some(item)</code>，即序列中的下一个值；要么是<code>None</code>，表示已经没有值了。这个类型被写作<code>Self::Item</code>，而不是普通的<code>Item</code>，这是因为<code>Item</code>是每一个迭代器类型的一个特性，而不是单独的类型。和往常一样，<code>self</code>和<code>Self</code>类型需要显式地出现在使用它们的字段、方法等的代码中。</p>
<p>这里有个示例为一个类型实现了<code>Iterator</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="c1">// (这段代码出自std::env标准库模块)
</span><span class="c1"></span><span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="nb">Iterator</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Args</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">type</span> <span class="nc">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>我们在”第2章”中使用过标准库函数<code>std::env::args()</code>来获取命令行参数，<code>std::env::Args</code>就是它返回的迭代器的类型。它产生<code>String</code>值，因此<code>impl</code>块中声明了<code>type Item = String;</code>。</p>
<p>泛型代码也可以使用关联类型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="sd">/// 循环一个迭代器，把值存储到新的vector中。
</span><span class="sd"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">collect_into_vector</span><span class="o">&lt;</span><span class="n">I</span>: <span class="nb">Iterator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">iter</span>: <span class="nc">I</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">I</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">results</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">results</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">value</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="n">results</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>在这个函数体中，Rust为我们推断出了<code>value</code>的类型，这很棒。但我们必须指明<code>collect_into_vector</code>的返回类型，而<code>Item</code>关联类型是唯一的方法。（<code>Vec&lt;I&gt;</code>显然是错的：它说明函数会返回一个迭代器的vector！）</p>
<p>上面的代码你可能永远不会自己写出来，因为在阅读了”第15章”后，你就会知道迭代器已经有了一个标准方法<code>iter.collect()</code>来做这件事了。因此在继续之前让我们再看一个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="sd">/// 打印出一个迭代器产生的所有值
</span><span class="sd"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">dump</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">(</span><span class="n">iter</span>: <span class="nc">I</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="k">where</span><span class="w"> </span><span class="n">I</span>: <span class="nb">Iterator</span>
    <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">iter</span><span class="p">.</span><span class="n">enumerate</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{}: {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w"> </span><span class="c1">// error
</span><span class="c1"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>还差一点就完成了。这里只有一个问题：<code>value</code>可能不是一个可打印的类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-mysql" data-lang="mysql"><span class="w">    </span><span class="n">error</span><span class="p">:</span><span class="w"> </span><span class="o">`&lt;</span><span class="n">I</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Iterator</span><span class="o">&gt;</span><span class="p">::</span><span class="n">Item</span><span class="o">`</span><span class="w"> </span><span class="n">doesn</span><span class="s1">&#39;t implement `Debug`
</span><span class="s1">      |
</span><span class="s1">    8 |         println!(&#34;{}: {:?}&#34;, index, value);   // error
</span><span class="s1">      |                                     ^^^^^
</span><span class="s1">      |                          `&lt;I as Iterator&gt;::Item` cannot be formatted
</span><span class="s1">      |                          using `{:?}` because it doesn&#39;</span><span class="n">t</span><span class="w"> </span><span class="n">implement</span><span class="w"> </span><span class="o">`</span><span class="n">Debug</span><span class="o">`</span><span class="w">
</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">help</span><span class="p">:</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">trait</span><span class="w"> </span><span class="o">`</span><span class="n">Debug</span><span class="o">`</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="n">implemented</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">`&lt;</span><span class="n">I</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Iterator</span><span class="o">&gt;</span><span class="p">::</span><span class="n">Item</span><span class="o">`</span><span class="w">
</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">note</span><span class="p">:</span><span class="w"> </span><span class="n">required</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="o">`</span><span class="n">std</span><span class="p">::</span><span class="n">fmt</span><span class="p">::</span><span class="n">Debug</span><span class="p">::</span><span class="n">fmt</span><span class="o">`</span><span class="w">
</span><span class="w">    </span><span class="n">help</span><span class="p">:</span><span class="w"> </span><span class="n">consider</span><span class="w"> </span><span class="n">further</span><span class="w"> </span><span class="n">restricting</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">associated</span><span class="w"> </span><span class="n">type</span><span class="w">
</span><span class="w">      </span><span class="o">|</span><span class="w">
</span><span class="w">    </span><span class="mi">5</span><span class="w"> </span><span class="o">|</span><span class="w">     </span><span class="k">where</span><span class="w"> </span><span class="n">I</span><span class="p">:</span><span class="w"> </span><span class="n">Iterator</span><span class="p">,</span><span class="w"> </span><span class="o">&lt;</span><span class="n">I</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Iterator</span><span class="o">&gt;</span><span class="p">::</span><span class="n">Item</span><span class="p">:</span><span class="w"> </span><span class="n">Debug</span><span class="w">
</span><span class="w">      </span><span class="o">|</span><span class="w">                      </span><span class="o">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>错误信息有一点混淆，因为Rust使用了语法<code>&lt;I as Iterator&gt;::Item</code>，这种方式比<code>I::Item</code>更加显式和详细。这是有效的Rust语法，不过你很少会需要用这种方式指明类型。</p>
<p>错误信息的关键是，要想让这段泛型代码能编译，我们必须确保<code>I::Item</code>实现了<code>Debug</code> trait，这个trait用于使用<code>{:?}</code>格式化值。正如错误信息建议的那样，我们可以通过添加一个<code>I::Item</code>的约束来解决这个问题：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span>::<span class="n">Debug</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">dump</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">(</span><span class="n">iter</span>: <span class="nc">I</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="k">where</span><span class="w"> </span><span class="n">I</span>: <span class="nb">Iterator</span><span class="p">,</span><span class="w"> </span><span class="n">I</span>::<span class="n">Item</span>: <span class="nc">Debug</span><span class="w">
</span><span class="w">    </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>或者，我们可以写“<code>I</code>必须是一个产生<code>String</code>值的迭代器”：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">dump</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">(</span><span class="n">iter</span>: <span class="nc">I</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="k">where</span><span class="w"> </span><span class="n">I</span>: <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">=</span><span class="nb">String</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>Iterator&lt;Item=String&gt;</code>本身是一个trait。如果你把<code>Iterator</code>看作所有可能的迭代器类型的集合，那么<code>Iterator&lt;Item=String&gt;</code>就是<code>Iterator</code>的一个子集：产生<code>String</code>的迭代器类型的集合。这个语法可以用在任何需要一个trait名字的位置，包括trait对象类型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">dump</span><span class="p">(</span><span class="n">iter</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="k">dyn</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">=</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">iter</span><span class="p">.</span><span class="n">enumerate</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{}: {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>带有关联类型的trait，例如<code>iterator</code>，和trait对象是兼容的，不过必须像这里展示的一样指明所有的关联类型才可以。否则，<code>s</code>的类型可能是任何东西，因此Rust无法对这段代码进行类型检查。</p>
<p>我们已经展示了很多涉及到迭代器的例子，因为目前迭代器是关联类型最突出的用途。但关联类型在任何trait需要涉及方法以外的东西的场景中都很有用：</p>
<ul>
<li>
<p>在一个线程池库中，一个<code>Task</code> trait表示一个工作单元，它可能有一个关联的<code>Output</code>类型。</p>
</li>
<li>
<p>一个<code>Pattern</code> trait表示一种搜索字符串的方式，它可能有一个关联的<code>Match</code>类型，表示字符串中和模式匹配的所有信息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="k">trait</span><span class="w"> </span><span class="n">Pattern</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Match</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">search</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">string</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Match</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="sd">/// 你可以在字符串中搜索一个特定的字符。
</span><span class="sd"></span><span class="k">impl</span><span class="w"> </span><span class="n">Pattern</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="sd">/// 一个`Match`只是发现字符的位置
</span><span class="sd"></span><span class="w">    </span><span class="k">type</span> <span class="nc">Match</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">usize</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">search</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">string</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>如果你熟悉正则表达式，那么很容易就能看出<code>impl Pattern for RegExp</code>将会有一个更加精密的<code>Match</code>类型，可能是一个包含匹配的开始和结尾、匹配的括号组的位置等内容的结构体。</p>
</li>
<li>
<p>一个用于关系型数据库的库可能有一个<code>DatabaseConnection</code> trait，它有一个关联类型表示事务、游标、预处理语句等等。</p>
</li>
</ul>
<p>关联类型完美适用于每一个实现都有 <em>一个</em> 特定的相关类型的情况：每一个<code>Task</code>的类型产生一个特定类型的<code>Output</code>；每一个<code>Pattern</code>的类型查找一个特定的<code>Match</code>类型。然而，正如我们即将看到的一样，一些类型间的关系并不是这种模式。</p>
<h3 id="泛型trait或运算符重载是如何工作的">泛型trait（或运算符重载是如何工作的）</h3>
<p>Rust中的乘法使用了这个trait：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="sd">/// std::ops::Mul，用于支持乘法(`*`)的类型
</span><span class="sd"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Mul</span><span class="o">&lt;</span><span class="n">RHS</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="sd">/// `*`运算符产生的结果的类型
</span><span class="sd"></span><span class="w">        </span><span class="k">type</span> <span class="nc">Output</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="sd">/// `*`运算符用到的的方法
</span><span class="sd"></span><span class="w">        </span><span class="k">fn</span> <span class="nf">mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">RHS</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>Mul</code>是一个泛型类型。类型参数<code>RHS</code>是 <em>右手边(righthand side)</em> 的缩写。</p>
<p>这里的类型参数和在结构体或函数中的含义一样：<code>Mul</code>是一个泛型trait，它实例化出的<code>Mul&lt;f64&gt;</code>、<code>Mul&lt;String&gt;</code>、<code>Mul&lt;Size&gt;</code>等都是不同的trait，正如<code>min::&lt;i32&gt;</code>和<code>min::&lt;String&gt;</code>是不同的函数、<code>Vec&lt;i32&gt;</code>和<code>Vec&lt;String&gt;</code>是不同的类型一样。</p>
<p>单个类型例如<code>WindowSize</code>，可以同时实现<code>Mul&lt;f64&gt;</code>和<code>Mul&lt;i32&gt;</code>，甚至更多。你可以将一个<code>WindowSize</code>和很多其它类型相乘。每一个实现都有它自己的关联<code>Output</code>类型。</p>
<p>泛型trait可以不受孤儿规则的约束：你可以为一个外部类型实现一个外部trait，只要trait的类型参数中有一个是在当前crate中定义的类型。因此，假设你自己已经定义了<code>WindowSize</code>，你可以为<code>f64</code>实现<code>Mul&lt;WindowSize&gt;</code>，即使你既没有定义<code>Mul</code>又没有定义<code>f64</code>。这些实现甚至也可以是泛型的，例如<code>impl&lt;T&gt; Mul&lt;WindowSize&gt; for Vec&lt;T&gt;</code>。之所以可以这样是因为在别的crate中没有任何方法可以为任何类型实现<code>Mul&lt;WindowSize&gt;</code>，因此和你的实现之间不可能发生冲突。（我们在“trait和其他人的类型”一节中介绍过孤儿规则。）这正是像<code>nalgebra</code>这样的crate为vector定义算术运算的方法。</p>
<p>之前展示的trait忽略了一个小细节。真正的<code>Mul</code> trait看起来像这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Mul</span><span class="o">&lt;</span><span class="n">RHS</span><span class="o">=</span><span class="bp">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>语法<code>RHS=Self</code>意思是<code>RHS</code>的默认值为<code>Self</code>。如果我们写<code>impl Mul for Complex</code>，而不指明<code>Mul</code>的类型参数，那么意味着<code>impl Mul&lt;Complex&gt; for Complex</code>。如果我们在一个约束中写<code>where T: Mul</code>，那么意味着<code>T: Mul&lt;T&gt;</code>。</p>
<p>在Rust中，表达式<code>lhs * rhs</code>是<code>Mul::mul(lhs, rhs)</code>的缩写。因此在Rust中重载<code>*</code>运算符和实现<code>Mul</code> trait一样简单。我们将在下一章中展示示例。</p>
<h3 id="impl-trait"><code>impl Trait</code></h3>
<p>你可能想象过，组合使用多种泛型类型可能会变得一团糟。例如，仅仅只使用标准库中的组合器组合几个迭代器会让你的返回类型变得眼花缭乱：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">iter</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">vec</span>::<span class="n">IntoIter</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">cyclical_zip</span><span class="p">(</span><span class="n">v</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">u</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt;
        <span class="nc">iter</span>::<span class="n">Cycle</span><span class="o">&lt;</span><span class="n">iter</span>::<span class="n">Chain</span><span class="o">&lt;</span><span class="n">IntoIter</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">IntoIter</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">v</span><span class="p">.</span><span class="n">into_iter</span><span class="p">().</span><span class="n">chain</span><span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">into_iter</span><span class="p">()).</span><span class="n">cycle</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>我们可以简单的将返回类型替换为一个triat对象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">cyclical_zip</span><span class="p">(</span><span class="n">v</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">u</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">=</span><span class="kt">u8</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">into_iter</span><span class="p">().</span><span class="n">chain</span><span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">into_iter</span><span class="p">()).</span><span class="n">cycle</span><span class="p">())</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>然而，在大多数情况下，仅仅为了避免丑陋的类型签名，就要在每一次调用这个函数时付出动态分发的开销和一次不可避免的堆分配并不是一个好的折衷。</p>
<p>Rust有一个专为此情形设计的特性叫做<code>impl Trait</code>。<code>impl Trait</code>允许我们“擦除”返回值的类型，只指明它实现的trait或traits，并且没有动态分发或者堆分配：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">cyclical_zip</span><span class="p">(</span><span class="n">v</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">u</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">=</span><span class="kt">u8</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">v</span><span class="p">.</span><span class="n">into_iter</span><span class="p">().</span><span class="n">chain</span><span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">into_iter</span><span class="p">()).</span><span class="n">cycle</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>现在，与指明嵌套的迭代器组合器结构体的类型相比，<code>cyclical_zip</code>的签名只简单的说明了它返回一种产生<code>u8</code>的迭代器。返回类型表达了函数的意图，而不是实现细节。</p>
<p>这确实清理了代码并增强了可读性，但<code>impl Trait</code>并不只是一个方便的缩写。使用<code>impl Trait</code>意味着你可以在将来修改实际返回的类型，只要新的类型仍然实现了<code>Iterator&lt;Item=u8&gt;</code>，任何调用了这个函数的代码将仍然能不出错地继续编译。这为库的作者提供了很大的灵活性，因为只有相关的的功能被编码进类型签名。</p>
<p>例如，如果一个库的第一版按照上面的方法使用迭代器组合器，然后又发现了一个更好的算法，那么库的作者可以使用不同的迭代器组合器或者甚至返回一个自定义的实现了<code>Iterator</code>的类型，而库的用户可以在完全不改变代码的情况下享受性能的提升。</p>
<p>使用<code>impl Trait</code>类似于面向对象语言中广泛使用的工厂模式的静态分发版本，这很有诱惑力。例如，你可以定义一个这样的trait：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">trait</span><span class="w"> </span><span class="n">Shape</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">new</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">area</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">f64</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>在为几个类型实现了它之后，你可能想根据一个运行时的值来决定使用不同的<code>Shape</code>，例如一个用户输入的字符串。使用<code>impl Shape</code>作为返回类型并不可行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">make_shape</span><span class="p">(</span><span class="n">shape</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="n">Shape</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">shape</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;circle&#34;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">Circle</span>::<span class="n">new</span><span class="p">(),</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;triangle&#34;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">Triangle</span>::<span class="n">new</span><span class="p">(),</span><span class="w">  </span><span class="c1">// 错误：不兼容的类型
</span><span class="c1"></span><span class="w">            </span><span class="s">&#34;shape&#34;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">Rectangle</span>::<span class="n">new</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>从调用者的角度来看，像这样的函数并没有什么意义。<code>impl Trait</code>是一种静态分发的版本，因此编译器需要在编译期知道函数内返回的实际类型，这样才能在栈上分配正确数量的空间并调用正确的字段和方法。这里，它可能是<code>Circle</code>、<code>Triganle</code>或者<code>Rectangle</code>，它们的空间大小都不同，而且都有不同的<code>area()</code>实现。</p>
<p>很重要的一点是要注意Rust不允许trait方法使用<code>impl Trait</code>作为返回类型。要想支持这一点需要对语言的类型系统进行一些改进。在这项工作完成之前，只有自由函数和关联到特定类型的函数可以使用<code>impl Trait</code>作为返回值。</p>
<p><code>impl Trait</code>也可以用来在函数中接受泛型参数。例如，考虑下面的简单泛型代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">print</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Display</span><span class="o">&gt;</span><span class="p">(</span><span class="n">val</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>它和下面的使用<code>impl Trait</code>的版本相同：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">print</span><span class="p">(</span><span class="n">val</span>: <span class="nc">impl</span><span class="w"> </span><span class="n">Display</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这里有一个很重要的例外。使用泛型允许函数的调用者指定泛型参数的类型，例如<code>print::&lt;i32&gt;(42)</code>，而使用<code>impl Trait</code>则不行。</p>
<p>每一个<code>impl Trait</code>参数都会被赋予一个自己的匿名类型参数，因此<code>impl Trait</code>局限于最简单的泛型函数中，不能表示参数的类型之间的关系。</p>
<h3 id="关联常量">关联常量</h3>
<p>像结构体和枚举一样，trait也可以有关联常量。你可以用和结构体或枚举一样的语法给trait声明关联常量：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">trait</span><span class="w"> </span><span class="n">Greet</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">GREETING</span>: <span class="kp">&amp;</span><span class="o">&#39;</span><span class="nb">static</span> <span class="kt">str</span> <span class="o">=</span><span class="w"> </span><span class="s">&#34;Hello&#34;</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">greet</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>trait中的关联常量也有特殊的作用。像关联类型和函数一样，你可以声明它们但不赋给它们值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">trait</span><span class="w"> </span><span class="n">Float</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">ZERO</span>: <span class="nc">Self</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">ONE</span>: <span class="nc">Self</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>然后，实现这些trait的类型可以定义这些值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="n">Float</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">f32</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">ZERO</span>: <span class="kt">f32</span> <span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">ONE</span>: <span class="kt">f32</span> <span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="n">Float</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">f64</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">ZERO</span>: <span class="kt">f64</span> <span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">ONE</span>: <span class="kt">f64</span> <span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>你可以编写使用这些值的泛型代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">add_one</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Float</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Add</span><span class="o">&lt;</span><span class="n">Output</span><span class="o">=</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">value</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">T</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">value</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">T</span>::<span class="n">ONE</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>注意关联常量不能和trait对象一起使用，因为编译器依赖实现的类型信息，才能在编译期找出正确的值。</p>
<p>即使是一个没有任何行为的简单trait，例如<code>Float</code>，也可以给出足够的类型信息，再搭配上少数运算符，就可以实现一些非常普遍的数学函数例如斐波那契数列：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">fib</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Float</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Add</span><span class="o">&lt;</span><span class="n">Output</span><span class="o">=</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">n</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">T</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="mi">0</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">T</span>::<span class="n">ZERO</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="mi">1</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">T</span>::<span class="n">ONE</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">n</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">fib</span>::<span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fib</span>::<span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>在上面两节中，我们已经展示了用trait描述类型间关系的不同方法。所有这些都可以避免虚方法开销和向下转换，因为它们允许Rust在编译期就知道精确的类型。</p>
<h2 id="逆向工程约束">逆向工程约束</h2>
<p>当没有单个trait可以满足你的所有需求时，编写泛型代码可能会变得非常困难。假设我们写了这个做一些计算的函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">dot</span><span class="p">(</span><span class="n">v1</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">i64</span><span class="p">],</span><span class="w"> </span><span class="n">v2</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">i64</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="kt">i64</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">total</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="n">v1</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">total</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">total</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="n">total</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>现在我们想用相同的代码来处理浮点数值。我们可能会尝试这样写：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">dot</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v1</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">v2</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">N</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">total</span>: <span class="nc">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="n">v1</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">total</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">total</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="n">total</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这样是行不通的：Rust会抱怨<code>*</code>和<code>+</code>的使用以及<code>0</code>的类型。我们可以用<code>Add</code>和<code>Mul</code> trait来要求<code>N</code>是一个支持<code>+</code>和<code>*</code>的类型。对于<code>0</code>的使用也要修改，因为在Rust中<code>0</code>总是整数，而相应的浮点值是<code>0.0</code>。幸运的是，那些有默认值的类型有一个标准的<code>Default</code> trait。对于数值类型，默认值总是0：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="p">{</span><span class="n">Add</span><span class="p">,</span><span class="w"> </span><span class="n">Mul</span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">dot</span><span class="o">&lt;</span><span class="n">N</span>: <span class="nc">Add</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Mul</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Default</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v1</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">v2</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">N</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">total</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">N</span>::<span class="n">default</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="n">v1</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">total</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">total</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="n">total</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这已经接近正确答案了，但还不够：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-mysql" data-lang="mysql"><span class="w">    </span><span class="n">error</span><span class="p">:</span><span class="w"> </span><span class="n">mismatched</span><span class="w"> </span><span class="n">types</span><span class="w">
</span><span class="w">      </span><span class="o">|</span><span class="w">
</span><span class="w">    </span><span class="mi">5</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">fn</span><span class="w"> </span><span class="n">dot</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="k">Add</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Mul</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">Default</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v1</span><span class="p">:</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">v2</span><span class="p">:</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="err">{</span><span class="w">
</span><span class="w">      </span><span class="o">|</span><span class="w">        </span><span class="o">-</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">parameter</span><span class="w">
</span><span class="w">    </span><span class="p">...</span><span class="w">
</span><span class="w">    </span><span class="mi">8</span><span class="w"> </span><span class="o">|</span><span class="w">         </span><span class="n">total</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">total</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w">
</span><span class="w">      </span><span class="o">|</span><span class="w">                         </span><span class="o">^^^^^^^^^^^^^</span><span class="w"> </span><span class="n">expected</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">parameter</span><span class="w"> </span><span class="o">`</span><span class="n">N</span><span class="o">`</span><span class="p">,</span><span class="w">
</span><span class="w">      </span><span class="o">|</span><span class="w">                                       </span><span class="n">found</span><span class="w"> </span><span class="n">associated</span><span class="w"> </span><span class="n">type</span><span class="w">
</span><span class="w">      </span><span class="o">|</span><span class="w">
</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">note</span><span class="p">:</span><span class="w"> </span><span class="n">expected</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">parameter</span><span class="w"> </span><span class="o">`</span><span class="n">N</span><span class="o">`</span><span class="w">
</span><span class="w">                </span><span class="n">found</span><span class="w"> </span><span class="n">associated</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">`&lt;</span><span class="n">N</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Mul</span><span class="o">&gt;</span><span class="p">::</span><span class="n">Output</span><span class="o">`</span><span class="w">
</span><span class="w">    </span><span class="n">help</span><span class="p">:</span><span class="w"> </span><span class="n">consider</span><span class="w"> </span><span class="n">further</span><span class="w"> </span><span class="n">restricting</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">bound</span><span class="w">
</span><span class="w">      </span><span class="o">|</span><span class="w">
</span><span class="w">    </span><span class="mi">5</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">fn</span><span class="w"> </span><span class="n">dot</span><span class="o">&lt;</span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="k">Add</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Mul</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">Default</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Mul</span><span class="o">&lt;</span><span class="n">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">v1</span><span class="p">:</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">v2</span><span class="p">:</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="err">{</span><span class="w">
</span><span class="w">      </span><span class="o">|</span><span class="w">                               </span><span class="o">^^^^^^^^^^^^^^^^^</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>我们的新代码假设两个<code>N</code>类型的值相乘产生另一个<code>N</code>类型的值。这并不是绝对的，你可以重载乘法运算符来返回任何你希望的类型。我们需要一种方式来告诉Rust这个泛型函数只能用于有普通乘法的类型，这也就是<code>N * N</code>要返回<code>N</code>类型的值。错误消息中的建议 <em>几乎总是</em> 对的：我们可以把<code>Mul</code>换成<code>Mul&lt;Output=N&gt;</code>，然后<code>Add</code>也进行相同的替换：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">dot</span><span class="o">&lt;</span><span class="n">N</span>: <span class="nc">Add</span><span class="o">&lt;</span><span class="n">Output</span><span class="o">=</span><span class="n">N</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Mul</span><span class="o">&lt;</span><span class="n">Output</span><span class="o">=</span><span class="n">N</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Default</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v1</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">v2</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">N</span><span class="w">
</span><span class="w">    </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这个时候，约束已经开始逐渐累积，让代码变得难以阅读。让我们把约束移动到<code>where</code>子句中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">dot</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v1</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">v2</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">N</span><span class="w">
</span><span class="w">        </span><span class="k">where</span><span class="w"> </span><span class="n">N</span>: <span class="nc">Add</span><span class="o">&lt;</span><span class="n">Output</span><span class="o">=</span><span class="n">N</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Mul</span><span class="o">&lt;</span><span class="n">Output</span><span class="o">=</span><span class="n">N</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Default</span><span class="w">
</span><span class="w">    </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>很好。但Rust仍然会抱怨下面这行代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-mysql" data-lang="mysql"><span class="w">    </span><span class="n">error</span><span class="p">:</span><span class="w"> </span><span class="n">cannot</span><span class="w"> </span><span class="n">move</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">`</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="o">`</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">non</span><span class="o">-</span><span class="n">copy</span><span class="w"> </span><span class="n">slice</span><span class="w">
</span><span class="w">      </span><span class="o">|</span><span class="w">
</span><span class="w">    </span><span class="mi">8</span><span class="w"> </span><span class="o">|</span><span class="w">         </span><span class="n">total</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">total</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w">
</span><span class="w">      </span><span class="o">|</span><span class="w">                         </span><span class="o">^^^^^</span><span class="w">
</span><span class="w">      </span><span class="o">|</span><span class="w">                         </span><span class="o">|</span><span class="w">
</span><span class="w">      </span><span class="o">|</span><span class="w">                         </span><span class="n">cannot</span><span class="w"> </span><span class="n">move</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">here</span><span class="w">
</span><span class="w">      </span><span class="o">|</span><span class="w">                         </span><span class="n">move</span><span class="w"> </span><span class="n">occurs</span><span class="w"> </span><span class="n">because</span><span class="w"> </span><span class="o">`</span><span class="n">v1</span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="o">`</span><span class="w"> </span><span class="n">has</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">`</span><span class="n">N</span><span class="o">`</span><span class="p">,</span><span class="w">
</span><span class="w">      </span><span class="o">|</span><span class="w">                         </span><span class="n">which</span><span class="w"> </span><span class="n">does</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="n">implement</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="o">`</span><span class="n">Copy</span><span class="o">`</span><span class="w"> </span><span class="n">trait</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>因为我们没有要求<code>N</code>是一个可拷贝的类型，Rust把<code>v[i]</code>解释为尝试把一个值移出切片，这是禁止的。但我们根本不希望修改这个切片；我们只希望拷贝这个值来进行操作。幸运的是，所有Rust的内建数值类型都实现了<code>Copy</code>，因此我们可以简单地把它添加到<code>N</code>的约束中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">where</span><span class="w"> </span><span class="n">N</span>: <span class="nc">Add</span><span class="o">&lt;</span><span class="n">Output</span><span class="o">=</span><span class="n">N</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Mul</span><span class="o">&lt;</span><span class="n">Output</span><span class="o">=</span><span class="n">N</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Default</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Copy</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这次，代码可以编译运行了。最终的代码看起来像这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="p">{</span><span class="n">Add</span><span class="p">,</span><span class="w"> </span><span class="n">Mul</span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">dot</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v1</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">v2</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">N</span><span class="w">
</span><span class="w">        </span><span class="k">where</span><span class="w"> </span><span class="n">N</span>: <span class="nc">Add</span><span class="o">&lt;</span><span class="n">Output</span><span class="o">=</span><span class="n">N</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Mul</span><span class="o">&lt;</span><span class="n">Output</span><span class="o">=</span><span class="n">N</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Default</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Copy</span><span class="w">
</span><span class="w">    </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">total</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">N</span>::<span class="n">default</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="n">v1</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">total</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">total</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="n">total</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="cp">#[test]</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">test_dot</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">]),</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="mf">53.0</span><span class="p">,</span><span class="w"> </span><span class="mf">7.0</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">5.0</span><span class="p">]),</span><span class="w"> </span><span class="mf">88.0</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>在Rust中偶尔会发生的一种情况是：有一段时间会与编译器激烈斗争，但最后写出来的代码看起来相当不错，好像编写起来轻而易举，并且运行得很漂亮。</p>
<p>我们在这里做的就是对<code>N</code>的约束进行逆向工程，让编译器来指导并检查我们的工作。这段代码写起来很麻烦是因为标准库中没有单独的<code>Number</code> trait包含我们需要的所有运算符和方法。有一个流行的开源crate叫做<code>num</code>定义了这样一个trait！我们已经知道，我们可以在 <em>Cargo.toml</em> 中添加<code>num</code>并编写：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">num</span>::<span class="n">Num</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">dot</span><span class="o">&lt;</span><span class="n">N</span>: <span class="nc">Num</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Copy</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v1</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">v2</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">N</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">total</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">N</span>::<span class="n">zero</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="n">v1</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">total</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">total</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="n">total</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>正如在面向对象语言中正确的接口让一切变得美好一样，在泛型编程中，正确的trait让一切变得美好。</p>
<p>为什么我们会遇到这种问题？为什么Rust的设计者不让泛型变得类似于C++的模板一样，把约束隐藏在代码中，à la “duck typing”？</p>
<p>Rust的方案的一个优势是泛型代码的向前兼容性。你可以修改一个公有的泛型函数或方法的实现，只要你不修改签名，就不会影响到使用它的用户。</p>
<p>约束的另一个优势是当你遇到编译器的错误时，至少编译器可以告诉你错误在哪。C++编译器涉及到模板的错误消息比Rust的要长很多，并且会指出很多不同行的代码，因为编译器没有办法辨别到底是谁的错误导致了这个问题：是模板、或者是它的调用者？</p>
<p>可能显式写出约束最重要的优势是它们就在代码和文档中。你可以在Rust中查看泛型函数的签名，然后看出它到底接受什么类型的参数。而模板则做不到这一点。在像Boost这样的C++库中为参数类型编写完整的文档的工作甚至比我们在这里经历的工作更加艰巨。Boost的开发者们并没有一个可以检查他们的工作的编译器。</p>
<h2 id="trait作为基础">trait作为基础</h2>
<p>trait是Rust最主要的特性之一，并且有充足的理由支持这一观点。设计一个程序或者库时没有什么比设计一个好的接口更重要了。</p>
<p>本章是语法、规则和解释的风暴。现在我们已经铺设好基础了，可以开始讨论Rust中更多trait和泛型的用法。事实上，我们才刚刚触及皮毛。接下来的两章将介绍标准库提供的通用trait。再往后的章节介绍闭包、迭代器、输入/输出、并发。trait和泛型在这些话题中都扮演了中心的角色。</p>

    </div>
<div class="post_comments">
  
  
  
</div>




    <hr>

<div id="gitalk-container"></div>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js" crossorigin="anonymous"></script>
    <script type="text/javascript">
      var gitalk = new Gitalk({
        id: '0001-01-01 00:00:00 \u002b0000 UTC',
        title: '',
        clientID: '72786bf87c19beec6abe',
        clientSecret: '93ce647699b49ea6434332d36b0122a4ad8281ad',
        repo: 'buf1024.github.io',
        owner: 'buf1024',
        admin: ['buf1024'],
        body: decodeURI(location.href)
      });
      gitalk.render('gitalk-container');
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/gitalk/gitalk">comments powered by gitalk.</a></noscript>

  </article>
<aside class="sidebar">
  <section class="sidebar_inner">
    <br>
    


    
    
    <h2 class="mt-4">最新文章</h2>
    <ul class="flex-column">
      <li>
        <a href="https://luoguochun.cn/post/2024-01-13-rust-sqlx-sqlbuilder/" class="nav-link" title="Rust sqlx SQLBuilder">Rust sqlx SQLBuilder</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2024-01-08-vite-engineering-config/" class="nav-link" title="前端工程化配置保姆级教程">前端工程化配置保姆级教程</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-12-26-rust-proc-macro/" class="nav-link" title="rust 过程宏">rust 过程宏</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-09-21-rust-panic/" class="nav-link" title="一行代码让 rustc panic">一行代码让 rustc panic</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-07-19-flutter-muti-window/" class="nav-link" title="Flutter 桌面端多窗口支持">Flutter 桌面端多窗口支持</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-07-04-hiqradio/" class="nav-link" title="hiqradio 一个简单的收音机软件">hiqradio 一个简单的收音机软件</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-03-21-android-https/" class="nav-link" title="android https 抓包">android https 抓包</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-03-16-love-for-insterest/" class="nav-link" title="为爱发电终是不能长久的……">为爱发电终是不能长久的……</a>
      </li>
    </ul>
    <div>
      <h2 class="mt-4 taxonomy" id="categories-section">分类</h2>
      <nav class="tags_nav">
        <a href='https://luoguochun.cn/categories/misc/' class="post_tag button button_translucent" title="misc">
          MISC
          <span class="button_tally">11</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/linux/' class="post_tag button button_translucent" title="linux">
          LINUX
          <span class="button_tally">8</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/tcp/' class="post_tag button button_translucent" title="tcp">
          TCP
          <span class="button_tally">8</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/c/' class="post_tag button button_translucent" title="c">
          C
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/flutter/' class="post_tag button button_translucent" title="flutter">
          FLUTTER
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/rust/' class="post_tag button button_translucent" title="rust">
          RUST
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/python/' class="post_tag button button_translucent" title="python">
          PYTHON
          <span class="button_tally">6</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/c&#43;&#43;/' class="post_tag button button_translucent" title="c&#43;&#43;">
          C&#43;&#43;
          <span class="button_tally">4</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/web/' class="post_tag button button_translucent" title="web">
          WEB
          <span class="button_tally">4</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/gcc/' class="post_tag button button_translucent" title="gcc">
          GCC
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/git/' class="post_tag button button_translucent" title="git">
          GIT
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/reactjs/' class="post_tag button button_translucent" title="reactjs">
          REACTJS
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/unittest/' class="post_tag button button_translucent" title="unittest">
          UNITTEST
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/vim/' class="post_tag button button_translucent" title="vim">
          VIM
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/%E6%9E%84%E6%9E%B6/' class="post_tag button button_translucent" title="构架">
          构架
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/asm/' class="post_tag button button_translucent" title="asm">
          ASM
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/docker/' class="post_tag button button_translucent" title="docker">
          DOCKER
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/go/' class="post_tag button button_translucent" title="go">
          GO
          <span class="button_tally">1</span>
        </a>
        
        
      </nav>
    </div>
    <div>
      <h2 class="mt-4 taxonomy" id="tags-section">标签</h2>
      <nav class="tags_nav">
        <a href='https://luoguochun.cn/tags/c/' class="post_tag button button_translucent" title="c">
          C
          <span class="button_tally">21</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/linux/' class="post_tag button button_translucent" title="linux">
          LINUX
          <span class="button_tally">16</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/c&#43;&#43;/' class="post_tag button button_translucent" title="c&#43;&#43;">
          C&#43;&#43;
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/python/' class="post_tag button button_translucent" title="python">
          PYTHON
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/tcp/' class="post_tag button button_translucent" title="tcp">
          TCP
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/dart/' class="post_tag button button_translucent" title="dart">
          DART
          <span class="button_tally">6</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/flutter/' class="post_tag button button_translucent" title="flutter">
          FLUTTER
          <span class="button_tally">6</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/rust/' class="post_tag button button_translucent" title="rust">
          RUST
          <span class="button_tally">4</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/tdd/' class="post_tag button button_translucent" title="tdd">
          TDD
          <span class="button_tally">4</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/android/' class="post_tag button button_translucent" title="android">
          ANDROID
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/git/' class="post_tag button button_translucent" title="git">
          GIT
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/gtest/' class="post_tag button button_translucent" title="gtest">
          GTEST
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/js/' class="post_tag button button_translucent" title="js">
          JS
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/rust-lib/' class="post_tag button button_translucent" title="rust-lib">
          RUST-LIB
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/vcs/' class="post_tag button button_translucent" title="vcs">
          VCS
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/vim/' class="post_tag button button_translucent" title="vim">
          VIM
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/asm/' class="post_tag button button_translucent" title="asm">
          ASM
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/css/' class="post_tag button button_translucent" title="css">
          CSS
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/gas/' class="post_tag button button_translucent" title="gas">
          GAS
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/gcc/' class="post_tag button button_translucent" title="gcc">
          GCC
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/http/' class="post_tag button button_translucent" title="http">
          HTTP
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/libevent/' class="post_tag button button_translucent" title="libevent">
          LIBEVENT
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/macos/' class="post_tag button button_translucent" title="macos">
          MACOS
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/react-native/' class="post_tag button button_translucent" title="react-native">
          REACT-NATIVE
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/redis/' class="post_tag button button_translucent" title="redis">
          REDIS
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/%E6%9E%84%E6%9E%B6/' class="post_tag button button_translucent" title="构架">
          构架
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/api/' class="post_tag button button_translucent" title="api">
          API
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/bt/' class="post_tag button button_translucent" title="bt">
          BT
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/c&#43;/' class="post_tag button button_translucent" title="c&#43;">
          C&#43;
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/coroutine/' class="post_tag button button_translucent" title="coroutine">
          COROUTINE
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/database/' class="post_tag button button_translucent" title="database">
          DATABASE
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/docker/' class="post_tag button button_translucent" title="docker">
          DOCKER
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/endian/' class="post_tag button button_translucent" title="endian">
          ENDIAN
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/frontend/' class="post_tag button button_translucent" title="frontend">
          FRONTEND
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/gdb/' class="post_tag button button_translucent" title="gdb">
          GDB
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/go/' class="post_tag button button_translucent" title="go">
          GO
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/html/' class="post_tag button button_translucent" title="html">
          HTML
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/https/' class="post_tag button button_translucent" title="https">
          HTTPS
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/jquery/' class="post_tag button button_translucent" title="jquery">
          JQUERY
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/ld/' class="post_tag button button_translucent" title="ld">
          LD
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/logger/' class="post_tag button button_translucent" title="logger">
          LOGGER
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/makefile/' class="post_tag button button_translucent" title="makefile">
          MAKEFILE
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/misc/' class="post_tag button button_translucent" title="misc">
          MISC
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/orm/' class="post_tag button button_translucent" title="orm">
          ORM
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/os/' class="post_tag button button_translucent" title="os">
          OS
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/process/' class="post_tag button button_translucent" title="process">
          PROCESS
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/react/' class="post_tag button button_translucent" title="react">
          REACT
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/rpm/' class="post_tag button button_translucent" title="rpm">
          RPM
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/rsa/' class="post_tag button button_translucent" title="rsa">
          RSA
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/server/' class="post_tag button button_translucent" title="server">
          SERVER
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/sqlalchemy/' class="post_tag button button_translucent" title="sqlalchemy">
          SQLALCHEMY
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/ssh/' class="post_tag button button_translucent" title="ssh">
          SSH
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/ssl/tls/' class="post_tag button button_translucent" title="ssl/tls">
          SSL/TLS
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/vc/' class="post_tag button button_translucent" title="vc">
          VC
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/vite/' class="post_tag button button_translucent" title="vite">
          VITE
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/vue/' class="post_tag button button_translucent" title="vue">
          VUE
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/webui/' class="post_tag button button_translucent" title="webui">
          WEBUI
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/wechat/' class="post_tag button button_translucent" title="wechat">
          WECHAT
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/win32/' class="post_tag button button_translucent" title="win32">
          WIN32
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/windows/' class="post_tag button button_translucent" title="windows">
          WINDOWS
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/wireshark/' class="post_tag button button_translucent" title="wireshark">
          WIRESHARK
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/' class="post_tag button button_translucent" title="微服务">
          微服务
          <span class="button_tally">1</span>
        </a>
        
        
      </nav>
    </div>
  </section>
</aside>

  
</div>
  </main><svg width="0" height="0" class="hidden">
  <symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="facebook">
    <path d="M437 0H75C33.648 0 0 33.648 0 75v362c0 41.352 33.648 75 75 75h151V331h-60v-90h60v-61c0-49.629 40.371-90 90-90h91v90h-91v61h91l-15 90h-76v181h121c41.352 0 75-33.648 75-75V75c0-41.352-33.648-75-75-75zm0 0"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18.001 18.001" id="twitter">
    <path d="M15.891 4.013c.808-.496 1.343-1.173 1.605-2.034a8.68 8.68 0 0 1-2.351.861c-.703-.756-1.593-1.14-2.66-1.14-1.043 0-1.924.366-2.643 1.078a3.56 3.56 0 0 0-1.076 2.605c0 .309.039.585.117.819-3.076-.105-5.622-1.381-7.628-3.837-.34.601-.51 1.213-.51 1.846 0 1.301.549 2.332 1.645 3.089-.625-.053-1.176-.211-1.645-.47 0 .929.273 1.705.82 2.388a3.623 3.623 0 0 0 2.115 1.291c-.312.08-.641.118-.979.118-.312 0-.533-.026-.664-.083.23.757.664 1.371 1.291 1.841a3.652 3.652 0 0 0 2.152.743C4.148 14.173 2.625 14.69.902 14.69c-.422 0-.721-.006-.902-.038 1.697 1.102 3.586 1.649 5.676 1.649 2.139 0 4.029-.542 5.674-1.626 1.645-1.078 2.859-2.408 3.639-3.974a10.77 10.77 0 0 0 1.172-4.892v-.468a7.788 7.788 0 0 0 1.84-1.921 8.142 8.142 0 0 1-2.11.593z"
      ></path>
  </symbol>
  <symbol aria-hidden="true" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="mail">
    <path  d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="calendar">
    <path d="M452 40h-24V0h-40v40H124V0H84v40H60C26.916 40 0 66.916 0 100v352c0 33.084 26.916 60 60 60h392c33.084 0 60-26.916 60-60V100c0-33.084-26.916-60-60-60zm20 412c0 11.028-8.972 20-20 20H60c-11.028 0-20-8.972-20-20V188h432v264zm0-304H40v-48c0-11.028 8.972-20 20-20h24v40h40V80h264v40h40V80h24c11.028 0 20 8.972 20 20v48z"></path>
    <path d="M76 230h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zM76 310h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zM76 390h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zm80-80h40v40h-40z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="github">
    <path d="M255.968 5.329C114.624 5.329 0 120.401 0 262.353c0 113.536 73.344 209.856 175.104 243.872 12.8 2.368 17.472-5.568 17.472-12.384 0-6.112-.224-22.272-.352-43.712-71.2 15.52-86.24-34.464-86.24-34.464-11.616-29.696-28.416-37.6-28.416-37.6-23.264-15.936 1.728-15.616 1.728-15.616 25.696 1.824 39.2 26.496 39.2 26.496 22.848 39.264 59.936 27.936 74.528 21.344 2.304-16.608 8.928-27.936 16.256-34.368-56.832-6.496-116.608-28.544-116.608-127.008 0-28.064 9.984-51.008 26.368-68.992-2.656-6.496-11.424-32.64 2.496-68 0 0 21.504-6.912 70.4 26.336 20.416-5.696 42.304-8.544 64.096-8.64 21.728.128 43.648 2.944 64.096 8.672 48.864-33.248 70.336-26.336 70.336-26.336 13.952 35.392 5.184 61.504 2.56 68 16.416 17.984 26.304 40.928 26.304 68.992 0 98.72-59.84 120.448-116.864 126.816 9.184 7.936 17.376 23.616 17.376 47.584 0 34.368-.32 62.08-.32 70.496 0 6.88 4.608 14.88 17.6 12.352C438.72 472.145 512 375.857 512 262.353 512 120.401 397.376 5.329 255.968 5.329z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 212 212" id="gitlab">
    <path d="M12.3 74.7h54L43.3 3c-1-3.6-6.4-3.6-7.6 0L12.3 74.8z" />
    <path d="M12.3 74.7L.5 111c-1 3.2 0 6.8 3 8.8l101.6 74-92.5-119z"/>
    <path d="M105 193.7l-38.6-119h-54l92.7 119z"/>
    <path d="M105 193.7l38.7-119H66.4l38.7 119z"/>
    <path d="M105 193.7l38.7-119H198l-93 119z"/>
    <path d="M198 74.7l11.6 36.2c1 3 0 6.6-3 8.6l-101.5 74 93-119z"/>
    <path d="M198 74.7h-54.3L167 3c1.2-3.6 6.4-3.6 7.6 0L198 74.8z"/>
  </symbol>
  <symbol viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="rss">
    <circle cx="3.429" cy="20.571" r="3.429"></circle>
    <path d="M11.429 24h4.57C15.999 15.179 8.821 8.001 0 8v4.572c6.302.001 11.429 5.126 11.429 11.428z"></path>
    <path d="M24 24C24 10.766 13.234 0 0 0v4.571c10.714 0 19.43 8.714 19.43 19.429z"></path>
  </symbol>
  <symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="linkedin">
    <path d="M437 0H75C33.648 0 0 33.648 0 75v362c0 41.352 33.648 75 75 75h362c41.352 0 75-33.648 75-75V75c0-41.352-33.648-75-75-75zM181 406h-60V196h60zm0-240h-60v-60h60zm210 240h-60V286c0-16.54-13.46-30-30-30s-30 13.46-30 30v120h-60V196h60v11.309C286.719 202.422 296.93 196 316 196c40.691.043 75 36.547 75 79.688zm0 0"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 612 612" id="to-top">
    <path d="M604.501 440.509L325.398 134.956c-5.331-5.357-12.423-7.627-19.386-7.27-6.989-.357-14.056 1.913-19.387 7.27L7.499 440.509c-9.999 10.024-9.999 26.298 0 36.323s26.223 10.024 36.222 0l262.293-287.164L568.28 476.832c9.999 10.024 26.222 10.024 36.221 0 9.999-10.023 9.999-26.298 0-36.323z"></path>
  </symbol>
  <symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="carly">
    <path d="M504.971 239.029L448 182.059V84c0-46.317-37.682-84-84-84h-44c-13.255 0-24 10.745-24 24s10.745 24 24 24h44c19.851 0 36 16.149 36 36v108c0 6.365 2.529 12.47 7.029 16.971L454.059 256l-47.029 47.029A24.002 24.002 0 0 0 400 320v108c0 19.851-16.149 36-36 36h-44c-13.255 0-24 10.745-24 24s10.745 24 24 24h44c46.318 0 84-37.683 84-84v-98.059l56.971-56.971c9.372-9.372 9.372-24.568 0-33.941zM112 192V84c0-19.851 16.149-36 36-36h44c13.255 0 24-10.745 24-24S205.255 0 192 0h-44c-46.318 0-84 37.683-84 84v98.059l-56.971 56.97c-9.373 9.373-9.373 24.568 0 33.941L64 329.941V428c0 46.317 37.682 84 84 84h44c13.255 0 24-10.745 24-24s-10.745-24-24-24h-44c-19.851 0-36-16.149-36-36V320c0-6.365-2.529-12.47-7.029-16.971L57.941 256l47.029-47.029A24.002 24.002 0 0 0 112 192z"></path>
  </symbol>
  <symbol viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="copy">
    <path d="M23 2.75A2.75 2.75 0 0 0 20.25 0H8.75A2.75 2.75 0 0 0 6 2.75v13.5A2.75 2.75 0 0 0 8.75 19h11.5A2.75 2.75 0 0 0 23 16.25zM18.25 14.5h-7.5a.75.75 0 0 1 0-1.5h7.5a.75.75 0 0 1 0 1.5zm0-3h-7.5a.75.75 0 0 1 0-1.5h7.5a.75.75 0 0 1 0 1.5zm0-3h-7.5a.75.75 0 0 1 0-1.5h7.5a.75.75 0 0 1 0 1.5z"></path>
    <path d="M8.75 20.5a4.255 4.255 0 0 1-4.25-4.25V2.75c0-.086.02-.166.025-.25H3.75A2.752 2.752 0 0 0 1 5.25v16A2.752 2.752 0 0 0 3.75 24h12a2.752 2.752 0 0 0 2.75-2.75v-.75z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512.001 512.001" id="closeme">
    <path d="M284.286 256.002L506.143 34.144c7.811-7.811 7.811-20.475 0-28.285-7.811-7.81-20.475-7.811-28.285 0L256 227.717 34.143 5.859c-7.811-7.811-20.475-7.811-28.285 0-7.81 7.811-7.811 20.475 0 28.285l221.857 221.857L5.858 477.859c-7.811 7.811-7.811 20.475 0 28.285a19.938 19.938 0 0 0 14.143 5.857 19.94 19.94 0 0 0 14.143-5.857L256 284.287l221.857 221.857c3.905 3.905 9.024 5.857 14.143 5.857s10.237-1.952 14.143-5.857c7.811-7.811 7.811-20.475 0-28.285L284.286 256.002z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="open-menu">
    <path d="M492 236H20c-11.046 0-20 8.954-20 20s8.954 20 20 20h472c11.046 0 20-8.954 20-20s-8.954-20-20-20zm0-160H20C8.954 76 0 84.954 0 96s8.954 20 20 20h472c11.046 0 20-8.954 20-20s-8.954-20-20-20zm0 320H20c-11.046 0-20 8.954-20 20s8.954 20 20 20h472c11.046 0 20-8.954 20-20s-8.954-20-20-20z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="instagram">
    <path d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948 0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072 3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.163 6.162 6.163 6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zm0 10.162c-2.209 0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796 0-1.441.645-1.441 1.44s.645 1.44 1.441 1.44c.795 0 1.439-.645 1.439-1.44s-.644-1.44-1.439-1.44z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id=youtube>
    <path d="M19.615 3.184c-3.604-.246-11.631-.245-15.23 0-3.897.266-4.356 2.62-4.385 8.816.029 6.185.484 8.549 4.385 8.816 3.6.245 11.626.246 15.23 0 3.897-.266 4.356-2.62 4.385-8.816-.029-6.185-.484-8.549-4.385-8.816zm-10.615 12.816v-8l8 3.993-8 4.007z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="stackoverflow">
    <path d="M21 27v-8h3v11H0V19h3v8h18z"></path><path d="M17.1.2L15 1.8l7.9 10.6 2.1-1.6L17.1.2zm3.7 14.7L10.6 6.4l1.7-2 10.2 8.5-1.7 2zM7.2 12.3l12 5.6 1.1-2.4-12-5.6-1.1 2.4zm-1.8 6.8l13.56 1.96.17-2.38-13.26-2.55-.47 2.97zM19 25H5v-3h14v3z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="xing">
    <path d="M18.188 0c-.517 0-.741.325-.927.66 0 0-7.455 13.224-7.702 13.657.015.024 4.919 9.023 4.919 9.023.17.308.436.66.967.66h3.454c.211 0 .375-.078.463-.22.089-.151.089-.346-.009-.536l-4.879-8.916c-.004-.006-.004-.016 0-.022L22.139.756c.095-.191.097-.387.006-.535C22.056.078 21.894 0 21.686 0h-3.498zM3.648 4.74c-.211 0-.385.074-.473.216-.09.149-.078.339.02.531l2.34 4.05c.004.01.004.016 0 .021L1.86 16.051c-.099.188-.093.381 0 .529.085.142.239.234.45.234h3.461c.518 0 .766-.348.945-.667l3.734-6.609-2.378-4.155c-.172-.315-.434-.659-.962-.659H3.648v.016z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 71 55" id="discord">
    <path d="M60.1045 4.8978C55.5792 2.8214 50.7265 1.2916 45.6527 0.41542C45.5603 0.39851 45.468 0.440769 45.4204 0.525289C44.7963 1.6353 44.105 3.0834 43.6209 4.2216C38.1637 3.4046 32.7345 3.4046 27.3892 4.2216C26.905 3.0581 26.1886 1.6353 25.5617 0.525289C25.5141 0.443589 25.4218 0.40133 25.3294 0.41542C20.2584 1.2888 15.4057 2.8186 10.8776 4.8978C10.8384 4.9147 10.8048 4.9429 10.7825 4.9795C1.57795 18.7309 -0.943561 32.1443 0.293408 45.3914C0.299005 45.4562 0.335386 45.5182 0.385761 45.5576C6.45866 50.0174 12.3413 52.7249 18.1147 54.5195C18.2071 54.5477 18.305 54.5139 18.3638 54.4378C19.7295 52.5728 20.9469 50.6063 21.9907 48.5383C22.0523 48.4172 21.9935 48.2735 21.8676 48.2256C19.9366 47.4931 18.0979 46.6 16.3292 45.5858C16.1893 45.5041 16.1781 45.304 16.3068 45.2082C16.679 44.9293 17.0513 44.6391 17.4067 44.3461C17.471 44.2926 17.5606 44.2813 17.6362 44.3151C29.2558 49.6202 41.8354 49.6202 53.3179 44.3151C53.3935 44.2785 53.4831 44.2898 53.5502 44.3433C53.9057 44.6363 54.2779 44.9293 54.6529 45.2082C54.7816 45.304 54.7732 45.5041 54.6333 45.5858C52.8646 46.6197 51.0259 47.4931 49.0921 48.2228C48.9662 48.2707 48.9102 48.4172 48.9718 48.5383C50.038 50.6034 51.2554 52.5699 52.5959 54.435C52.6519 54.5139 52.7526 54.5477 52.845 54.5195C58.6464 52.7249 64.529 50.0174 70.6019 45.5576C70.6551 45.5182 70.6887 45.459 70.6943 45.3942C72.1747 30.0791 68.2147 16.7757 60.1968 4.9823C60.1772 4.9429 60.1437 4.9147 60.1045 4.8978ZM23.7259 37.3253C20.2276 37.3253 17.3451 34.1136 17.3451 30.1693C17.3451 26.225 20.1717 23.0133 23.7259 23.0133C27.308 23.0133 30.1626 26.2532 30.1066 30.1693C30.1066 34.1136 27.28 37.3253 23.7259 37.3253ZM47.3178 37.3253C43.8196 37.3253 40.9371 34.1136 40.9371 30.1693C40.9371 26.225 43.7636 23.0133 47.3178 23.0133C50.9 23.0133 53.7545 26.2532 53.6986 30.1693C53.6986 34.1136 50.9 37.3253 47.3178 37.3253Z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 17 18" id="mastodon">
    <path
    fill="#ffffff"
    d="m 15.054695,9.8859583 c -0.22611,1.1632697 -2.02517,2.4363497 -4.09138,2.6830797 -1.0774504,0.12856 -2.1382704,0.24673 -3.2694704,0.19484 -1.84996,-0.0848 -3.30971,-0.44157 -3.30971,-0.44157 0,0.1801 0.0111,0.35157 0.0333,0.51194 0.24051,1.82571 1.81034,1.93508 3.29737,1.98607 1.50088,0.0514 2.8373104,-0.37004 2.8373104,-0.37004 l 0.0617,1.35686 c 0,0 -1.0498104,0.56374 -2.9199404,0.66742 -1.03124,0.0567 -2.3117,-0.0259 -3.80308,-0.42069 -3.23454998,-0.85613 -3.79081998,-4.304 -3.87592998,-7.8024197 -0.026,-1.03871 -0.01,-2.01815 -0.01,-2.83732 0,-3.57732 2.34385998,-4.62587996 2.34385998,-4.62587996 1.18184,-0.54277 3.20976,-0.77101 5.318,-0.7882499985409 h 0.0518 C 9.8267646,0.01719834 11.856025,0.24547834 13.037775,0.78824834 c 0,0 2.34377,1.04855996 2.34377,4.62587996 0,0 0.0294,2.63937 -0.32687,4.47183"/>
 <path
    fill="#000000"
    d="m 12.616925,5.6916583 v 4.3315297 h -1.71607 V 5.8189683 c 0,-0.88624 -0.37289,-1.33607 -1.1187604,-1.33607 -0.82467,0 -1.23799,0.53361 -1.23799,1.58875 v 2.30122 h -1.70594 v -2.30122 c 0,-1.05514 -0.4134,-1.58875 -1.23808,-1.58875 -0.74587,0 -1.11876,0.44983 -1.11876,1.33607 v 4.2042197 h -1.71607 V 5.6916583 c 0,-0.88527 0.22541,-1.58876 0.67817,-2.10922 0.46689,-0.52047 1.07833,-0.78727 1.83735,-0.78727 0.87816,0 1.54317,0.33752 1.98288,1.01267 l 0.42744,0.71655 0.42753,-0.71655 c 0.43961,-0.67515 1.10463,-1.01267 1.9828704,-1.01267 0.75893,0 1.37037,0.2668 1.83735,0.78727 0.45268,0.52046 0.67808,1.22395 0.67808,2.10922"/>
  </symbol>
</svg>

<footer class="footer">
  <div class="footer_inner wrap pale">
    <img src='https://luoguochun.cn/icons/apple-touch-icon.png' class="icon icon_2 transparent" alt="BUF1024">
    <p>Copyright&nbsp;2011-&nbsp;<span class="year"></span>&nbsp;BUF1024. All Rights Reserved</p><a class="to_top" href="#documentTop">
  <svg class="icon">
  <title>to-top</title>
  <use xlink:href="#to-top"></use>
</svg>

</a>

  </div>
</footer>

<script type="text/javascript" src="https://luoguochun.cn/zh-cn/js/bundle.884eccc71c2848fb4aeb15945329b5a857717f0313da00cb46b765b5734cfa64b08ce2609627167129c2de17d9b47ed210682f96a2502ebb3aadc73191740211.js" integrity="sha512-iE7MxxwoSPtK6xWUUym1qFdxfwMT2gDLRrdltXNM&#43;mSwjOJglicWcSnC3hfZtH7SEGgvlqJQLrs6rccxkXQCEQ==" crossorigin="anonymous"></script>
</body>

</html>

<!DOCTYPE html>
<html lang="zh-cn" data-figures=""  class="page"   >

<head>
<title>BUF1024</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">





<meta property="og:locale" content="zh-cn" />

<meta property="og:type" content="article">
<meta name="description" content="结构体 Long ago, when shepherds wanted to see if two herds of sheep were isomorphic, they would look for an explicit isomorphism ——John C. Baez and James Dolan, …" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:creator" content="">
<meta name="twitter:title" content="" />
<meta name="twitter:image" content="https://luoguochun.cn"/>
<meta property="og:url" content="https://luoguochun.cn/prust/ch09/" />
<meta property="og:title" content="" />
<meta property="og:description" content="结构体 Long ago, when shepherds wanted to see if two herds of sheep were isomorphic, they would look for an explicit isomorphism ——John C. Baez and James Dolan, …" />
<meta property="og:image" content="https://luoguochun.cn" />
  <meta name="keywords" content="blog,computer,luoguochun" />

<link rel="apple-touch-icon" sizes="180x180" href="https://luoguochun.cn/icons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://luoguochun.cn/icons/favicon-32x32.png">
<link rel="manifest" href="https://luoguochun.cn/icons/site.webmanifest">

<link rel="canonical" href="https://luoguochun.cn/prust/ch09/">



<link rel="preload" href="https://luoguochun.cn/css/styles.42e2c5f6d8cf9c52872666f8d8b2678ad0c426978b9d78aff3c33b7a1e7f6f97f54bcdaf0518a25fb0fe26367d04f8b07c683b3b38b331cb098daadee06b1f3e.css" integrity = "sha512-QuLF9tjPnFKHJmb42LJnitDEJpeLnXiv88M7eh5/b5f1S82vBRiiX7D&#43;JjZ9BPiwfGg7OzizMcsJjare4GsfPg==" as="style" crossorigin="anonymous">



<link rel="preload" href="https://luoguochun.cn/zh-cn/js/bundle.884eccc71c2848fb4aeb15945329b5a857717f0313da00cb46b765b5734cfa64b08ce2609627167129c2de17d9b47ed210682f96a2502ebb3aadc73191740211.js" as="script" integrity=
"sha512-iE7MxxwoSPtK6xWUUym1qFdxfwMT2gDLRrdltXNM&#43;mSwjOJglicWcSnC3hfZtH7SEGgvlqJQLrs6rccxkXQCEQ==" crossorigin="anonymous">


<link rel="stylesheet" type="text/css" href="https://luoguochun.cn/css/styles.42e2c5f6d8cf9c52872666f8d8b2678ad0c426978b9d78aff3c33b7a1e7f6f97f54bcdaf0518a25fb0fe26367d04f8b07c683b3b38b331cb098daadee06b1f3e.css" integrity="sha512-QuLF9tjPnFKHJmb42LJnitDEJpeLnXiv88M7eh5/b5f1S82vBRiiX7D&#43;JjZ9BPiwfGg7OzizMcsJjare4GsfPg==" crossorigin="anonymous">

</head>

<body data-code="100" data-lines="false" id="documentTop"
  data-lang="zh-cn">

<header class="nav_header" >
  <nav class="nav"><a href='https://luoguochun.cn' class="nav_brand nav_item" title="BUF1024">BUF1024
  <div class="nav_close">
    <div><svg class="icon">
  <title>open-menu</title>
  <use xlink:href="#open-menu"></use>
</svg>
<svg class="icon">
  <title>closeme</title>
  <use xlink:href="#closeme"></use>
</svg>
</div>
  </div>
</a>

    <div class='nav_body nav_body_left'>
      
      
      
        

  <div class="nav_parent">
    <a href="https://luoguochun.cn/" class="nav_item" title="主页">主页 </a>
  </div>
  <div class="nav_parent">
    <a href="https://luoguochun.cn" class="nav_item" title="链接">链接 <img src='https://luoguochun.cn/icons/caret-icon.svg' alt="icon" class="nav_icon"></a>
    <div class="nav_sub">
      <span class="nav_child"></span>
        <a href="https://luoguochun.cn/talib-doc/" class="nav_child nav_item" title="TA 技术分析库">TA 技术分析库</a>
        <a href="https://luoguochun.cn/hiqradio" class="nav_child nav_item" title="hiqadio网络收音机">hiqadio网络收音机</a>
    </div>
  </div>
  <div class="nav_parent">
    <a href="https://luoguochun.cn/about/" class="nav_item" title="关于">关于 </a>
  </div>
      
<div class='follow'>
<div class="color_mode">
  <input type="checkbox" class="color_choice" id="mode">
</div>

</div>

    </div>
  </nav>
</header>

  <main>
  
<div class="grid-inverse wrap content">
  <article class="post_content">
    <h1 class="post_title"></h1>
  <div class="post_meta">
    <span><svg class="icon">
  <title>calendar</title>
  <use xlink:href="#calendar"></use>
</svg>
</span>
    <span class="post_date">
      Jan 1, 0001</span>
    <span class="post_time"> · 25 min read</span>
    <span class="page_only">&nbsp;·
  <div class="post_share">
    分享到:
    <a href="https://twitter.com/intent/tweet?text=&url=https%3a%2f%2fluoguochun.cn%2fprust%2fch09%2f&tw_p=tweetbutton" class="twitter" title="分享到 Twitter" target="_blank" rel="nofollow">
      <svg class="icon">
  <title>twitter</title>
  <use xlink:href="#twitter"></use>
</svg>

    </a>
    <a href="https://www.facebook.com/sharer.php?u=https%3a%2f%2fluoguochun.cn%2fprust%2fch09%2f&t=" class="facebook" title="分享到 Facebook" target="_blank" rel="nofollow">
      <svg class="icon">
  <title>facebook</title>
  <use xlink:href="#facebook"></use>
</svg>

    </a>
    <a href="#linkedinshare" id = "linkedinshare" class="linkedin" title="分享到 LinkedIn" rel="nofollow">
      <svg class="icon">
  <title>linkedin</title>
  <use xlink:href="#linkedin"></use>
</svg>

    </a>
    <a href="https://luoguochun.cn/prust/ch09/" title="Copy Link" class="link link_yank">
      <svg class="icon">
  <title>copy</title>
  <use xlink:href="#copy"></use>
</svg>

    </a>
  </div>
  </span>
  </div>

    <div class="post_body"><h1 id="结构体">结构体</h1>
<p><em>Long ago, when shepherds wanted to see if two herds of sheep were isomorphic, they would look for an explicit isomorphism</em></p>
<p align="right">
    ——John C. Baez and James Dolan, “<a href="https://arxiv.org/abs/math/9802029">Categorification</a>”
</p>
<p>Rust的结构体，有时也称为 <em>structure</em> ，类似于C和C++中的<code>struct</code>类型、Python中的<code>class</code>、JavaScript中的对象。一个结构体把多个不同类型的值组合成单个值，所以你可以将它们作为一个整体进行处理，你也可以读取并且修改结构体的各个组成部分。一个结构体也可以有一些关联的方法来操作它的组成部分。</p>
<p>Rust有三种类型的结构体： <em>命名字段(name-field)</em> 、 <em>类元组(tuple-like)</em> 、 <em>类单元(unit-like)</em> ，它们的区别在于如何引用它们的组成部分：一个命名字段结构体给每一个组件取了一个名字，而类元组结构体用它们出现的顺序来标识它们。类单元结构体没有任何组成部分，它并不常见，但可能比你想象中的更加有用。</p>
<p>在本章中我们将详细解释每一种结构体，并展示它们在内存中的布局。我们将介绍如何给它们添加方法、如何定义可以处理很多不同类型组件的泛型结构体、以及如何让Rust为你的结构体生成通用的trait的实现。</p>
<h2 id="命名字段结构体">命名字段结构体</h2>
<p>一个命名字段结构体的定义类似于这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="sd">/// 一个8位灰度像素的矩形
</span><span class="sd"></span><span class="w">    </span><span class="k">struct</span> <span class="nc">GrayscaleMap</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">pixels</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">size</span>: <span class="p">(</span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这里声明了一个结构体类型<code>GrayscaleMap</code>，它有两个字段分别命名为<code>pixels</code>和<code>size</code>。Rust的一个习惯是所有的类型包括结构体，名称中的每一个单词的首字母大写，例如<code>GrayscaleMap</code>，这种习惯称为 <em>大驼峰命名法</em> （或 <em>帕斯卡命名法</em> ）。字段和方法名都是小写，用下划线分隔每个单词。这被称为 <em>蛇形命名法</em> 。</p>
<p>你可以用 <em>结构体表达式</em> 构造一个这种类型的值，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1024</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">576</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">image</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GrayscaleMap</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">pixels</span>: <span class="nc">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">height</span><span class="p">],</span><span class="w">
</span><span class="w">        </span><span class="n">size</span>: <span class="p">(</span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>结构体表达式以类型名称开始(<code>GrayscaleMap</code>)，然后在花括号中列出每一个字段的名称和值。还有一种缩写可以用同名的局部变量来充当字段：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">new_map</span><span class="p">(</span><span class="n">size</span>: <span class="p">(</span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="kt">usize</span><span class="p">),</span><span class="w"> </span><span class="n">pixels</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">GrayscaleMap</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pixels</span><span class="p">.</span><span class="n">len</span><span class="p">(),</span><span class="w"> </span><span class="n">size</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">size</span><span class="p">.</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="n">GrayscaleMap</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">pixels</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>结构体表达式<code>GrayscaleMap { pixels, size }</code>是<code>GrayscaleMap { pixels: pixels, size: size }</code>的缩写。你也可以在使用同名字段缩写的同时使用<code>key: value</code>语法为其它字段赋值。</p>
<p>访问一个结构体的字段需要使用熟悉的<code>.</code>运算符：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">image</span><span class="p">.</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span><span class="w"> </span><span class="mi">476</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">image</span><span class="p">.</span><span class="n">pixels</span><span class="p">.</span><span class="n">len</span><span class="p">(),</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">576</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>和其他item一样，结构体默认是私有的，只在它们声明的模块及其子模块中可见。你可以通过在定义前加<code>pub</code>来让结构体在模块之外也可见。它的每一个字段也是这样，默认也是私有的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="sd">/// 一个8位灰度像素的矩形
</span><span class="sd"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">GrayscaleMap</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">pub</span><span class="w"> </span><span class="n">pixels</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="k">pub</span><span class="w"> </span><span class="n">size</span>: <span class="p">(</span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>即使结构体被声明为<code>pub</code>，它的字段也可以是私有的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="sd">/// 一个8位灰度像素的矩形
</span><span class="sd"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">GrayscaleMap</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">pixels</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">size</span>: <span class="p">(</span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>其他的模块可以使用这个结构体和它的所有公有的关联函数，但不能通过字段名访问私有的字段，也不能通过结构体表达式创建新的<code>GrayscaleMap</code>值。也就是说，创建一个结构体的值要求所有的结构体字段都可见。这也是为什么你不能通过结构体表达式创建新的<code>String</code>或者<code>Vec</code>。这些标准类型都是结构体，但它们的字段全都是私有的。要想创建一个这些类型的值，你必须使用公有的类型关联函数，例如<code>Vec::new()</code>。</p>
<p>在创建一个命名字段结构体值的时候，你可以使用另一个相同类型的结构体来提供你省略的字段的值。在一个结构体表达式中，如果命名字段最后跟着一个<code>.. EXPR</code>，那么没有提到的字段将从<code>EXPR</code>中获取值，<code>EXPR</code>必须是另一个相同类型的值。假设我们有一个代表游戏中的怪物的结构体：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="c1">// 在这个游戏中，连扫帚都是怪物。
</span><span class="c1"></span><span class="w">    </span><span class="k">struct</span> <span class="nc">Broom</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">name</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">height</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">health</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">position</span>: <span class="p">(</span><span class="kt">f32</span><span class="p">,</span><span class="w"> </span><span class="kt">f32</span><span class="p">,</span><span class="w"> </span><span class="kt">f32</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">intent</span>: <span class="nc">BroomIntent</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="sd">/// 一个`Broom`的工作状态有两种可能。
</span><span class="sd"></span><span class="w">    </span><span class="cp">#[derive(Copy, Clone)]</span><span class="w">
</span><span class="w">    </span><span class="k">enum</span> <span class="nc">BroomIntent</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">FetchWater</span><span class="p">,</span><span class="w"> </span><span class="n">DumpWater</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>对程序员来说最好的童话是 <em>魔法师的学徒</em> ：一个魔法师学徒制造了一把能替他工作的扫帚，但工作完成之后却不知道该如何停止它。用斧头把扫帚劈成两半会产生两把扫帚，每个只有一半大小，但仍然像之前一样盲目地继续工作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="c1">// 以值接受输入的扫帚，会获取所有权
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">chop</span><span class="p">(</span><span class="n">b</span>: <span class="nc">Broom</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">(</span><span class="n">Broom</span><span class="p">,</span><span class="w"> </span><span class="n">Broom</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// 用`b`初始化`broom1`的大部分，只修改`height`。因为
</span><span class="c1"></span><span class="w">        </span><span class="c1">// `String`不是`Copy`，因此`broom1`会获取`b`的name的所有权。
</span><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">broom1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Broom</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">height</span>: <span class="nc">b</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="c1">// 用`broom1`初始化`broom2`的大部分。因为`String`不是
</span><span class="c1"></span><span class="w">        </span><span class="c1">// `Copy`，所以我们必须显式克隆`name`
</span><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">broom2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Broom</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">name</span>: <span class="nc">broom1</span><span class="p">.</span><span class="n">name</span><span class="p">.</span><span class="n">clone</span><span class="p">(),</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="n">broom1</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="c1">// 给两半分别起不同的名字。
</span><span class="c1"></span><span class="w">        </span><span class="n">broom1</span><span class="p">.</span><span class="n">name</span><span class="p">.</span><span class="n">push_str</span><span class="p">(</span><span class="s">&#34; I&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="n">broom2</span><span class="p">.</span><span class="n">name</span><span class="p">.</span><span class="n">push_str</span><span class="p">(</span><span class="s">&#34; II&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="n">broom1</span><span class="p">,</span><span class="w"> </span><span class="n">broom2</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这个定义完成之后，我们可以创建一个扫帚，将它劈成两半，然后我们会得到：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">hokey</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Broom</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">name</span>: <span class="s">&#34;Hokey&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="n">height</span>: <span class="mi">60</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">width</span>: <span class="mi">100</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">health</span>: <span class="mi">100</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">position</span>: <span class="p">(</span><span class="mf">100.0</span><span class="p">,</span><span class="w"> </span><span class="mf">200.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">intent</span>: <span class="nc">BroomIntent</span>::<span class="n">FetchWater</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">hokey1</span><span class="p">,</span><span class="w"> </span><span class="n">hokey2</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">chop</span><span class="p">(</span><span class="n">hokey</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">hokey1</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Hokey I&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">hokey1</span><span class="p">.</span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="mi">30</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">hokey1</span><span class="p">.</span><span class="n">health</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">hokey2</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Hokey II&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">hokey2</span><span class="p">.</span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="mi">30</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">hokey2</span><span class="p">.</span><span class="n">health</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>新的<code>hokey1</code>和<code>hokey2</code>扫帚接收到了新的调整之后的名字，高度减半，其他的值都和原来一样。</p>
<h2 id="类元组结构体">类元组结构体</h2>
<p>第二种结构体类型称为 <em>类元组结构体</em> ，因为它类似一个元组：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">struct</span> <span class="nc">Bounds</span><span class="p">(</span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="kt">usize</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>你可以像构建元组一样构造一个这种类型的值，除了必须要包含结构体的名字：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">image_bounds</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Bounds</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span><span class="w"> </span><span class="mi">768</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>类元组结构体持有的值被称为 <em>元素</em> ，就像元组持有的值一样。你可以像访问元组的元素一样访问它们：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">image_bounds</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">image_bounds</span><span class="p">.</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">786432</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>每一个类元组结构体的元素都可以是公有的或者私有的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Bounds</span><span class="p">(</span><span class="k">pub</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="k">pub</span><span class="w"> </span><span class="kt">usize</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>表达式<code>Bounds(1024, 768)</code>看起来像一个函数调用，实际上它就是：定义这个类型也会隐式地定义一个同名函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">Bounds</span><span class="p">(</span><span class="n">elem0</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">elem1</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Bounds</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>在底层，命名字段结构体和类元组结构体非常相似。到底用哪一个取决于可读性、二义性和简洁性。如果你将频繁使用<code>.</code>运算符来获取值的组成部分，那么通过名称来标识字段会增强可读性，也更不容易写错。如果你通常用模式匹配来获取元素，那么类元组结构体可以漂亮地完成工作。</p>
<p>类元组结构体常用于 <em>新类型</em> ，这种结构体只有单个组件，可以用来获得更严格的类型检查。例如如果你在处理只有ASCII的文本，你可以定义一个这样的新类型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">struct</span> <span class="nc">Ascii</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>使用这种类型表示ASCII字符串比简单的传递<code>Vec&lt;u8&gt;</code>缓冲区好得多，还可以在注释中表明这个类型到底是什么含义。新类型可以帮助Rust捕获其他字节缓冲区被传给期望ASCII文本的函数的错误。我们将在”第22章”中给出一个使用新类型来实现高效的类型转换的例子。</p>
<h2 id="类单元结构体">类单元结构体</h2>
<p>第三种结构体有一点迷惑：它声明了一个没有任何元素的结构体类型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">struct</span> <span class="nc">Onesuch</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>一个这种类型的值不占用任何内存，类似于单元类型<code>()</code>。Rust不需要考虑怎么在内存中存储类单元结构体，也不需要生成操作它们的代码，因为它可以仅从其类型中得知它可能需要了解的有关值的所有信息。但从逻辑上讲，一个空的结构体和其他的有值的类型没有什么区别——或者更精确地说，一个这样的类型就是一个单独的值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">o</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Onesuch</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>当在“字段和元素”一节中介绍<code>..</code>运算符时，你已经遇到过一个类单元结构体了。表达式<code>3..5</code>是结构体值<code>Range { start: 3, end: 5 }</code>的缩写，而表达式<code>..</code>两端都省略的情况下，就是类单元结构体值<code>RangeFull</code>的缩写。</p>
<p>当和trait一起使用时，类单元结构体会变得很有用。我们将在”第11章”中介绍trait。</p>
<h2 id="结构体布局">结构体布局</h2>
<p>在内存中，命名字段结构体和类元组结构体是同样的东西：一些可能不同类型的值的集合，以一种特殊的方式分布在内存中。例如，我们之前在这一章中定义的这个结构体：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">struct</span> <span class="nc">GrayscaleMap</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">pixels</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">size</span>: <span class="p">(</span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>一个<code>GrayscaleMap</code>按照如”图9-1”的布局分布在内存中。</p>
<p><figure>
  <picture>

    
      
        
        
        
        
        
        
    <img
      loading="lazy"
      decoding="async"
      alt="一个&amp;lt;code&amp;gt;GrayscaleMap&amp;lt;/code&amp;gt;结构体的内存布局"
      
        class="image_figure image_internal image_unprocessed"
        src="../img/f9-1.png"
      
      
    />

    </picture>
</figure>
</p>
<p align="center">图9-1 一个<code>GrayscaleMap</code>结构体的内存布局</p>
<p>与C和C++不同，Rust对于如何在内存中布局结构体字段或元素没有任何确切的保证，这里的图只是展示了其中一种可能的排列。然而Rust确实保证了直接在结构体的内存块里存储字段的值。JavaScript、Python和Java将会把<code>pixels</code>和<code>size</code>值分别放在它们自己的堆上分配的内存块中，然后让<code>GrayscaleMap</code>的字段指向他们。而Rust会直接把<code>pixels</code>和<code>size</code>嵌入到<code>GrayscaleMap</code>值里。只有<code>pixels</code> vector持有的堆上分配的缓冲区保留着自己的块。</p>
<p>你可以使用<code>#[repr(C)]</code>属性来要求Rust用一种与C和C++兼容的方式布局结构体。我们将会在”第23章”中详细介绍这些。</p>
<h2 id="使用impl定义方法">使用<code>impl</code>定义方法</h2>
<p>在本书中，我们已经在很多类型的值上调用过方法。我们使用<code>v.push(e)</code>把元素添加进vector，使用<code>v.len()</code>获取它的长度，使用<code>r.expect(&quot;msg&quot;)</code>检查<code>Result</code>的值是否是错误值，等等。你可以为你自己的结构体类型定义方法。与C++或Java那种直接出现在结构体定义内部的方式不同，Rust的方法在一个单独的<code>impl</code>块中定义。</p>
<p>一个<code>impl</code>块就是一些<code>fn</code>定义的结合，每一个函数都将成为这个结构体的一个方法。例如，这里我们定义了一个公有的结构体<code>Queue</code>，然后为它定义了两个公有的方法：<code>push</code>和<code>pop</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="sd">/// 一个先进先出的字符队列
</span><span class="sd"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Queue</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">older</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">,</span><span class="w">   </span><span class="c1">// 旧的元素，越旧越靠后
</span><span class="c1"></span><span class="w">        </span><span class="n">younger</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="w">  </span><span class="c1">// 新的元素，越新越靠后
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="n">Queue</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="sd">/// 将一个字符添加到队列的尾部。
</span><span class="sd"></span><span class="w">        </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">push</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">c</span>: <span class="kt">char</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">younger</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">c</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="sd">/// 移出队列最前端的元素，如果有字符被移出就返回`Some(c)`，
</span><span class="sd"></span><span class="w">        </span><span class="sd">/// 否则如果队列为空就返回`None`。
</span><span class="sd"></span><span class="w">        </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">pop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">older</span><span class="p">.</span><span class="n">is_empty</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">younger</span><span class="p">.</span><span class="n">is_empty</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                    </span><span class="k">return</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span><span class="w">
</span><span class="w">                </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">                </span><span class="c1">// 将新的元素都移动到旧的元素里，
</span><span class="c1"></span><span class="w">                </span><span class="c1">// 并且反转顺序。
</span><span class="c1"></span><span class="w">                </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">mem</span>::<span class="n">swap</span><span class="p">;</span><span class="w">
</span><span class="w">                </span><span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">older</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">younger</span><span class="p">);</span><span class="w">
</span><span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">older</span><span class="p">.</span><span class="n">reverse</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">            </span><span class="c1">// 现在旧的元素保证不为空。Vec的pop方法
</span><span class="c1"></span><span class="w">            </span><span class="c1">// 已经返回了一个Option，因此不用再处理
</span><span class="c1"></span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">older</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>在 <em>impl</em> 块中定义的函数被称为 <em>关联函数</em> ，因为它们被关联到特定的类型。与之相反的是 <em>自由函数</em> ，也就是不在<code>impl</code>块中定义的函数。</p>
<p>Rust将调用方法的值作为第一个参数传给方法，它的参数名必须是<code>self</code>。因为<code>self</code>的类型很明显是<code>impl</code>块外面的结构体类型，或者是其引用，所以Rust允许你省略类型，用<code>self</code>、<code>&amp;self</code>、<code>&amp;mut self</code>分别作为<code>self: Queue</code>、<code>self: &amp;Queue</code>、<code>self: &amp;mut Queue</code>的缩写。如果你喜欢的话也可以使用非缩写的形式，但几乎所有的Rust代码都是用缩写形式。</p>
<p>在我们的示例中，<code>push</code>和<code>pop</code>方法中通过<code>self.older</code>和<code>self.younger</code>引用了<code>Queue</code>的字段。与C++或Java中“this”对象的成员直接在方法内可见不同，Rust方法中必须显式使用<code>self</code>来引用字段，这和Python方法中<code>self</code>的用法、JavaScript方法中<code>this</code>的用法类似。</p>
<p>因为<code>push</code>和<code>pop</code>需要修改<code>Queue</code>，所以它们都以<code>&amp;mut self</code>传参。然而，当你调用这两个方法时，你不需要手动借用可变引用，普通的方法调用语法会自动进行隐式转换。因此有了这些定义之后，你可以像这样使用<code>Queue</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Queue</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">older</span>: <span class="nb">Vec</span>::<span class="n">new</span><span class="p">(),</span><span class="w"> </span><span class="n">younger</span>: <span class="nb">Vec</span>::<span class="n">new</span><span class="p">()</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="sc">&#39;0&#39;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="sc">&#39;1&#39;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="sc">&#39;0&#39;</span><span class="p">));</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="sc">&#39;=&#39;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="sc">&#39;1&#39;</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="sc">&#39;=&#39;</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">(),</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>为了满足<code>push</code>方法的<code>self</code>参数要求，直接写<code>q.push(...)</code>会借用<code>q</code>的可变引用，就像你写了<code>(&amp;mut q).push(...)</code>一样。</p>
<p>如果一个方法不需要修改<code>self</code>，那么你可以以共享引用获取参数。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="n">Queue</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">is_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">older</span><span class="p">.</span><span class="n">is_empty</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">younger</span><span class="p">.</span><span class="n">is_empty</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>方法调用表达式知道要借用哪一种引用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="fm">assert!</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">is_empty</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="sc">&#39;☉&#39;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="fm">assert!</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">is_empty</span><span class="p">());</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>或者，如果一个方法想获取<code>self</code>的所有权，它可以以值传递<code>self</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="n">Queue</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">older</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">younger</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>调用这个<code>split</code>方法看起来和调用其他方法一样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Queue</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">older</span>: <span class="nb">Vec</span>::<span class="n">new</span><span class="p">(),</span><span class="w"> </span><span class="n">younger</span>: <span class="nb">Vec</span>::<span class="n">new</span><span class="p">()</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="sc">&#39;P&#39;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="sc">&#39;D&#39;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="sc">&#39;P&#39;</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="sc">&#39;X&#39;</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">older</span><span class="p">,</span><span class="w"> </span><span class="n">younger</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="p">.</span><span class="n">split</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="c1">// q现在是未初始化状态
</span><span class="c1"></span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">older</span><span class="p">,</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="sc">&#39;D&#39;</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">younger</span><span class="p">,</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="sc">&#39;X&#39;</span><span class="p">]);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>但是注意，因为<code>split</code>以值获取<code>self</code>，这会把<code>q</code>中的<code>Queue</code>值 <em>移动</em> 走，导致<code>q</code>变为未初始化。因为<code>split</code>的<code>self</code>现在拥有了这个队列，因此它可以把两个单独的vector移动出来并返回给调用者。</p>
<p>有时，像这样以值传递<code>self</code>，或者以引用传递都不能满足我们的需求，因此Rust还允许你通过智能指针类型传递<code>self</code>。</p>
<h3 id="以boxrcarc传递self">以<code>Box</code>、<code>Rc</code>、<code>Arc</code>传递<code>Self</code></h3>
<p>一个方法的<code>self</code>参数还可以是<code>Box&lt;Self&gt;</code>、<code>Rc&lt;Self&gt;</code>、<code>Arc&lt;Self&gt;</code>。这些方法只能在相应指针类型上调用。调用这些方法会传递指针的所有权。</p>
<p>你通常不需要这么做。一个以引用传递<code>self</code>的方法可以在任何智能指针类型上正常调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">bq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Queue</span>::<span class="n">new</span><span class="p">());</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// `Queue::push`接受一个`&amp;mut Queue`，但`bq`是`Box&lt;Queue&gt;`。
</span><span class="c1"></span><span class="w">    </span><span class="c1">// 这没有问题：Rust在调用期间从`Box`借用了一个`&amp;mut Queue`
</span><span class="c1"></span><span class="w">    </span><span class="n">bq</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="sc">&#39;■&#39;</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>对于方法调用和字段访问，Rust自动从智能指针类型例如<code>Box</code>、<code>Rc</code>和<code>Arc</code>借用一个引用，因此<code>&amp;self</code>和<code>&amp;mut self</code>通常总是正确的方法签名，再加上偶尔用到的<code>self</code>。</p>
<p>但如果这个方法的意图涉及管理指针的所有权呢？假设我们有一个像这样的节点组成的树，类似某种彻底简化的XML：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">rc</span>::<span class="n">Rc</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">struct</span> <span class="nc">Node</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">tag</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">children</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Rc</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;&gt;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="n">Node</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">tag</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Node</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Node</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="n">tag</span>: <span class="nc">tag</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w">
</span><span class="w">                </span><span class="n">children</span>: <span class="nc">vec</span><span class="o">!</span><span class="p">[],</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>每一个节点都有一个tag来指示它是什么类型的节点，还有一个子节点的vector通过引用计数指针来允许共享，并让生命周期变得更灵活。</p>
<p>通常我们会实现一个方法让它向自己的列表中添加一个子节点，但现在让我们把角色颠倒过来，给<code>Node</code>实现一个把它自己添加到别的<code>Node</code>的子节点中的方法。我们可以写：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="n">Node</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">parent</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Node</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">parent</span><span class="p">.</span><span class="n">children</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Rc</span>::<span class="n">new</span><span class="p">(</span><span class="bp">self</span><span class="p">));</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>但这个方法并不能让人满意。这个方法调用了<code>Rc::new</code>来分配新的堆空间并且把<code>self</code>移动进去，但如果调用者已经有了一个<code>Rc&lt;Node&gt;</code>，这些操作就都不是必须的：我们应该只递增引用计数然后把指针加到vector里。<code>Rc</code>的全部意义不就是实现共享吗？</p>
<p>我们可以这样写：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="n">Node</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">append_to</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">Rc</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">parent</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Node</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">parent</span><span class="p">.</span><span class="n">children</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="bp">self</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>如果调用者已经是<code>Rc&lt;Node&gt;</code>类型，那它可以直接调用<code>append_to</code>，以值传递<code>Rc</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">shared_node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">new</span><span class="p">(</span><span class="n">Node</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;first&#34;</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="n">shared_node</span><span class="p">.</span><span class="n">append_to</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">parent</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这会把<code>shared_node</code>的所有权传递给方法：引用计数不会发生变化，也不会有新的内存分配。</p>
<p>如果调用者需要保留节点的指针以便之后使用，它可以首先克隆<code>Rc</code>再调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="n">shared_node</span><span class="p">.</span><span class="n">clone</span><span class="p">().</span><span class="n">append_to</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">parent</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>克隆<code>Rc</code>只会递增引用计数，没有堆分配或者拷贝。但当调用返回时<code>shared_node</code>和<code>parent</code>的子节点的vector现在指向同一个<code>Node</code>。</p>
<p>最后，如果调用者现在拥有一个<code>Node</code>，那么它必须先创建一个<code>Rc</code>再调用方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">owned</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Node</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;owned directly&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">Rc</span>::<span class="n">new</span><span class="p">(</span><span class="n">owned</span><span class="p">).</span><span class="n">append_to</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">parent</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>把<code>append_to</code>方法的签名设为<code>Rc&lt;Self&gt;</code>可以让调用者知道<code>Node</code>的需求。然后调用者可以用最小化内存分配和引用计数调整的方式来调用：</p>
<ul>
<li>如果可以传递<code>Rc</code>的所有权，就直接在指针上调用。</li>
<li>如果需要保留<code>Rc</code>的所有权，就递增引用计数后再调用。</li>
<li>如果只拥有<code>Node</code>，那么必须先调用<code>Rc::new</code>来分配堆空间然后把<code>Node</code>移动进去。因为<code>parent</code>必须通过<code>Rc&lt;Node&gt;</code>指针引用它的子节点，所以这一步最终肯定是必须的。</li>
</ul>
<p>再重复一遍，对于大多数方法，<code>&amp;self</code>、<code>&amp;mut self</code>、和<code>self</code>（以值传参）就能满足你的需求。但如果一个方法的目的是影响值的所有权，使用其他指针类型的<code>self</code>可能是正确的选择。</p>
<h3 id="类型关联函数">类型关联函数</h3>
<p><code>impl</code>块里定义的函数也可以没有<code>self</code>参数。这些参数仍然和类型关联，因为它们也是在<code>impl</code>块中定义的。但它们不是方法，因为它们没有<code>self</code>参数。为了将它们和方法区别开来，我们称它们为 <em>类型关联函数</em> 。</p>
<p>它们通常用于提供构造函数，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="n">Queue</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Queue</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Queue</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">older</span>: <span class="nb">Vec</span>::<span class="n">new</span><span class="p">(),</span><span class="w"> </span><span class="n">younger</span>: <span class="nb">Vec</span>::<span class="n">new</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>为了使用这个函数，我们通过<code>Queue::new</code>来引用它：类型名+双冒号+函数名。现在我们的示例代码变得更加简洁：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Queue</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="sc">&#39;*&#39;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="o">..</span><span class="p">.</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>Rust的传统是构造函数都叫<code>new</code>，我们已经见过了<code>Vec::new</code>、<code>Box::new</code>、<code>HashMap::new</code>，等等。但<code>new</code>这个名字本身并没有什么特殊的地方。它并不是关键字，而且一个类型经常还有其他名字的关联函数作为构造函数，例如<code>Vec::with_capacity</code>。</p>
<p>尽管一个类型可以有很多个分开的<code>impl</code>块，但它们必须在定义类型的那个crate中。然而，Rust确实允许你将自己定义的方法附加到其他类型，我们将在”第11章”介绍怎么做到这一点。</p>
<p>如果你习惯写C++或Java，你可能会觉得将类型的方法和定义分离开来很奇怪，但这么做确实有以下优势：</p>
<ul>
<li>你总是能很容易的找到一个类型的数据成员。在很大的C++类定义中，你可能需要浏览几百行成员成员函数的定义来确保你没有遗漏数据成员。而在Rust中，所有数据成员都在一个地方。</li>
<li>尽管我们可以很容易想象把方法定义添加到命名字段结构体的定义中，但类元组结构体和类单元结构体却不是这样。将方法拿出来放在一个<code>impl</code>块中可以让这三种结构体共用唯一一种语法。事实上，Rust还使用这套语法为不是结构体的类型定义方法，例如<code>enum</code>结构体和基本类型例如<code>i32</code>。（任何类型都可以有方法的事实是Rust中不使用术语 <em>对象</em> ，而是更喜欢把一切称为 <em>值</em> 的原因之一。）</li>
<li>同样的<code>impl</code>语法还可以很容易地用于实现trait，我们将在”第11章”中介绍。</li>
</ul>
<h2 id="关联常量">关联常量</h2>
<p>Rust的类型系统还采用了C#和Java等语言中的一个特性，就是关联到类型而不是关联到类型实例的值。在Rust中，它们被称为 <em>关联常量</em> 。</p>
<p>正如它的名字一样，关联常量是常量值。它们通常用来表示某一个类型中使用最广泛的值。例如，你可以定义一个二维的向量用于线性代数，并为它定义一个关联的单位向量：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Vector2</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">x</span>: <span class="kt">f32</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">y</span>: <span class="kt">f32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="n">Vector2</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">ZERO</span>: <span class="nc">Vector2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Vector2</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mf">0.0</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">UNIT</span>: <span class="nc">Vector2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Vector2</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mf">0.0</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这些值被关联到类型本身，你可以在不创建<code>Vector2</code>的实例的情况下使用它们。和类型关联方法一样，引用它们的方法是类型的名称再加上它们的名称：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">scaled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Vector2</span>::<span class="n">UNIT</span><span class="p">.</span><span class="n">scaled_by</span><span class="p">(</span><span class="mf">2.0</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>关联常量的类型并不一定必须是它关联的类型，我们可以使用这个特性来给类型添加ID或者名称。例如，如果有几个和<code>Vector2</code>很像的类型需要写入到文件里，然后加载到内存中，那么关联常量可以为写入的数据添加名称或数字ID，这样之后可以据此辨识出类型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="n">Vector2</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">NAME</span>: <span class="kp">&amp;</span><span class="o">&#39;</span><span class="nb">static</span> <span class="kt">str</span> <span class="o">=</span><span class="w"> </span><span class="s">&#34;Vector2&#34;</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">ID</span>: <span class="kt">u32</span> <span class="o">=</span><span class="w"> </span><span class="mi">18</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h2 id="泛型结构体">泛型结构体</h2>
<p>我们之前的<code>Queue</code>定义并不能令人满意：它被用来存储字符，但它却没有任何和字符相关的方法。如果我们要定义另一个存储<code>String</code>值的结构体，那么除了<code>char</code>要换成<code>String</code>之外，剩下的代码完全相同。重复定义将会浪费时间。</p>
<p>幸运的是，Rust的结构体可以是 <em>泛型</em> 的，这意味着它们的定义只是一个模板，你可以把任何类型塞进去。例如，这里有一个可以存储任何类型的值的<code>Queue</code>的定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Queue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">older</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">younger</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>你可以将<code>Queue&lt;T&gt;</code>中的<code>&lt;T&gt;</code>读作“对于任意类型<code>T</code>”。因此这个定义读作“对于任意类型<code>T</code>，一个<code>Queue&lt;T&gt;</code>有两个<code>Vec&lt;T&gt;</code>类型的字段。”例如，在<code>Queue&lt;String&gt;</code>中，<code>T</code>是<code>String</code>，所以<code>older</code>和<code>younger</code>的类型都是<code>Vec&lt;String&gt;</code>。在<code>Queue&lt;char&gt;</code>中<code>T</code>是<code>char</code>，我们就得到了一个和一开始的<code>char</code>类型特定的定义完全相同的结构体。事实上，<code>Vec</code>本身就是一个用这种方式定义的泛型结构体。</p>
<p>在泛型结构体的定义中，&lt;尖括号&gt;里的类型名被称为 <em>类型参数</em> 。一个泛型结构体的<code>impl</code>块看起来像这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Queue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Queue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Queue</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">older</span>: <span class="nb">Vec</span>::<span class="n">new</span><span class="p">(),</span><span class="w"> </span><span class="n">younger</span>: <span class="nb">Vec</span>::<span class="n">new</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">push</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">younger</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">is_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">older</span><span class="p">.</span><span class="n">is_empty</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">younger</span><span class="p">.</span><span class="n">is_empty</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>你可以将<code>impl&lt;T&gt; Queue&lt;T&gt;</code>这一行读作“对于任意类型<code>T</code>，有一些<code>Queue&lt;T&gt;</code>可用的关联方法”。然后，你可以在关联函数的定义中将类型参数<code>T</code>用作一个类型。</p>
<p>这种语法看起来好像有些重复，但<code>impl&lt;T&gt;</code>能更清晰地表达出<code>impl</code>块覆盖了任意的类型<code>T</code>，这能将它和为特定种类的<code>Queue</code>编写的<code>impl</code>块区分开来，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="n">Queue</span><span class="o">&lt;</span><span class="kt">f64</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">sum</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">f64</span> <span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这个<code>impl</code>块头读作“这里有一些<code>Queue&lt;f64&gt;</code>特定的关联方法”。这样就给<code>Queue&lt;f64&gt;</code>添加了一个<code>sum</code>方法，而其它种类的<code>Queue</code>并没有这个方法。</p>
<p>我们已经在之前的代码中使用过Rust的<code>self</code>参数的缩写形式。这里<code>Queue&lt;T&gt;</code>如果写出类型显得有些啰嗦。作为另一种缩写，每一个<code>impl</code>块，不管是不是泛型的，都定义了特殊的类型参数<code>Self</code>（注意<code>大驼峰</code>风格的名称）来表示我们要添加方法的类型。在之前的代码中，<code>Self</code>将是<code>Queue&lt;T&gt;</code>，因此我们可以进一步简化<code>Queue::new</code>的定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Queue</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">older</span>: <span class="nb">Vec</span>::<span class="n">new</span><span class="p">(),</span><span class="w"> </span><span class="n">younger</span>: <span class="nb">Vec</span>::<span class="n">new</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>你可能已经注意到了，在<code>new</code>的函数体内，我们不需要在构造表达式中写出类型参数，简单地写<code>Queue { ... }</code>就足够了。这是因为Rust的类型推导发挥了作用：因为函数的返回值类型只能有一种可能，就是<code>Queue&lt;T&gt;</code>，所以Rust会自动为我们提供参数。然而，你必须总是在函数签名和类型定义中指明类型参数。Rust不会推断它们，相反，它将这些已知的类型作为基础来推断那些函数体内的类型。</p>
<p><code>Self</code>也可以用于这种方式：我们可以写<code>Self { ... }</code>。你觉得哪种形式更容易理解就可以用哪种。</p>
<p>对于关联函数的调用，你可以显式地使用<code>::&lt;&gt;(涡轮鱼)</code>注解来提供类型参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Queue</span>::<span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>但在实践中，通常可以让Rust自动帮你推断类型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Queue</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Queue</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="s">&#34;CAD&#34;</span><span class="p">);</span><span class="w">      </span><span class="c1">// 显然是Queue&lt;&amp;&#39;static str&gt;
</span><span class="c1"></span><span class="w">    </span><span class="n">r</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mf">0.74</span><span class="p">);</span><span class="w">       </span><span class="c1">// 显然是Queue&lt;f64&gt;
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="s">&#34;BTC&#34;</span><span class="p">);</span><span class="w">      </span><span class="c1">// 比特币/USD，2019年6月 
</span><span class="c1"></span><span class="w">    </span><span class="n">r</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mf">13764.0</span><span class="p">);</span><span class="w">    
</span></code></pre></td></tr></table>
</div>
</div><p>事实上，这正是整本书中我们使用<code>Vec</code>的方式。</p>
<p>并不只有结构体可以是泛型的。枚举也可以有类型参数，语法也非常的相似。我们将在“枚举”一节中详细介绍。</p>
<h2 id="有生命周期参数的结构体">有生命周期参数的结构体</h2>
<p>正如我们在“包含引用的结构体”一节中讨论过的一样，如果一个结构体类型中包含引用，你必须指明那些引用的生命周期。例如，这里有一个存储切片中最大和最小元素的引用的结构体：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">struct</span> <span class="nc">Extrema</span><span class="o">&lt;&#39;</span><span class="na">elt</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">greatest</span>: <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">elt</span> <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">least</span>: <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">elt</span> <span class="kt">i32</span>
    <span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>之前，我们建议你将类似<code>struct Queue&lt;T&gt;</code>的声明看作是对于任意类型<code>T</code>，你都可以构建一个<code>Queue&lt;T&gt;</code>来存储该类型。类似的，你可以将<code>struct Extrema&lt;'elt&gt;</code>看作对于任意生命周期<code>'elt</code>，你都可以构建一个<code>Extrema&lt;'elt&gt;</code>来存储生命周期为<code>'elt</code>的引用。</p>
<p>这里有一个函数来扫描一个切片并返回一个指向其中元素的<code>Extrema</code>值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">find_extrema</span><span class="o">&lt;&#39;</span><span class="na">s</span><span class="o">&gt;</span><span class="p">(</span><span class="n">slice</span>: <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">s</span> <span class="p">[</span><span class="kt">i32</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">Extrema</span><span class="o">&lt;&#39;</span><span class="na">s</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">greatest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">slice</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">least</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">slice</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="n">slice</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">slice</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">least</span><span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="n">least</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">slice</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">slice</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">greatest</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">greatest</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">slice</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="n">Extrema</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">greatest</span><span class="p">,</span><span class="w"> </span><span class="n">least</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这里，<code>find_extrema</code>借用了<code>slice</code>的元素。因为<code>slice</code>的生命周期是<code>'s</code>，所以我们返回的<code>Extrema</code>结构体中的引用的生命周期也是<code>'s</code>。Rust总是会为调用推断生命周期参数，因此调用<code>find_extrema</code>并不需要提到它们：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="p">,</span><span class="w"> </span><span class="mi">48</span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find_extrema</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">.</span><span class="n">least</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">.</span><span class="n">greatest</span><span class="p">,</span><span class="w"> </span><span class="mi">48</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>因为返回值和参数使用相同的生命周期非常常见，所以当只有一种可能时Rust允许我们省略生命周期。我们还可以在不改变含义的情况下将<code>find_extrema</code>的签名写成这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">find_extrema</span><span class="p">(</span><span class="n">slice</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">i32</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">Extrema</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>诚然，我们也 <em>可能</em> 是想返回<code>Extrema&lt;'static&gt;</code>，但这并不是通常的情况。Rust只为通常的情况提供了一个缩写。</p>
<h2 id="为结构体类型派生常见的trait">为结构体类型派生常见的trait</h2>
<p>可以非常简单地定义一个结构体：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">x</span>: <span class="kt">f64</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">y</span>: <span class="kt">f64</span>
    <span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>然而，如果你真的开始使用这个<code>Point</code>类型，你将很快发现它使用起来很痛苦。按照上面的写法，<code>Point</code>既不能拷贝也不能克隆。你不能用<code>println!(&quot;{:?}&quot;, point);</code>打印它，它也不支持<code>==</code>和<code>!=</code>运算符。</p>
<p>在Rust中这些特性都有一个名字——<code>Copy</code>、<code>Clone</code>、<code>Debug</code>、<code>PartialEq</code>。它们被称为 <em>trait</em> 。在”第11章”中，我们将展示如何为你自己的结构体手动实现trait。但这个例子中出现的标准trait，以及其它一些trait，你不需要手动实现它们，除非你想要一些自定义行为。Rust可以自动为你实现它们。只需要为结构体添加<code>#[derive]</code>属性：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="cp">#[derive(Copy, Clone, Debug, PartialEq)]</span><span class="w">
</span><span class="w">    </span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">x</span>: <span class="kt">f64</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">y</span>: <span class="kt">f64</span>
    <span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这些trait中的任何一个都可以自动实现，前提是这个结构体的所有字段都实现了那个trait。我们可以要求Rust为<code>Point</code>派生<code>PartialEq</code>，是因为它的两个字段都是<code>f64</code>类型，这个类型已经实现了<code>PartialEq</code>。</p>
<p>Rust还可以派生<code>PartialOrd</code>，它可以支持比较运算符<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>和<code>&gt;=</code>。我们没有这么做，是因为比较两个点来判断其中一个是否“小于”另一个是一件很奇怪的事。因此我们选择让<code>Point</code>值不支持那些比较运算符。像这样的情况也是Rust让我们自己写<code>#[derive]</code>属性而不是直接自动派生所有可用的trait的原因之一。另一个原因是实现一个trait将自动变为公有的特性。因此可复制性、可克隆性等都将是结构体公共API的一部分，应该慎重选择。</p>
<p>我们将在”第13章”详细介绍Rust的标准trait并解释哪些可以用<code>#[derive]</code>自动实现。</p>
<h2 id="内部可变性">内部可变性</h2>
<p>可变性和其他东西一样：如果限制太过宽松就会导致问题，但你又总是希望它能放宽一点。例如，假设你的蜘蛛机器人控制系统是一个中心化的结构体<code>SpiderRobot</code>，这个结构体里包含设置和I/O处理。当机器人启动时它的值就被初始化，并且永远不会改变：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">SpiderRobot</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">species</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">web_enabled</span>: <span class="kt">bool</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">leg_devices</span>: <span class="p">[</span><span class="n">fd</span>::<span class="n">FileDesc</span><span class="p">;</span><span class="w"> </span><span class="mi">8</span><span class="p">],</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>机器人的每一个主要系统都由一个不同的结构体处理，这些结构体都有一个指向那个<code>SpiderRobot</code>值的指针：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">rc</span>::<span class="n">Rc</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">SpiderSenses</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">robot</span>: <span class="nc">Rc</span><span class="o">&lt;</span><span class="n">SpiderRobot</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="c1">// &lt;-- 指向设置和I/O的指针
</span><span class="c1"></span><span class="w">        </span><span class="n">eyes</span>: <span class="p">[</span><span class="n">Camera</span><span class="p">;</span><span class="w"> </span><span class="mi">32</span><span class="p">],</span><span class="w">
</span><span class="w">        </span><span class="n">motion</span>: <span class="nc">Accelerometer</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>控制织网、捕食、毒液流动等的结构体都有一个<code>Rc&lt;SpiderRobot&gt;</code>智能指针。回顾一下，<code>Rc</code>代表”引用计数”,、<code>Rc</code>中的值总是共享的因此总是不可变的。</p>
<p>现在假设你想使用标准的<code>File</code>类型给<code>SpiderRobot</code>结构体添加一点日志功能。那么就会有一个问题：<code>File</code>值必须是<code>mut</code>的。所有写入它的函数都需要<code>mut</code>引用。</p>
<p>这种情况经常出现。我们需要的是一个不可变(<code>SpiderRobot</code>结构体)的值内有一小部分数据可变(一个<code>File</code>)。这被称为 <em>内部可变性</em> 。Rust为此提供了几种方式，这一节中我们将讨论最直观的两种类型：
<code>Cell&lt;T&gt;</code>和<code>RefCell&lt;T&gt;</code>，这两个类型都在<code>std::cell</code>模块中。</p>
<p><code>Cell&lt;T&gt;</code>结构体只包含单个私有的类型<code>T</code>的值。<code>Cell</code>唯一特殊的地方是即使你没有对<code>Cell</code>自身的<code>mut</code>访问权限，也可以访问和修改它里面的字段值：</p>
<p><em><code>Cell:new(value)</code></em></p>
<p>  创建一个新的<code>Cell</code>，将给定的<code>value</code>移动进去。</p>
<p><em><code>cell.get()</code></em></p>
<p>  返回一个<code>cell</code>中值的拷贝</p>
<p><em><code>cell.set(value)</code></em></p>
<p>  将给定的值<code>value</code>存储在<code>cell</code>中，丢弃掉之前存储的值。这个方法以非<code>mut</code>引用获取<code>self</code>参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">set</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">value</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="c1">// 注意：不是`&amp;mut self`
</span></code></pre></td></tr></table>
</div>
</div><p>  显然，这和普通的<code>set</code>方法不同。到目前为止，Rust告诉我们如果想要修改数据就需要<code>mut</code>访问权限。但同样的道理，这一处不同的细节就是<code>Cell</code>全部的精髓。它们是一种安全地扭曲不可变性规则的方式——既不多、也不少。</p>
<p><code>Cell</code>还可以有一些其他的方法，你可以在<a href="https://doc.rust-lang.org/std/cell/struct.Cell.html">它的文档</a>中查阅。</p>
<p>如果你想给你的<code>SpiderRobot</code>添加一个简单的计数器，那么使用<code>Cell</code>将会很方便。你可以写：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">cell</span>::<span class="n">Cell</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">SpiderRobot</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">        </span><span class="n">hardware_error_count</span>: <span class="nc">Cell</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>即使是<code>SpiderRobot</code>的非<code>mut</code>方法也可以使用<code>.get()</code>和<code>.set()</code>来访问<code>u32</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="n">SpiderRobot</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="sd">/// 错误计数加一
</span><span class="sd"></span><span class="w">        </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">add_hardware_error</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">hardware_error_count</span><span class="p">.</span><span class="n">get</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">hardware_error_count</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="sd">/// 如果有硬件错误的话返回真
</span><span class="sd"></span><span class="w">        </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">has_hardware_errors</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">hardware_error_count</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这非常简单，但并不能解决我们的日志问题。<code>Cell</code> <em>不能</em> 让你调用内含值的<code>mut</code>方法，因为<code>.get()</code>方法返回的是单元里值的拷贝，所以它只能用于实现了”<code>Copy</code> trait”的类型。为了实现日志功能，我们需要一个可变的<code>File</code>，而”<code>File</code>”不可拷贝。</p>
<p>这个例子中正确的工具是<code>RefCell</code>。类似于<code>Cell&lt;T&gt;</code>，<code>RefCell&lt;T&gt;</code>也是一个包含单个<code>T</code>类型的值的泛型类型。和<code>Cell</code>不同的是，<code>RefCell</code>支持借用内部的<code>T</code>类型的值：</p>
<p><em><code>RefCell::new(value)</code></em></p>
<p>  创建一个新的<code>RefCell</code>，把<code>value</code>移动进去。</p>
<p><em><code>ref_cell.borrow()</code></em></p>
<p>  返回一个<code>Ref&lt;T&gt;</code>，它本质上是<code>ref_cell</code>里存储的值的一个共享引用。</p>
<p>  如果里面的值已经有可变借用了，这个方法会panic。</p>
<p><em><code>ref_cell.borrow_mut()</code></em></p>
<p>  返回一个<code>RefMut&lt;T&gt;</code>，它本质上是<code>ref_cell</code>里存储的值的一个可变引用。</p>
<p>  如果里面的值已经被借用了，这个方法会panic。</p>
<p><em><code>ref_cell.try_borrow(), ref_cell.try_borrow_mut()</code></em></p>
<p>  与<code>borrow()</code>和<code>borrow_mut()</code>的功能一样，但返回一个<code>Result</code>。当值已经有可变借用/被借用时，它们不panic，而是返回一个<code>Err</code>值。</p>
<p>同样的，<code>RefCell</code>还有一些其它方法，你可以在<a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html">它的文档</a>中查阅。</p>
<p>只有当你尝试打破Rust中<code>mut</code>引用必须是独占引用的规则时这两个方法才会panic。例如，这样将会panic：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">cell</span>::<span class="n">RefCell</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ref_cell</span>: <span class="nc">RefCell</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RefCell</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">());</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ref_cell</span><span class="p">.</span><span class="n">borrow</span><span class="p">();</span><span class="w">  </span><span class="c1">// ok，返回一个Ref&lt;String&gt;
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">len</span><span class="p">();</span><span class="w">        </span><span class="c1">// ok, 返回&#34;hello&#34;.len()
</span><span class="c1"></span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w">       
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ref_cell</span><span class="p">.</span><span class="n">borrow_mut</span><span class="p">();</span><span class="w"> </span><span class="c1">// panic：已经被借用了
</span><span class="c1"></span><span class="w">    </span><span class="n">w</span><span class="p">.</span><span class="n">push_str</span><span class="p">(</span><span class="s">&#34; world&#34;</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>为了避免panic，你可以把这两个借用放进单独的块里。这样的话，<code>r</code>会在你尝试借用<code>w</code>之前被drop。</p>
<p>这和普通引用的工作方式很像。唯一的不同在于普通的情况下，当你尝试借用一个变量的引用，Rust会在 <em>编译期</em> 确保你必须安全地使用引用。如果检查失败了，你会得到一个编译期错误。<code>RefCell</code>使用运行时检查来执行同样的规则。如果你尝试打破规则，你会得到一个panic（或者使用<code>try_borrow</code>和<code>try_borrow_mut</code>时会得到一个<code>Err</code>）。</p>
<p>现在我们已经准备好用<code>RefCell</code>来完善我们的<code>SpiderRobot</code>了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">SpiderRobot</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">        </span><span class="n">log_file</span>: <span class="nc">RefCell</span><span class="o">&lt;</span><span class="n">File</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="n">SpiderRobot</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="sd">/// 向日志文件中写入一行。
</span><span class="sd"></span><span class="w">        </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">log</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">message</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">log_file</span><span class="p">.</span><span class="n">borrow_mut</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="c1">// `writeln!`和`println!`很像，
</span><span class="c1"></span><span class="w">            </span><span class="c1">// 但会把字符串写入到给定的文件中。
</span><span class="c1"></span><span class="w">            </span><span class="fm">writeln!</span><span class="p">(</span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">message</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>变量<code>file</code>的类型是<code>RefMut&lt;File&gt;</code>。它的使用方式就像<code>File</code>的可变引用一样。有关写入文件的细节，见”第18章”。</p>
<p>Cell很容易使用。虽然必须调用<code>.get()</code>和<code>.set()</code>或者<code>.borrow()</code>和<code>.borrow_mut()</code>有点麻烦，但那只是我们扭曲可变性规则的代价。还有一些不是很明显但却更严重的问题：Cell——和任何包含了它们的类型——都不是线程安全的。因此Rust”不允许”多个线程直接访问它们。我们将在”第19章”中讨论到“<code>Mutex&lt;T&gt;</code>”、“原子量”和“全局变量”时介绍多线程中的内部可变性。</p>
<p>不管一个结构体有命名字段还是类元组结构体，它都是一些其他值的聚合体：如果我有一个<code>SpiderSenses</code>结构体，那么我就有一个指向共享的<code>SpiderRobot</code>结构体的<code>Rc</code>指针、同时还有了eyes、accelerometer等等。因此结构体的本质是单词“和(and)”：我有一个X <em>和(and)</em> 一个Y。但是否有另一种类型用于单词“或(or)”呢？换句话说，当你有了一个这种类型的值时，你有了一个X <em>或(or)</em> 一个Y？这样的类型太有用了以至于它们在Rust中无处不在，它们就是我们下一章要讨论的主题。</p>

    </div>
<div class="post_comments">
  
  
  
</div>




    <hr>

<div id="gitalk-container"></div>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js" crossorigin="anonymous"></script>
    <script type="text/javascript">
      var gitalk = new Gitalk({
        id: '0001-01-01 00:00:00 \u002b0000 UTC',
        title: '',
        clientID: '72786bf87c19beec6abe',
        clientSecret: '93ce647699b49ea6434332d36b0122a4ad8281ad',
        repo: 'buf1024.github.io',
        owner: 'buf1024',
        admin: ['buf1024'],
        body: decodeURI(location.href)
      });
      gitalk.render('gitalk-container');
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/gitalk/gitalk">comments powered by gitalk.</a></noscript>

  </article>
<aside class="sidebar">
  <section class="sidebar_inner">
    <br>
    


    
    
    <h2 class="mt-4">最新文章</h2>
    <ul class="flex-column">
      <li>
        <a href="https://luoguochun.cn/post/2024-01-13-rust-sqlx-sqlbuilder/" class="nav-link" title="Rust sqlx SQLBuilder">Rust sqlx SQLBuilder</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2024-01-08-vite-engineering-config/" class="nav-link" title="前端工程化配置保姆级教程">前端工程化配置保姆级教程</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-12-26-rust-proc-macro/" class="nav-link" title="rust 过程宏">rust 过程宏</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-09-21-rust-panic/" class="nav-link" title="一行代码让 rustc panic">一行代码让 rustc panic</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-07-19-flutter-muti-window/" class="nav-link" title="Flutter 桌面端多窗口支持">Flutter 桌面端多窗口支持</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-07-04-hiqradio/" class="nav-link" title="hiqradio 一个简单的收音机软件">hiqradio 一个简单的收音机软件</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-03-21-android-https/" class="nav-link" title="android https 抓包">android https 抓包</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-03-16-love-for-insterest/" class="nav-link" title="为爱发电终是不能长久的……">为爱发电终是不能长久的……</a>
      </li>
    </ul>
    <div>
      <h2 class="mt-4 taxonomy" id="categories-section">分类</h2>
      <nav class="tags_nav">
        <a href='https://luoguochun.cn/categories/misc/' class="post_tag button button_translucent" title="misc">
          MISC
          <span class="button_tally">11</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/linux/' class="post_tag button button_translucent" title="linux">
          LINUX
          <span class="button_tally">8</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/tcp/' class="post_tag button button_translucent" title="tcp">
          TCP
          <span class="button_tally">8</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/c/' class="post_tag button button_translucent" title="c">
          C
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/flutter/' class="post_tag button button_translucent" title="flutter">
          FLUTTER
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/rust/' class="post_tag button button_translucent" title="rust">
          RUST
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/python/' class="post_tag button button_translucent" title="python">
          PYTHON
          <span class="button_tally">6</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/c&#43;&#43;/' class="post_tag button button_translucent" title="c&#43;&#43;">
          C&#43;&#43;
          <span class="button_tally">4</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/web/' class="post_tag button button_translucent" title="web">
          WEB
          <span class="button_tally">4</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/gcc/' class="post_tag button button_translucent" title="gcc">
          GCC
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/git/' class="post_tag button button_translucent" title="git">
          GIT
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/reactjs/' class="post_tag button button_translucent" title="reactjs">
          REACTJS
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/unittest/' class="post_tag button button_translucent" title="unittest">
          UNITTEST
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/vim/' class="post_tag button button_translucent" title="vim">
          VIM
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/%E6%9E%84%E6%9E%B6/' class="post_tag button button_translucent" title="构架">
          构架
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/asm/' class="post_tag button button_translucent" title="asm">
          ASM
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/docker/' class="post_tag button button_translucent" title="docker">
          DOCKER
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/go/' class="post_tag button button_translucent" title="go">
          GO
          <span class="button_tally">1</span>
        </a>
        
        
      </nav>
    </div>
    <div>
      <h2 class="mt-4 taxonomy" id="tags-section">标签</h2>
      <nav class="tags_nav">
        <a href='https://luoguochun.cn/tags/c/' class="post_tag button button_translucent" title="c">
          C
          <span class="button_tally">21</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/linux/' class="post_tag button button_translucent" title="linux">
          LINUX
          <span class="button_tally">16</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/c&#43;&#43;/' class="post_tag button button_translucent" title="c&#43;&#43;">
          C&#43;&#43;
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/python/' class="post_tag button button_translucent" title="python">
          PYTHON
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/tcp/' class="post_tag button button_translucent" title="tcp">
          TCP
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/dart/' class="post_tag button button_translucent" title="dart">
          DART
          <span class="button_tally">6</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/flutter/' class="post_tag button button_translucent" title="flutter">
          FLUTTER
          <span class="button_tally">6</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/rust/' class="post_tag button button_translucent" title="rust">
          RUST
          <span class="button_tally">4</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/tdd/' class="post_tag button button_translucent" title="tdd">
          TDD
          <span class="button_tally">4</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/android/' class="post_tag button button_translucent" title="android">
          ANDROID
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/git/' class="post_tag button button_translucent" title="git">
          GIT
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/gtest/' class="post_tag button button_translucent" title="gtest">
          GTEST
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/js/' class="post_tag button button_translucent" title="js">
          JS
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/rust-lib/' class="post_tag button button_translucent" title="rust-lib">
          RUST-LIB
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/vcs/' class="post_tag button button_translucent" title="vcs">
          VCS
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/vim/' class="post_tag button button_translucent" title="vim">
          VIM
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/asm/' class="post_tag button button_translucent" title="asm">
          ASM
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/css/' class="post_tag button button_translucent" title="css">
          CSS
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/gas/' class="post_tag button button_translucent" title="gas">
          GAS
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/gcc/' class="post_tag button button_translucent" title="gcc">
          GCC
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/http/' class="post_tag button button_translucent" title="http">
          HTTP
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/libevent/' class="post_tag button button_translucent" title="libevent">
          LIBEVENT
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/macos/' class="post_tag button button_translucent" title="macos">
          MACOS
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/react-native/' class="post_tag button button_translucent" title="react-native">
          REACT-NATIVE
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/redis/' class="post_tag button button_translucent" title="redis">
          REDIS
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/%E6%9E%84%E6%9E%B6/' class="post_tag button button_translucent" title="构架">
          构架
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/api/' class="post_tag button button_translucent" title="api">
          API
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/bt/' class="post_tag button button_translucent" title="bt">
          BT
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/c&#43;/' class="post_tag button button_translucent" title="c&#43;">
          C&#43;
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/coroutine/' class="post_tag button button_translucent" title="coroutine">
          COROUTINE
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/database/' class="post_tag button button_translucent" title="database">
          DATABASE
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/docker/' class="post_tag button button_translucent" title="docker">
          DOCKER
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/endian/' class="post_tag button button_translucent" title="endian">
          ENDIAN
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/frontend/' class="post_tag button button_translucent" title="frontend">
          FRONTEND
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/gdb/' class="post_tag button button_translucent" title="gdb">
          GDB
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/go/' class="post_tag button button_translucent" title="go">
          GO
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/html/' class="post_tag button button_translucent" title="html">
          HTML
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/https/' class="post_tag button button_translucent" title="https">
          HTTPS
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/jquery/' class="post_tag button button_translucent" title="jquery">
          JQUERY
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/ld/' class="post_tag button button_translucent" title="ld">
          LD
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/logger/' class="post_tag button button_translucent" title="logger">
          LOGGER
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/makefile/' class="post_tag button button_translucent" title="makefile">
          MAKEFILE
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/misc/' class="post_tag button button_translucent" title="misc">
          MISC
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/orm/' class="post_tag button button_translucent" title="orm">
          ORM
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/os/' class="post_tag button button_translucent" title="os">
          OS
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/process/' class="post_tag button button_translucent" title="process">
          PROCESS
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/react/' class="post_tag button button_translucent" title="react">
          REACT
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/rpm/' class="post_tag button button_translucent" title="rpm">
          RPM
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/rsa/' class="post_tag button button_translucent" title="rsa">
          RSA
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/server/' class="post_tag button button_translucent" title="server">
          SERVER
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/sqlalchemy/' class="post_tag button button_translucent" title="sqlalchemy">
          SQLALCHEMY
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/ssh/' class="post_tag button button_translucent" title="ssh">
          SSH
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/ssl/tls/' class="post_tag button button_translucent" title="ssl/tls">
          SSL/TLS
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/vc/' class="post_tag button button_translucent" title="vc">
          VC
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/vite/' class="post_tag button button_translucent" title="vite">
          VITE
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/vue/' class="post_tag button button_translucent" title="vue">
          VUE
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/webui/' class="post_tag button button_translucent" title="webui">
          WEBUI
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/wechat/' class="post_tag button button_translucent" title="wechat">
          WECHAT
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/win32/' class="post_tag button button_translucent" title="win32">
          WIN32
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/windows/' class="post_tag button button_translucent" title="windows">
          WINDOWS
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/wireshark/' class="post_tag button button_translucent" title="wireshark">
          WIRESHARK
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/' class="post_tag button button_translucent" title="微服务">
          微服务
          <span class="button_tally">1</span>
        </a>
        
        
      </nav>
    </div>
  </section>
</aside>

  
</div>
  </main><svg width="0" height="0" class="hidden">
  <symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="facebook">
    <path d="M437 0H75C33.648 0 0 33.648 0 75v362c0 41.352 33.648 75 75 75h151V331h-60v-90h60v-61c0-49.629 40.371-90 90-90h91v90h-91v61h91l-15 90h-76v181h121c41.352 0 75-33.648 75-75V75c0-41.352-33.648-75-75-75zm0 0"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18.001 18.001" id="twitter">
    <path d="M15.891 4.013c.808-.496 1.343-1.173 1.605-2.034a8.68 8.68 0 0 1-2.351.861c-.703-.756-1.593-1.14-2.66-1.14-1.043 0-1.924.366-2.643 1.078a3.56 3.56 0 0 0-1.076 2.605c0 .309.039.585.117.819-3.076-.105-5.622-1.381-7.628-3.837-.34.601-.51 1.213-.51 1.846 0 1.301.549 2.332 1.645 3.089-.625-.053-1.176-.211-1.645-.47 0 .929.273 1.705.82 2.388a3.623 3.623 0 0 0 2.115 1.291c-.312.08-.641.118-.979.118-.312 0-.533-.026-.664-.083.23.757.664 1.371 1.291 1.841a3.652 3.652 0 0 0 2.152.743C4.148 14.173 2.625 14.69.902 14.69c-.422 0-.721-.006-.902-.038 1.697 1.102 3.586 1.649 5.676 1.649 2.139 0 4.029-.542 5.674-1.626 1.645-1.078 2.859-2.408 3.639-3.974a10.77 10.77 0 0 0 1.172-4.892v-.468a7.788 7.788 0 0 0 1.84-1.921 8.142 8.142 0 0 1-2.11.593z"
      ></path>
  </symbol>
  <symbol aria-hidden="true" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="mail">
    <path  d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="calendar">
    <path d="M452 40h-24V0h-40v40H124V0H84v40H60C26.916 40 0 66.916 0 100v352c0 33.084 26.916 60 60 60h392c33.084 0 60-26.916 60-60V100c0-33.084-26.916-60-60-60zm20 412c0 11.028-8.972 20-20 20H60c-11.028 0-20-8.972-20-20V188h432v264zm0-304H40v-48c0-11.028 8.972-20 20-20h24v40h40V80h264v40h40V80h24c11.028 0 20 8.972 20 20v48z"></path>
    <path d="M76 230h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zM76 310h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zM76 390h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zm80-80h40v40h-40z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="github">
    <path d="M255.968 5.329C114.624 5.329 0 120.401 0 262.353c0 113.536 73.344 209.856 175.104 243.872 12.8 2.368 17.472-5.568 17.472-12.384 0-6.112-.224-22.272-.352-43.712-71.2 15.52-86.24-34.464-86.24-34.464-11.616-29.696-28.416-37.6-28.416-37.6-23.264-15.936 1.728-15.616 1.728-15.616 25.696 1.824 39.2 26.496 39.2 26.496 22.848 39.264 59.936 27.936 74.528 21.344 2.304-16.608 8.928-27.936 16.256-34.368-56.832-6.496-116.608-28.544-116.608-127.008 0-28.064 9.984-51.008 26.368-68.992-2.656-6.496-11.424-32.64 2.496-68 0 0 21.504-6.912 70.4 26.336 20.416-5.696 42.304-8.544 64.096-8.64 21.728.128 43.648 2.944 64.096 8.672 48.864-33.248 70.336-26.336 70.336-26.336 13.952 35.392 5.184 61.504 2.56 68 16.416 17.984 26.304 40.928 26.304 68.992 0 98.72-59.84 120.448-116.864 126.816 9.184 7.936 17.376 23.616 17.376 47.584 0 34.368-.32 62.08-.32 70.496 0 6.88 4.608 14.88 17.6 12.352C438.72 472.145 512 375.857 512 262.353 512 120.401 397.376 5.329 255.968 5.329z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 212 212" id="gitlab">
    <path d="M12.3 74.7h54L43.3 3c-1-3.6-6.4-3.6-7.6 0L12.3 74.8z" />
    <path d="M12.3 74.7L.5 111c-1 3.2 0 6.8 3 8.8l101.6 74-92.5-119z"/>
    <path d="M105 193.7l-38.6-119h-54l92.7 119z"/>
    <path d="M105 193.7l38.7-119H66.4l38.7 119z"/>
    <path d="M105 193.7l38.7-119H198l-93 119z"/>
    <path d="M198 74.7l11.6 36.2c1 3 0 6.6-3 8.6l-101.5 74 93-119z"/>
    <path d="M198 74.7h-54.3L167 3c1.2-3.6 6.4-3.6 7.6 0L198 74.8z"/>
  </symbol>
  <symbol viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="rss">
    <circle cx="3.429" cy="20.571" r="3.429"></circle>
    <path d="M11.429 24h4.57C15.999 15.179 8.821 8.001 0 8v4.572c6.302.001 11.429 5.126 11.429 11.428z"></path>
    <path d="M24 24C24 10.766 13.234 0 0 0v4.571c10.714 0 19.43 8.714 19.43 19.429z"></path>
  </symbol>
  <symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="linkedin">
    <path d="M437 0H75C33.648 0 0 33.648 0 75v362c0 41.352 33.648 75 75 75h362c41.352 0 75-33.648 75-75V75c0-41.352-33.648-75-75-75zM181 406h-60V196h60zm0-240h-60v-60h60zm210 240h-60V286c0-16.54-13.46-30-30-30s-30 13.46-30 30v120h-60V196h60v11.309C286.719 202.422 296.93 196 316 196c40.691.043 75 36.547 75 79.688zm0 0"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 612 612" id="to-top">
    <path d="M604.501 440.509L325.398 134.956c-5.331-5.357-12.423-7.627-19.386-7.27-6.989-.357-14.056 1.913-19.387 7.27L7.499 440.509c-9.999 10.024-9.999 26.298 0 36.323s26.223 10.024 36.222 0l262.293-287.164L568.28 476.832c9.999 10.024 26.222 10.024 36.221 0 9.999-10.023 9.999-26.298 0-36.323z"></path>
  </symbol>
  <symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="carly">
    <path d="M504.971 239.029L448 182.059V84c0-46.317-37.682-84-84-84h-44c-13.255 0-24 10.745-24 24s10.745 24 24 24h44c19.851 0 36 16.149 36 36v108c0 6.365 2.529 12.47 7.029 16.971L454.059 256l-47.029 47.029A24.002 24.002 0 0 0 400 320v108c0 19.851-16.149 36-36 36h-44c-13.255 0-24 10.745-24 24s10.745 24 24 24h44c46.318 0 84-37.683 84-84v-98.059l56.971-56.971c9.372-9.372 9.372-24.568 0-33.941zM112 192V84c0-19.851 16.149-36 36-36h44c13.255 0 24-10.745 24-24S205.255 0 192 0h-44c-46.318 0-84 37.683-84 84v98.059l-56.971 56.97c-9.373 9.373-9.373 24.568 0 33.941L64 329.941V428c0 46.317 37.682 84 84 84h44c13.255 0 24-10.745 24-24s-10.745-24-24-24h-44c-19.851 0-36-16.149-36-36V320c0-6.365-2.529-12.47-7.029-16.971L57.941 256l47.029-47.029A24.002 24.002 0 0 0 112 192z"></path>
  </symbol>
  <symbol viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="copy">
    <path d="M23 2.75A2.75 2.75 0 0 0 20.25 0H8.75A2.75 2.75 0 0 0 6 2.75v13.5A2.75 2.75 0 0 0 8.75 19h11.5A2.75 2.75 0 0 0 23 16.25zM18.25 14.5h-7.5a.75.75 0 0 1 0-1.5h7.5a.75.75 0 0 1 0 1.5zm0-3h-7.5a.75.75 0 0 1 0-1.5h7.5a.75.75 0 0 1 0 1.5zm0-3h-7.5a.75.75 0 0 1 0-1.5h7.5a.75.75 0 0 1 0 1.5z"></path>
    <path d="M8.75 20.5a4.255 4.255 0 0 1-4.25-4.25V2.75c0-.086.02-.166.025-.25H3.75A2.752 2.752 0 0 0 1 5.25v16A2.752 2.752 0 0 0 3.75 24h12a2.752 2.752 0 0 0 2.75-2.75v-.75z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512.001 512.001" id="closeme">
    <path d="M284.286 256.002L506.143 34.144c7.811-7.811 7.811-20.475 0-28.285-7.811-7.81-20.475-7.811-28.285 0L256 227.717 34.143 5.859c-7.811-7.811-20.475-7.811-28.285 0-7.81 7.811-7.811 20.475 0 28.285l221.857 221.857L5.858 477.859c-7.811 7.811-7.811 20.475 0 28.285a19.938 19.938 0 0 0 14.143 5.857 19.94 19.94 0 0 0 14.143-5.857L256 284.287l221.857 221.857c3.905 3.905 9.024 5.857 14.143 5.857s10.237-1.952 14.143-5.857c7.811-7.811 7.811-20.475 0-28.285L284.286 256.002z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="open-menu">
    <path d="M492 236H20c-11.046 0-20 8.954-20 20s8.954 20 20 20h472c11.046 0 20-8.954 20-20s-8.954-20-20-20zm0-160H20C8.954 76 0 84.954 0 96s8.954 20 20 20h472c11.046 0 20-8.954 20-20s-8.954-20-20-20zm0 320H20c-11.046 0-20 8.954-20 20s8.954 20 20 20h472c11.046 0 20-8.954 20-20s-8.954-20-20-20z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="instagram">
    <path d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948 0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072 3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.163 6.162 6.163 6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zm0 10.162c-2.209 0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796 0-1.441.645-1.441 1.44s.645 1.44 1.441 1.44c.795 0 1.439-.645 1.439-1.44s-.644-1.44-1.439-1.44z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id=youtube>
    <path d="M19.615 3.184c-3.604-.246-11.631-.245-15.23 0-3.897.266-4.356 2.62-4.385 8.816.029 6.185.484 8.549 4.385 8.816 3.6.245 11.626.246 15.23 0 3.897-.266 4.356-2.62 4.385-8.816-.029-6.185-.484-8.549-4.385-8.816zm-10.615 12.816v-8l8 3.993-8 4.007z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="stackoverflow">
    <path d="M21 27v-8h3v11H0V19h3v8h18z"></path><path d="M17.1.2L15 1.8l7.9 10.6 2.1-1.6L17.1.2zm3.7 14.7L10.6 6.4l1.7-2 10.2 8.5-1.7 2zM7.2 12.3l12 5.6 1.1-2.4-12-5.6-1.1 2.4zm-1.8 6.8l13.56 1.96.17-2.38-13.26-2.55-.47 2.97zM19 25H5v-3h14v3z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="xing">
    <path d="M18.188 0c-.517 0-.741.325-.927.66 0 0-7.455 13.224-7.702 13.657.015.024 4.919 9.023 4.919 9.023.17.308.436.66.967.66h3.454c.211 0 .375-.078.463-.22.089-.151.089-.346-.009-.536l-4.879-8.916c-.004-.006-.004-.016 0-.022L22.139.756c.095-.191.097-.387.006-.535C22.056.078 21.894 0 21.686 0h-3.498zM3.648 4.74c-.211 0-.385.074-.473.216-.09.149-.078.339.02.531l2.34 4.05c.004.01.004.016 0 .021L1.86 16.051c-.099.188-.093.381 0 .529.085.142.239.234.45.234h3.461c.518 0 .766-.348.945-.667l3.734-6.609-2.378-4.155c-.172-.315-.434-.659-.962-.659H3.648v.016z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 71 55" id="discord">
    <path d="M60.1045 4.8978C55.5792 2.8214 50.7265 1.2916 45.6527 0.41542C45.5603 0.39851 45.468 0.440769 45.4204 0.525289C44.7963 1.6353 44.105 3.0834 43.6209 4.2216C38.1637 3.4046 32.7345 3.4046 27.3892 4.2216C26.905 3.0581 26.1886 1.6353 25.5617 0.525289C25.5141 0.443589 25.4218 0.40133 25.3294 0.41542C20.2584 1.2888 15.4057 2.8186 10.8776 4.8978C10.8384 4.9147 10.8048 4.9429 10.7825 4.9795C1.57795 18.7309 -0.943561 32.1443 0.293408 45.3914C0.299005 45.4562 0.335386 45.5182 0.385761 45.5576C6.45866 50.0174 12.3413 52.7249 18.1147 54.5195C18.2071 54.5477 18.305 54.5139 18.3638 54.4378C19.7295 52.5728 20.9469 50.6063 21.9907 48.5383C22.0523 48.4172 21.9935 48.2735 21.8676 48.2256C19.9366 47.4931 18.0979 46.6 16.3292 45.5858C16.1893 45.5041 16.1781 45.304 16.3068 45.2082C16.679 44.9293 17.0513 44.6391 17.4067 44.3461C17.471 44.2926 17.5606 44.2813 17.6362 44.3151C29.2558 49.6202 41.8354 49.6202 53.3179 44.3151C53.3935 44.2785 53.4831 44.2898 53.5502 44.3433C53.9057 44.6363 54.2779 44.9293 54.6529 45.2082C54.7816 45.304 54.7732 45.5041 54.6333 45.5858C52.8646 46.6197 51.0259 47.4931 49.0921 48.2228C48.9662 48.2707 48.9102 48.4172 48.9718 48.5383C50.038 50.6034 51.2554 52.5699 52.5959 54.435C52.6519 54.5139 52.7526 54.5477 52.845 54.5195C58.6464 52.7249 64.529 50.0174 70.6019 45.5576C70.6551 45.5182 70.6887 45.459 70.6943 45.3942C72.1747 30.0791 68.2147 16.7757 60.1968 4.9823C60.1772 4.9429 60.1437 4.9147 60.1045 4.8978ZM23.7259 37.3253C20.2276 37.3253 17.3451 34.1136 17.3451 30.1693C17.3451 26.225 20.1717 23.0133 23.7259 23.0133C27.308 23.0133 30.1626 26.2532 30.1066 30.1693C30.1066 34.1136 27.28 37.3253 23.7259 37.3253ZM47.3178 37.3253C43.8196 37.3253 40.9371 34.1136 40.9371 30.1693C40.9371 26.225 43.7636 23.0133 47.3178 23.0133C50.9 23.0133 53.7545 26.2532 53.6986 30.1693C53.6986 34.1136 50.9 37.3253 47.3178 37.3253Z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 17 18" id="mastodon">
    <path
    fill="#ffffff"
    d="m 15.054695,9.8859583 c -0.22611,1.1632697 -2.02517,2.4363497 -4.09138,2.6830797 -1.0774504,0.12856 -2.1382704,0.24673 -3.2694704,0.19484 -1.84996,-0.0848 -3.30971,-0.44157 -3.30971,-0.44157 0,0.1801 0.0111,0.35157 0.0333,0.51194 0.24051,1.82571 1.81034,1.93508 3.29737,1.98607 1.50088,0.0514 2.8373104,-0.37004 2.8373104,-0.37004 l 0.0617,1.35686 c 0,0 -1.0498104,0.56374 -2.9199404,0.66742 -1.03124,0.0567 -2.3117,-0.0259 -3.80308,-0.42069 -3.23454998,-0.85613 -3.79081998,-4.304 -3.87592998,-7.8024197 -0.026,-1.03871 -0.01,-2.01815 -0.01,-2.83732 0,-3.57732 2.34385998,-4.62587996 2.34385998,-4.62587996 1.18184,-0.54277 3.20976,-0.77101 5.318,-0.7882499985409 h 0.0518 C 9.8267646,0.01719834 11.856025,0.24547834 13.037775,0.78824834 c 0,0 2.34377,1.04855996 2.34377,4.62587996 0,0 0.0294,2.63937 -0.32687,4.47183"/>
 <path
    fill="#000000"
    d="m 12.616925,5.6916583 v 4.3315297 h -1.71607 V 5.8189683 c 0,-0.88624 -0.37289,-1.33607 -1.1187604,-1.33607 -0.82467,0 -1.23799,0.53361 -1.23799,1.58875 v 2.30122 h -1.70594 v -2.30122 c 0,-1.05514 -0.4134,-1.58875 -1.23808,-1.58875 -0.74587,0 -1.11876,0.44983 -1.11876,1.33607 v 4.2042197 h -1.71607 V 5.6916583 c 0,-0.88527 0.22541,-1.58876 0.67817,-2.10922 0.46689,-0.52047 1.07833,-0.78727 1.83735,-0.78727 0.87816,0 1.54317,0.33752 1.98288,1.01267 l 0.42744,0.71655 0.42753,-0.71655 c 0.43961,-0.67515 1.10463,-1.01267 1.9828704,-1.01267 0.75893,0 1.37037,0.2668 1.83735,0.78727 0.45268,0.52046 0.67808,1.22395 0.67808,2.10922"/>
  </symbol>
</svg>

<footer class="footer">
  <div class="footer_inner wrap pale">
    <img src='https://luoguochun.cn/icons/apple-touch-icon.png' class="icon icon_2 transparent" alt="BUF1024">
    <p>Copyright&nbsp;2011-&nbsp;<span class="year"></span>&nbsp;BUF1024. All Rights Reserved</p><a class="to_top" href="#documentTop">
  <svg class="icon">
  <title>to-top</title>
  <use xlink:href="#to-top"></use>
</svg>

</a>

  </div>
</footer>

<script type="text/javascript" src="https://luoguochun.cn/zh-cn/js/bundle.884eccc71c2848fb4aeb15945329b5a857717f0313da00cb46b765b5734cfa64b08ce2609627167129c2de17d9b47ed210682f96a2502ebb3aadc73191740211.js" integrity="sha512-iE7MxxwoSPtK6xWUUym1qFdxfwMT2gDLRrdltXNM&#43;mSwjOJglicWcSnC3hfZtH7SEGgvlqJQLrs6rccxkXQCEQ==" crossorigin="anonymous"></script>
</body>

</html>
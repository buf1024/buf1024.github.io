
<!DOCTYPE html>
<html lang="zh-cn" data-figures=""  class="page"   >

<head>
<title>BUF1024</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">





<meta property="og:locale" content="zh-cn" />

<meta property="og:type" content="article">
<meta name="description" content="输入输出 Doolittle: What concrete evidence do you have that you exist? Bomb #20: Hmmmm&hellip; well&hellip; I think, therefore I am. Doolittle: That’s good. That’s …" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:creator" content="">
<meta name="twitter:title" content="" />
<meta name="twitter:image" content="https://luoguochun.cn"/>
<meta property="og:url" content="https://luoguochun.cn/prust/ch18/" />
<meta property="og:title" content="" />
<meta property="og:description" content="输入输出 Doolittle: What concrete evidence do you have that you exist? Bomb #20: Hmmmm&hellip; well&hellip; I think, therefore I am. Doolittle: That’s good. That’s …" />
<meta property="og:image" content="https://luoguochun.cn" />
  <meta name="keywords" content="blog,computer,luoguochun" />

<link rel="apple-touch-icon" sizes="180x180" href="https://luoguochun.cn/icons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://luoguochun.cn/icons/favicon-32x32.png">
<link rel="manifest" href="https://luoguochun.cn/icons/site.webmanifest">

<link rel="canonical" href="https://luoguochun.cn/prust/ch18/">



<link rel="preload" href="https://luoguochun.cn/css/styles.42e2c5f6d8cf9c52872666f8d8b2678ad0c426978b9d78aff3c33b7a1e7f6f97f54bcdaf0518a25fb0fe26367d04f8b07c683b3b38b331cb098daadee06b1f3e.css" integrity = "sha512-QuLF9tjPnFKHJmb42LJnitDEJpeLnXiv88M7eh5/b5f1S82vBRiiX7D&#43;JjZ9BPiwfGg7OzizMcsJjare4GsfPg==" as="style" crossorigin="anonymous">



<link rel="preload" href="https://luoguochun.cn/zh-cn/js/bundle.884eccc71c2848fb4aeb15945329b5a857717f0313da00cb46b765b5734cfa64b08ce2609627167129c2de17d9b47ed210682f96a2502ebb3aadc73191740211.js" as="script" integrity=
"sha512-iE7MxxwoSPtK6xWUUym1qFdxfwMT2gDLRrdltXNM&#43;mSwjOJglicWcSnC3hfZtH7SEGgvlqJQLrs6rccxkXQCEQ==" crossorigin="anonymous">


<link rel="stylesheet" type="text/css" href="https://luoguochun.cn/css/styles.42e2c5f6d8cf9c52872666f8d8b2678ad0c426978b9d78aff3c33b7a1e7f6f97f54bcdaf0518a25fb0fe26367d04f8b07c683b3b38b331cb098daadee06b1f3e.css" integrity="sha512-QuLF9tjPnFKHJmb42LJnitDEJpeLnXiv88M7eh5/b5f1S82vBRiiX7D&#43;JjZ9BPiwfGg7OzizMcsJjare4GsfPg==" crossorigin="anonymous">

</head>

<body data-code="100" data-lines="false" id="documentTop"
  data-lang="zh-cn">

<header class="nav_header" >
  <nav class="nav"><a href='https://luoguochun.cn' class="nav_brand nav_item" title="BUF1024">BUF1024
  <div class="nav_close">
    <div><svg class="icon">
  <title>open-menu</title>
  <use xlink:href="#open-menu"></use>
</svg>
<svg class="icon">
  <title>closeme</title>
  <use xlink:href="#closeme"></use>
</svg>
</div>
  </div>
</a>

    <div class='nav_body nav_body_left'>
      
      
      
        

  <div class="nav_parent">
    <a href="https://luoguochun.cn/" class="nav_item" title="主页">主页 </a>
  </div>
  <div class="nav_parent">
    <a href="https://luoguochun.cn" class="nav_item" title="链接">链接 <img src='https://luoguochun.cn/icons/caret-icon.svg' alt="icon" class="nav_icon"></a>
    <div class="nav_sub">
      <span class="nav_child"></span>
        <a href="https://luoguochun.cn/talib-doc/" class="nav_child nav_item" title="TA 技术分析库">TA 技术分析库</a>
        <a href="https://luoguochun.cn/hiqradio" class="nav_child nav_item" title="hiqadio网络收音机">hiqadio网络收音机</a>
    </div>
  </div>
  <div class="nav_parent">
    <a href="https://luoguochun.cn/about/" class="nav_item" title="关于">关于 </a>
  </div>
      
<div class='follow'>
<div class="color_mode">
  <input type="checkbox" class="color_choice" id="mode">
</div>

</div>

    </div>
  </nav>
</header>

  <main>
  
<div class="grid-inverse wrap content">
  <article class="post_content">
    <h1 class="post_title"></h1>
  <div class="post_meta">
    <span><svg class="icon">
  <title>calendar</title>
  <use xlink:href="#calendar"></use>
</svg>
</span>
    <span class="post_date">
      Jan 1, 0001</span>
    <span class="post_time"> · 31 min read</span>
    <span class="page_only">&nbsp;·
  <div class="post_share">
    分享到:
    <a href="https://twitter.com/intent/tweet?text=&url=https%3a%2f%2fluoguochun.cn%2fprust%2fch18%2f&tw_p=tweetbutton" class="twitter" title="分享到 Twitter" target="_blank" rel="nofollow">
      <svg class="icon">
  <title>twitter</title>
  <use xlink:href="#twitter"></use>
</svg>

    </a>
    <a href="https://www.facebook.com/sharer.php?u=https%3a%2f%2fluoguochun.cn%2fprust%2fch18%2f&t=" class="facebook" title="分享到 Facebook" target="_blank" rel="nofollow">
      <svg class="icon">
  <title>facebook</title>
  <use xlink:href="#facebook"></use>
</svg>

    </a>
    <a href="#linkedinshare" id = "linkedinshare" class="linkedin" title="分享到 LinkedIn" rel="nofollow">
      <svg class="icon">
  <title>linkedin</title>
  <use xlink:href="#linkedin"></use>
</svg>

    </a>
    <a href="https://luoguochun.cn/prust/ch18/" title="Copy Link" class="link link_yank">
      <svg class="icon">
  <title>copy</title>
  <use xlink:href="#copy"></use>
</svg>

    </a>
  </div>
  </span>
  </div>

    <div class="post_body"><h1 id="输入输出">输入输出</h1>
<p><em>Doolittle: What concrete evidence do you have that you exist?</em></p>
<p><em>Bomb #20: Hmmmm&hellip; well&hellip; I think, therefore I am.</em></p>
<p><em>Doolittle: That’s good. That’s very good. But how do you know that anything else exists?</em></p>
<p><em>Bomb #20: My sensory apparatus reveals it to me.</em></p>
<p align="right">
    ——Dark Star
</p>
<p>Rust中有关输入输出的特性围绕着三个trait：<code>Read</code>、<code>BufRead</code>、<code>Write</code>来组织：</p>
<ul>
<li>实现了<code>Read</code>的值有读取字节输入的方法。它们被称为 <em>读者(reader)</em> 。</li>
<li>实现了<code>BufRead</code>的值是 <em>buffered reader(有缓存的读者)</em> 。它们支持<code>Read</code>的所有方法，加上读取文本的一行的方法，等等。</li>
<li>实现了<code>Write</code>的值支持字节和UTF-8文本输出。它们被称为 <em>写者(writer)</em> 。</li>
</ul>
<p>”图18-1”展示了这三个trait以及一些reader和writer类型的示例。</p>
<p>在本章中，我们将解释如何使用这些trait和它们的方法，包括图中出现的reader和writer类型，还有一些其他的和文件、终端、网络交互的方法。</p>
<p><figure>
  <picture>

    
      
        
        
        
        
        
        
    <img
      loading="lazy"
      decoding="async"
      alt="Rust的三个主要的I/O trait以及一些实现了它们的类型"
      
        class="image_figure image_internal image_unprocessed"
        src="../img/f18-1.png"
      
      
    />

    </picture>
</figure>
</p>
<p align="center">图18-1 Rust的三个主要的I/O trait以及一些实现了它们的类型</p>
<h2 id="reader和writer">Reader和Writer</h2>
<p><em>Reader</em> 是你的程序可以从中读取字节的值。例如：</p>
<ul>
<li>使用<code>std::fs::File::open(filename)</code>打开的文件</li>
<li>用于从网络中接收数据的<code>std::net::TcpStream</code></li>
<li>进程用来读取标准输入的<code>std::io::stdin()</code></li>
<li><code>std::io::Cursor&lt;&amp;[u8]&gt;</code>和<code>std::io::Cursor&lt;Vec&lt;u8&gt;&gt;</code>值，它们是从内存中的字节数组或vector中“读取”数据的reader</li>
</ul>
<p><em>Writer</em> 是你的程序可以向其中写入字节的值。例如：</p>
<ul>
<li>使用<code>std::fs::File::create(filename)</code>打开的文件</li>
<li>用于向网络中发送数据的<code>std::net::TcpStream</code></li>
<li>用于写入到终端的<code>std::io::stdout()</code>和<code>std::io::stderr()</code></li>
<li><code>Vec&lt;u8&gt;</code>，它也是一个writer，它的<code>write</code>方法把数据附加到尾部</li>
<li><code>std::io::Cursor&lt;Vec&lt;u8&gt;&gt;</code>，类似于上面，但允许你同时读取和写入数据，并可以在vector中定位到不同位置</li>
<li><code>std::io::Cursor&lt;&amp;mut [u8]&gt;</code>，和<code>std::io::Cursor&lt;Vec&lt;u8&gt;&gt;</code>很像，除了它不能让缓冲区增长，因为它只是已经存在的字节数组的切片</li>
</ul>
<p>因为有为reader和writer设计的标准trait（<code>std::io::Read</code>和<code>std::io::Write</code>），所以编写可以处理多种输入输出通道的泛型代码是非常普遍的。例如，这里有一个函数拷贝任意reader中的所有字节到任意writer：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="p">{</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">Read</span><span class="p">,</span><span class="w"> </span><span class="n">Write</span><span class="p">,</span><span class="w"> </span><span class="n">ErrorKind</span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">DEFAULT_BUF_SIZE</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">copy</span><span class="o">&lt;</span><span class="n">R</span>: <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span><span class="w"> </span><span class="n">W</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="n">reader</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">R</span><span class="p">,</span><span class="w"> </span><span class="n">writer</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">W</span><span class="p">)</span><span class="w">
</span><span class="w">        </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="kt">u64</span><span class="o">&gt;</span><span class="w">
</span><span class="w">        </span><span class="k">where</span><span class="w"> </span><span class="n">R</span>: <span class="nc">Read</span><span class="p">,</span><span class="w"> </span><span class="n">W</span>: <span class="nc">Write</span><span class="w">
</span><span class="w">    </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">DEFAULT_BUF_SIZE</span><span class="p">];</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">written</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">reader</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">buf</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="nb">Ok</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">written</span><span class="p">),</span><span class="w">
</span><span class="w">                </span><span class="nb">Ok</span><span class="p">(</span><span class="n">len</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">len</span><span class="p">,</span><span class="w">
</span><span class="w">                </span><span class="nb">Err</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">kind</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ErrorKind</span>::<span class="n">Interrupted</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">continue</span><span class="p">,</span><span class="w">
</span><span class="w">                </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">),</span><span class="w">
</span><span class="w">            </span><span class="p">};</span><span class="w">
</span><span class="w">            </span><span class="n">writer</span><span class="p">.</span><span class="n">write_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="o">..</span><span class="n">len</span><span class="p">])</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="n">written</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u64</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这是Rust的标准库中的<code>std::io::copy()</code>的实现。因为它是泛型的，你可以使用它从<code>File</code>中读取数据然后写入到<code>TcpStream</code>，或者从<code>Stdin</code>读取，然后写入到内存中的<code>Vec&lt;u8&gt;</code>，等等。</p>
<p>如果你看不明白这里的错误处理代码，请复习”第7章”。我们将在接下来的内容中一直使用<code>Result</code>类型，掌握它的工作原理很重要。</p>
<p>这三个<code>std::io</code>的trait：<code>Read</code>、<code>BufRead</code>、<code>Write</code>，以及<code>Seek</code>如此常用，以至于有一个只包含这些trait的<code>prelude</code>模块：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">prelude</span>::<span class="o">*</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>本章中你还会见到它一到两次。我们通常也习惯导入<code>std::io</code>模块自身：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="p">{</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">Read</span><span class="p">,</span><span class="w"> </span><span class="n">Write</span><span class="p">,</span><span class="w"> </span><span class="n">ErrorKind</span><span class="p">};</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这里的<code>self</code>关键字声明了<code>io</code>作为<code>std::io</code>模块的一个别名。这样，<code>std::io::Result</code>和<code>std::io::Error</code>可以用<code>io::Result</code>和<code>io::Error</code>更简洁地表示出来，等等。</p>
<h3 id="reader">Reader</h3>
<p><code>std::io::Read</code>有几个方法用于读取数据。所有这些方法都通过<code>mut</code>引用获取self参数。</p>
<p><em><code>reader.read(&amp;mut buffer)</code></em></p>
<p>  从数据源读取一些字节，并存储到给定的<code>buffer</code>中。<code>buffer</code>参数的类型是<code>&amp;mut [u8]</code>。它最多读取<code>buffer.len()</code>个字节。</p>
<p>  返回类型是<code>io::Result&lt;u64&gt;</code>，它是<code>Result&lt;u64, io::Error&gt;</code>的类型别名。当成功时，<code>u64</code>值是读取到的字节数，它可能等于或者小于<code>buffer.len()</code>， <em>即使还有更多的数据可以读取</em> 。<code>Ok(0)</code>意味着没有更多的输入可以读取。</p>
<p>  当出错时，<code>.read()</code>返回<code>Err(err)</code>，其中<code>err</code>是一个<code>io::Error</code>值。为了便于人类阅读，<code>io::Error</code>是可打印的；而对于程序，它有一个<code>.kind()</code>方法返回一个<code>io::ErrorKind</code>类型的错误码。这个枚举的成员有例如<code>PermissionDenied</code>和<code>ConnectionReset</code>。大多数的错误都不能被忽略，但有一种错误应该进行特殊处理。<code>io::ErrorKind::Interrupted</code>对应Unix的错误码<code>EINTR</code>，它意味着读取过程恰好被一个信号打断。除非你的程序想设计为根据信号做一些聪明的操作，否则它应该简单地重试读取操作。上一节中的<code>copy()</code>的代码，就是一个例子。</p>
<p>  如你所见，<code>.read()</code>方法非常底层，甚至直接继承了底层操作系统的怪癖。如果你要为一个新的数据源类型实现<code>Read</code> trait，这会赋予你极大的灵活性。但如果你尝试读取一些数据，就会非常难受。因此，Rust提供了几个更高级的便捷方法。它们都有基于<code>.read()</code>的默认实现。它们都处理了<code>ErrorKind::Interrupted</code>，因此你不需要再处理。</p>
<p><em><code>reader.read_to_end(&amp;mut byte_vec)</code></em></p>
<p>  读取reader中剩余的所有输入，将读到的数据附加到<code>byte_vec</code>尾部，<code>byte_vec</code>是一个<code>Vec&lt;u8&gt;</code>。返回一个<code>io::Result&lt;uszie&gt;</code>，表示读取到的字节数。</p>
<p>  这个方法读取的数据的大小没有限制，因此不要将它用于不受信任的源。（你可以使用<code>.take()</code>方法施加限制，如后文所述。）</p>
<p><em><code>reader.read_to_string(&amp;mut string)</code></em></p>
<p>  和上面相同，不过把数据附加到给定的<code>String</code>。如果流不是有效的UTF-8，它会返回一个<code>ErrorKind::InvalidData</code>错误。</p>
<p>  在一些编程语言中，字节输入和字符输入由不同的类型来处理。如今，UTF-8占据主导地位，Rust承认这一事实标准，并且完全支持UTF-8。其他字符集由开源的<code>encoding</code> crate提供支持。</p>
<p><em><code>reader.read_exact(&amp;mut buf)</code></em></p>
<p>  读取恰好足以填满给定缓冲区的数据。参数的类型是<code>&amp;mut [u8]</code>，如果在读取够<code>buf.len()</code>个字节之前reader的数据就已经耗光，那么会返回一个<code>ErrorKind:: UnexpectedEof</code>错误。</p>
<p>上面这些是<code>Read</code> trait的主要方法。除此之外，还有三个以值获取<code>reader</code>的适配器方法，将它转换为一个迭代器或者一个不同的reader：</p>
<p><em><code>reader.bytes()</code></em></p>
<p>  返回一个输入流的字节的迭代器。item的类型是<code>io::Result&lt;u8&gt;</code>，因此每一个字节都需要进行错误检查。另外，它会逐字节调用<code>reader.read()</code>，因此如果reader没有缓存的话会非常低效。</p>
<p><em><code>reader.chain(reader2)</code></em></p>
<p>  返回一个新的reader，首先产生<code>reader</code>的所有输入，然后产生<code>reader2</code>的所有输入。</p>
<p><em><code>reader.take(n)</code></em></p>
<p>  返回一个新的reader，从和<code>reader</code>相同的数据源读取数据，但最多只读取<code>n</code>个字节。</p>
<p>没有关闭reader的方法。reader和writer通常实现了<code>Drop</code>，因此它们会自动关闭。</p>
<h3 id="有缓冲的reader">有缓冲的Reader</h3>
<p>出于性能考虑，reader和writer可以进行 <em>缓存(buffer)</em> ，意思是它们有一块内存（缓冲区）用来存储一些输入或输出数据。这样可以减少系统调用的次数，如”图18-2”所示。在这个例子中，应用调用<code>.read_line()</code>方法从<code>BufReader</code>中读取数据，<code>BufReader</code>从操作系统获取更大块的输入。</p>
<p><figure>
  <picture>

    
      
        
        
        
        
        
        
    <img
      loading="lazy"
      decoding="async"
      alt="一个有缓冲的文件reader"
      
        class="image_figure image_internal image_unprocessed"
        src="../img/f18-2.png"
      
      
    />

    </picture>
</figure>
</p>
<p align="center">图18-2 一个有缓冲的文件reader</p>
<p>这张图并不是按比例的，一个<code>BufReader</code>的实际大小是几千字节，因此一次系统的<code>read</code>调用可以提供上百次<code>.read_line()</code>调用。这么做之所以能提高性能是因为系统调用很慢。（如图所示，操作系统也有一个缓冲区，原因与此相同：系统调用很慢，但从磁盘读取数据更慢。）</p>
<p>有缓冲的reader实现了<code>Read</code>和另一个trait <code>BufRead</code>，它添加了下面的方法：</p>
<p><em><code>reader.read_line(&amp;mut line)</code></em></p>
<p>  读取一行文本并将它附加到<code>line</code>，<code>line</code>是一个<code>String</code>。行尾的换行符<code>'\n'</code>
也会包含在<code>line</code>中。如果输入中有Windows风格的换行符<code>&quot;\r\n&quot;</code>，这两个字符都会包含进<code>line</code>。</p>
<p>  返回值是一个<code>io::Result&lt;usize&gt;</code>，代表读取到的字节数，包括行尾的换行符。</p>
<p>  如果reader到达输入结尾，<code>line</code>会保持不变，并返回<code>Ok(0)</code>。</p>
<p><em><code>reader.lines()</code></em></p>
<p>  返回一个迭代输入中每一行的迭代器。item的类型是<code>io::Result&lt;String&gt;</code>。换行符 <em>不</em> 包含在字符串中。如果输入中有Windows风格的换行符<code>&quot;\r\n&quot;</code>，这两个字符都会被丢弃。</p>
<p>  这个方法几乎总是你需要的文本输入方法。下面的两节会通过例子展示如何使用它。</p>
<p><em><code>reader.read_until(stop_byte, &amp;mut byte_vec), reader.split(stop_byte)</code></em></p>
<p>  这两个方法类似于<code>.read_line()</code>和<code>.lines()</code>，但是是面向字节的，产生<code>Vec&lt;u8&gt;</code>而不是<code>String</code>。你可以选择终止符<code>stop_byte</code>。</p>
<p><code>BufRead</code>还提供两个底层的方法<code>.fill_buf()</code>和<code>.consume(n)</code>，用来直接访问reader的内部缓冲区。更多有关这些方法的信息，可以查阅在线文档。</p>
<p>接下来的两节详细介绍了有缓冲的reader。</p>
<h3 id="读取行">读取行</h3>
<p>这里有一个实现了Unix <code>grep</code>工具的函数。它搜索文本的每一行，文本通常通过管道从另一个命令输入。对于一个给定的字符串：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">prelude</span>::<span class="o">*</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">grep</span><span class="p">(</span><span class="n">target</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">stdin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io</span>::<span class="n">stdin</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">line_result</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">stdin</span><span class="p">.</span><span class="n">lock</span><span class="p">().</span><span class="n">lines</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">line_result</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">line</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">);</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>因为我们想调用<code>.lines()</code>，所以我们需要一个实现了<code>BufRead</code>的输入源。在这个例子中，我们调用了<code>io::stdin()</code>来获取通过管道传入的数据。然而，Rust标准库使用了一个mutex来保护<code>stdin</code>，我们调用<code>.lock()</code>来锁住<code>stdin</code>以让当前的线程独占使用，它返回一个实现了<code>BufRead</code>的<code>StdinLock</code>值。在循环的结尾，<code>StdinLock</code>被丢弃，释放mutex。（如果没有mutex，那么如果两个线程同时从<code>stdin</code>中读取数据，会导致未定义行为。C里也有这个问题，它通过这种方式解决它：C中所有的输入和输出函数会在幕后获取一个锁。Rust中唯一的不同就是锁是API的一部分。）</p>
<p>函数的剩余部分非常直观：它调用<code>.lines()</code>并迭代返回的迭代器。因为这个迭代器产生<code>Result</code>值，所以我们使用<code>?</code>操作符来检查错误。</p>
<p>假设我们想进一步扩展我们的<code>grep</code>程序，让它支持搜索磁盘中的文件。我们可以把函数修改为泛型的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">grep</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span><span class="p">(</span><span class="n">target</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">reader</span>: <span class="nc">R</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w">
</span><span class="w">        </span><span class="k">where</span><span class="w"> </span><span class="n">R</span>: <span class="nc">BufRead</span><span class="w">
</span><span class="w">    </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">line_result</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">reader</span><span class="p">.</span><span class="n">lines</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">line_result</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">line</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">);</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>现在我们可以向它传递一个<code>StdinLock</code>或者一个有缓存的<code>File</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">stdin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io</span>::<span class="n">stdin</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">grep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">target</span><span class="p">,</span><span class="w"> </span><span class="n">stdin</span><span class="p">.</span><span class="n">lock</span><span class="p">())</span><span class="o">?</span><span class="p">;</span><span class="w">   </span><span class="c1">// ok
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">grep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">target</span><span class="p">,</span><span class="w"> </span><span class="n">BufReader</span>::<span class="n">new</span><span class="p">(</span><span class="n">f</span><span class="p">))</span><span class="o">?</span><span class="p">;</span><span class="w">  </span><span class="c1">// ok
</span></code></pre></td></tr></table>
</div>
</div><p>注意<code>File</code>并不是自动缓存的。<code>File</code>实现了<code>Read</code>但没有实现<code>BufRead</code>。然而，很容易为<code>File</code>或者其他任何无缓存的reader创建一个有缓存的reader。<code>BufReader::new(reader)</code>可以实现这个功能。（可以使用<code>BufReader::with_capacity(size, reader)</code>设置缓冲区的大小。）</p>
<p>在大多数语言中，文件都是默认有缓存的。如果你想要无缓存的输入或输出，你必须知道如何关闭缓存。在Rust中，<code>File</code>和<code>BufReader</code>是两个单独的库特性，因为有时你可能需要没有缓冲的文件，或者需要缓存文件之外的内容（例如，你可能会想要缓存来自网络的输入）。</p>
<p>包含错误处理和一些参数解析的完整的程序，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="c1">// grep - 搜索stdin或文件中匹配给定string的行
</span><span class="c1"></span><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">error</span>::<span class="n">Error</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="p">{</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">BufReader</span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">prelude</span>::<span class="o">*</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">path</span>::<span class="n">PathBuf</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">grep</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span><span class="p">(</span><span class="n">target</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">reader</span>: <span class="nc">R</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w">
</span><span class="w">        </span><span class="k">where</span><span class="w"> </span><span class="n">R</span>: <span class="nc">BufRead</span><span class="w">
</span><span class="w">    </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">line_result</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">reader</span><span class="p">.</span><span class="n">lines</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">line_result</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">line</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">);</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">grep_main</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// 获取命令行参数。第一个参数是要搜索的字符串；
</span><span class="c1"></span><span class="w">        </span><span class="c1">// 剩余的是文件名。
</span><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">env</span>::<span class="n">args</span><span class="p">().</span><span class="n">skip</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">next</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="s">&#34;usage: grep PATTERN FILE...&#34;</span><span class="p">)</span><span class="o">?</span><span class="w">
</span><span class="w">        </span><span class="p">};</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">files</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">PathBuf</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="n">PathBuf</span>::<span class="n">from</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">files</span><span class="p">.</span><span class="n">is_empty</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">stdin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io</span>::<span class="n">stdin</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="n">grep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">target</span><span class="p">,</span><span class="w"> </span><span class="n">stdin</span><span class="p">.</span><span class="n">lock</span><span class="p">())</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">files</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">                </span><span class="n">grep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">target</span><span class="p">,</span><span class="w"> </span><span class="n">BufReader</span>::<span class="n">new</span><span class="p">(</span><span class="n">f</span><span class="p">))</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">grep_main</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="fm">eprintln!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span><span class="w">
</span><span class="w">            </span><span class="n">std</span>::<span class="n">process</span>::<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="收集行">收集行</h3>
<p>包括<code>.lines()</code>在内的几个reader方法返回产生<code>Result</code>的迭代器。当你第一次尝试将一个文件的每一行收集到一个很大的vector中时，你可能会遇到需要摆脱<code>Result</code>的问题：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="c1">// ok，但不是你想要的
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">results</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">reader</span><span class="p">.</span><span class="n">lines</span><span class="p">().</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// error: 不能将Result的集合转换成Vec&lt;String&gt;
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">lines</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">reader</span><span class="p">.</span><span class="n">lines</span><span class="p">().</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>第二次尝试不能编译：哪里出错了？直观的解决方法是编写一个<code>for</code>循环并为每一个item检查错误：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">lines</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[];</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">line_result</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">reader</span><span class="p">.</span><span class="n">lines</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">lines</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">line_result</span><span class="o">?</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>不错；但这里如果使用<code>.collect()</code>会更好，并且我们确实可以这么做。我们只需要知道需要什么样的类型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">lines</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">reader</span><span class="p">.</span><span class="n">lines</span><span class="p">().</span><span class="n">collect</span>::<span class="o">&lt;</span><span class="n">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;&gt;&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>为什么这能工作？标准库里为<code>Result</code>包含了一个<code>FromIterator</code>的实现——在在线文档中容易忽略——让这变为了可能：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="o">&gt;</span><span class="w"> </span><span class="n">FromIterator</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="o">&gt;</span><span class="w">
</span><span class="w">        </span><span class="k">where</span><span class="w"> </span><span class="n">C</span>: <span class="nc">FromIterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这个签名需要仔细阅读，但它是一个漂亮的技巧。假设<code>C</code>是任意集合类型，例如<code>Vec</code>或者<code>HashSet</code>。只要我们已经知道了如何从一个产生<code>T</code>值的迭代器构建一个<code>C</code>，我们就可以从一个产生<code>Result&lt;T, E&gt;</code>值的迭代器构建一个<code>Result&lt;C, E&gt;</code>。我们只需要遍历迭代器产生的值，用其中的<code>Ok</code>值构建集合，但如何遇到了一个<code>Err</code>，就停止并传递它。</p>
<p>换句话说，<code>io::Result&lt;Vec&lt;String&gt;&gt;</code>是一个集合类型，所以<code>.collect()</code>方法可以创建并填充这种类型的值。</p>
<h3 id="writer">Writer</h3>
<p>正如我们所见，使用方法就基本可以完成输入。输出有一些不同。</p>
<p>在整本书中，我们都在使用<code>println!()</code>来产生普通文本输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;Hello, world!&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;The greatest common divisor of {:?} is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">numbers</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="fm">println!</span><span class="p">();</span><span class="w">     </span><span class="c1">// 打印空白行
</span></code></pre></td></tr></table>
</div>
</div><p>还有一个<code>print!()</code>宏，它不会在最后加上一个换行符，<code>eprintln!</code>和<code>eprint!</code>宏写入到标准错误流。这些函数的格式化代码都和<code>format!</code>宏一样，见“格式化”。</p>
<p>使用<code>write!()</code>和<code>writeln!()</code>宏可以把输出写入一个writer。它们与<code>print!()</code>和<code>println!()</code>类似，除了两个不同点：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="fm">writeln!</span><span class="p">(</span><span class="n">io</span>::<span class="n">stderr</span><span class="p">(),</span><span class="w"> </span><span class="s">&#34;error: world not helloable&#34;</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="fm">writeln!</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">byte_vec</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;The greatest common divisor of {:?} is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">numbers</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>一是<code>write</code>宏有一个额外的第一个参数：writer。另一个不同是它们返回一个<code>Result</code>，因此必须进行错误处理。这就是为什么我们在每一行的结尾都使用了<code>?</code>运算符。</p>
<p><code>print</code>宏不返回一个<code>Result</code>，如果写入失败它们会直接panic。因为它们会写入到终端，写入终端很少会失败。</p>
<p><code>Write</code> trait有这些方法：</p>
<p><em><code>writer.write(&amp;buf)</code></em></p>
<p>  将切片<code>buf</code>中的字节写入到底层的流中。它返回一个<code>io::Result&lt;usize&gt;</code>。成功时，它返回写入的字节数量，可能会小于<code>buf.len()</code>，取决于流。</p>
<p>  类似于<code>Reader::read()</code>，这是一个你应该避免直接使用的底层方法。</p>
<p><em><code>writer.write_all(&amp;buf)</code></em></p>
<p>  写入切片<code>buf</code>中的所有字节。返回<code>Result&lt;()&gt;</code>。</p>
<p><em><code>writer.flush()</code></em></p>
<p>  冲洗底层流中所有缓存的数据。返回<code>Result&lt;()&gt;</code>。</p>
<p>  注意尽管<code>println!</code>和<code>eprintln!</code>宏会自动冲洗标准输出和标准错误流，但<code>print!</code>和<code>eprint!</code>不会。使用它们之后你可能需要手动调用<code>flush()</code>。</p>
<p>类似于reader，writer也是在丢弃时自动关闭。</p>
<p>类似于<code>BufReader::new(reader)</code>为任意reader添加缓存，<code>BufWriter::new(writer)</code>为任意writer添加缓存：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">create</span><span class="p">(</span><span class="s">&#34;tmp.txt&#34;</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">writer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BufWriter</span>::<span class="n">new</span><span class="p">(</span><span class="n">file</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>为了设置缓冲区的大小，使用<code>BufWriter::with_capacity(size, writer)。</code></p>
<p>当<code>BufWriter</code>被丢弃时，它剩余的所有被缓存的数据都会被写入到底层的writer。然而，如果这次写入时出现了错误，这个错误会被 <em>忽略</em> 。（因为这个错误是在<code>BufWriter</code>的<code>.drop()</code>方法中发生，没有汇报错误的地方。）为了保证你的应用能够注意到所有的输出错误，可以在drop有缓存的writer之前手动调用<code>.flush()</code>。</p>
<h3 id="file">File</h3>
<p>我们已经看到过两种打开文件的方式：</p>
<p><em><code>File::open(filename)</code></em></p>
<p>  打开一个已存在的文件。它返回一个<code>io::Result&lt;File&gt;</code>，如果文件不存在将返回一个错误。</p>
<p><em><code>File::create(filename)</code></em></p>
<p>  创建一个新的文件用于写入。如果已经有同名文件，它会被截断。</p>
<p>注意<code>File</code>类型在文件系统模块<code>std::fs</code>中，而不是在<code>std::io</code>中。</p>
<p>当这两个文件都不符合要求时，你可以使用<code>OpenOptions</code>来指定额外的期望行为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">OpenOptions</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">log</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OpenOptions</span>::<span class="n">new</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w">   </span><span class="c1">// 如果文件存在，就追加到末尾
</span><span class="c1"></span><span class="w">        </span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">&#34;server.log&#34;</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OpenOptions</span>::<span class="n">new</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">create_new</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w">   </span><span class="c1">// 如果文件存在就失败
</span><span class="c1"></span><span class="w">        </span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">&#34;new_file.txt&#34;</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>方法<code>.append(), .write(), .create_new()</code>等，被设计用来进行类似这样的链式调用：每一个都返回<code>self</code>。这种链式方法的设计模式在Rust中太过普遍以至于有一个专门的名字：它被称为 <em>builder(构建器)</em> 。<code>std::process::Command</code>是另一个例子。更多关于<code>OpenOptions</code>的细节可以查阅在线文档。</p>
<p><code>File</code>被打开后，它的行为就类似于其他的reader和writer。如果需要的话你可以添加一个缓冲区。当你drop一个<code>File</code>时它会自动关闭。</p>
<h3 id="seek">Seek</h3>
<p><code>File</code>还实现了<code>Seek</code> trait，它意味着你可以在一个<code>File</code>中跳来跳去，而不是只能从开始单调地读到尾。<code>Seek</code>的定义类似如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Seek</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">seek</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span>: <span class="nc">SeekFrom</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="kt">u64</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">SeekFrom</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Start</span><span class="p">(</span><span class="kt">u64</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">End</span><span class="p">(</span><span class="kt">i64</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">Current</span><span class="p">(</span><span class="kt">i64</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>得益于这个枚举，<code>seek</code>方法变得很有表达力：使用<code>file.seek(SeekFrom::Start(0))</code>来定位到开始，使用<code>file.seek(SeekFrom::Current(-8))</code>来回退一些字节，等等。</p>
<p>在一个文件中定位很慢。不管你是在硬盘还是固态盘(SSD)上，定位都要消耗和读取几M数据一样长的时间。</p>
<h3 id="其他reader和writer类型">其他Reader和Writer类型</h3>
<p>目前为止，本章主要使用了<code>File</code>作为示例，但还有很多其他有用的reader和writer类型：</p>
<p><em><code>io::stdin()</code></em></p>
<p>  返回一个标准输入流的reader。它的类型是<code>io::Stdin</code>。因为它被多个线程共享，所以每一次读取都需要请求并释放mutex。</p>
<p>  <code>Stdin</code>有一个<code>.lock()</code>方法获取mutex并返回一个<code>io::StdinLock</code>，这是一个有缓存的reader，它会持有mutex，直到它被丢弃。因此对<code>StdinLock</code>的单独操作可以避免mutex的开销。我们在“读取行”中展示过使用这个方法的示例代码。</p>
<p>  出于技术原因，<code>io::stdin().lock()</code>不能工作。这个锁持有一个<code>Stdin</code>值的引用，这意味着<code>Stdin</code>值必须被存储起来，这样它才能生存的足够久：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">stdin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io</span>::<span class="n">stdin</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">lines</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stdin</span><span class="p">.</span><span class="n">lock</span><span class="p">().</span><span class="n">lines</span><span class="p">();</span><span class="w">   </span><span class="c1">// ok
</span></code></pre></td></tr></table>
</div>
</div><p><em><code>io::stdout(), io::stderr()</code></em></p>
<p>  返回标准输出和标准错误流的<code>Stdout</code>和<code>Stderr</code> writer类型。这两个类型也持有互斥锁和<code>.lock()</code>方法。</p>
<p><em><code>Vec&lt;u8&gt;</code></em></p>
<p>  实现了<code>Write</code>。写入到一个<code>Vec&lt;u8&gt;</code>会把新的数据附加到vector尾部。</p>
<p>  然而，<code>String</code> <em>并没有</em> 实现<code>Write</code>。为了使用<code>Write</code>构建一个字符串，首先要写入到一个<code>Vec&lt;u8&gt;</code>，然后使用<code>String::from_utf8(vec)</code>来把vector转换为字符串。</p>
<p><em><code>Cursor::new(buf)</code></em></p>
<p>  创建一个<code>Cursor</code>，它是一个从<code>buf</code>中读取的有缓存的reader。这也是一个创建从<code>String</code>读取的reader的方法。参数<code>buf</code>可以是任何实现了<code>AsRef&lt;[u8]&gt;</code>的类型，因此你也可以传递一个<code>&amp;[u8], &amp;str, Vec&lt;u8&gt;</code>。</p>
<p>  <code>Cursor</code>内部的结构非常简单。它只有两个字段：<code>buf</code>和一个整数，用来表示下一次读取开始的偏移量。初始时为0。</p>
<p>  <code>Cursor</code>实现了<code>Read, BufRead, Seek</code>。如果<code>buf</code>的类型是<code>&amp;mut [u8]</code>或者<code>Vec&lt;u8&gt;</code>，那么<code>Cursor</code>还会实现<code>Write</code>。写入一个<code>Cursor</code>会覆盖<code>buf</code>中从当前位置开始的字节。如果你试图越界写入一个<code>&amp;mut [u8]</code>，结果会是部分写入或者一个<code>io::Error</code>。使用Cursor越界写入一个<code>Vec&lt;u8&gt;</code>没有问题，因为它会让vector变长。因此<code>Cursor&lt;&amp;mut [u8]&gt;</code>和<code>Cursor&lt;Vec&lt;u8&gt;&gt;</code>实现了<code>std::io::prelude</code>中全部的4个trait。</p>
<p><em><code>std::net::TcpStream</code></em></p>
<p>  代表一个TCP网络连接。因为TCP允许双向连接，所以它既是reader又是writer。</p>
<p>  类型关联函数<code>TcpStream::connect((&quot;hostname&quot;, PORT))</code>尝试连接到服务器，并返回一个<code>io::Result&lt;TcpStream&gt;</code>。</p>
<p><em><code>std::process::Command</code></em></p>
<p>  支持创建一个子进程并把数据管道连接到它的标准输入，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">process</span>::<span class="p">{</span><span class="n">Command</span><span class="p">,</span><span class="w"> </span><span class="n">Stdio</span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">child</span><span class="w"> </span><span class="o">=</span><span class="w">
</span><span class="w">        </span><span class="n">Command</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;grep&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">         </span><span class="p">.</span><span class="n">arg</span><span class="p">(</span><span class="s">&#34;-e&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">         </span><span class="p">.</span><span class="n">arg</span><span class="p">(</span><span class="s">&#34;a.*e.*i.*o.*u&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">         </span><span class="p">.</span><span class="n">stdin</span><span class="p">(</span><span class="n">Stdio</span>::<span class="n">piped</span><span class="p">())</span><span class="w">
</span><span class="w">         </span><span class="p">.</span><span class="n">spawn</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">to_child</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">child</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">take</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">word</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">my_words</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="fm">writeln!</span><span class="p">(</span><span class="n">to_child</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">word</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="nb">drop</span><span class="p">(</span><span class="n">to_child</span><span class="p">);</span><span class="w"> </span><span class="c1">// 关闭grep的stdin，所以它会退出
</span><span class="c1"></span><span class="w">    </span><span class="n">child</span><span class="p">.</span><span class="n">wait</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>  <code>child.stdin</code>的类型是<code>Option&lt;std::process:ChildStdin&gt;</code>；这里我们在创建子进程的时候使用了<code>.stdin(Stdio::piped())</code>，因此<code>.spawn()</code>成功后<code>child.stdin</code>肯定是<code>Some</code>。否则<code>child.stdin</code>将是<code>None</code>。</p>
<p>  <code>Command</code>还有类似的<code>.stdout()</code>和<code>.stderr()</code>方法，它们可以用来请求<code>child.stdout</code>和<code>child.stderr</code>中的reader。</p>
<p><code>std::io</code>模块还提供了很多返回简单reader和writer的函数：</p>
<p><em><code>io::sink()</code></em></p>
<p>  这是一个无操作的writer。所有的写入方法都会返回<code>Ok</code>，但数据都会被丢弃。</p>
<p><em><code>io::empty()</code></em></p>
<p>  这是一个无操作的reader。所有的读取都会成功，但总是返回输入结束。</p>
<p><em><code>io::repeat(byte)</code></em></p>
<p>  返回一个无限重复给定字节的reader。</p>
<h3 id="二进制数据压缩和序列化">二进制数据，压缩和序列化</h3>
<p>有很多基于<code>std::io</code>框架的开源crate提供额外的特性。</p>
<p><code>byteorder</code> crate提供<code>ReadBytesExt</code>和<code>WriteBytesExt</code> trait，它们为所有reader和writer添加二进制输入和输出的方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">byteorder</span>::<span class="p">{</span><span class="n">ReadBytesExt</span><span class="p">,</span><span class="w"> </span><span class="n">WriteBytesExt</span><span class="p">,</span><span class="w"> </span><span class="n">LittleEndian</span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">reader</span><span class="p">.</span><span class="n">read_u32</span>::<span class="o">&lt;</span><span class="n">LittleEndian</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">writer</span><span class="p">.</span><span class="n">write_i64</span>::<span class="o">&lt;</span><span class="n">LittleEndian</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i64</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>flate2</code> crate提供读取和写入<code>gzip</code>数据的适配器方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">flate2</span>::<span class="n">read</span>::<span class="n">GzDecoder</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="s">&#34;access.log.gz&#34;</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">gzip_reader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GzDecoder</span>::<span class="n">new</span><span class="p">(</span><span class="n">file</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>serde</code> crate以及它关联的格式化crate例如<code>serde_json</code>，实现了序列化和反序列化：它们在Rust结构体和字节流之间来回转换。我们之前在“trait和其他人的类型”中提到过它们一次。现在让我们仔细看看。</p>
<p>假设我们有一些数据，即一个文字冒险游戏的地图，存储在一个<code>HashMap</code>中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">type</span> <span class="nc">RoomId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span><span class="p">;</span><span class="w">                       </span><span class="c1">// 每一个房间有一个独一无二的名字
</span><span class="c1"></span><span class="w">    </span><span class="k">type</span> <span class="nc">RoomExits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="n">RoomId</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span><span class="w">       </span><span class="c1">// ...和一个通向的房间的名字的列表
</span><span class="c1"></span><span class="w">    </span><span class="k">type</span> <span class="nc">RoomMap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">RoomId</span><span class="p">,</span><span class="w"> </span><span class="n">RoomExits</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// 创建一个简单的地图。
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RoomMap</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">map</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&#34;Cobble Crawl&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w">
</span><span class="w">               </span><span class="fm">vec!</span><span class="p">[(</span><span class="sc">&#39;W&#39;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Debris Room&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">())]);</span><span class="w">
</span><span class="w">    </span><span class="n">map</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&#34;Debris Room&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w">
</span><span class="w">               </span><span class="fm">vec!</span><span class="p">[(</span><span class="sc">&#39;E&#39;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Cobble Crawl&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">()),</span><span class="w">
</span><span class="w">                    </span><span class="p">(</span><span class="sc">&#39;W&#39;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Sloping Canyon&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">())]);</span><span class="w">
</span><span class="w">    </span><span class="o">..</span><span class="p">.</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>将这个数据转换为JSON并输出只需要一行代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="n">serde_json</span>::<span class="n">to_writer</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">stdout</span><span class="p">(),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">map</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>在内部，<code>serde_json::to_writer</code>使用了<code>serde::Serialize</code> trait的<code>serialize</code>方法。这个库给所有它知道如何序列化的类型附加了这个trait，其中包括我们的数据中出现的类型：字符串、字符、元组、vector、<code>HashMap</code>。</p>
<p><code>serde</code>非常灵活。在我们的程序中，输出是JSON数据，因为我们选择了<code>serde_json</code>序列化器。其他格式例如<code>MessagePack</code>也是可用的。同样地，你可以把输出送到文件、<code>Vec&lt;u8&gt;</code>或其他任何writer中。上面的代码通过<code>stdout</code>打印了数据，内容如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json">    <span class="p">{</span><span class="nt">&#34;Debris Room&#34;</span><span class="p">:[[</span><span class="s2">&#34;E&#34;</span><span class="p">,</span><span class="s2">&#34;Cobble Crawl&#34;</span><span class="p">],[</span><span class="s2">&#34;W&#34;</span><span class="p">,</span><span class="s2">&#34;Sloping Canyon&#34;</span><span class="p">]],</span><span class="nt">&#34;Cobble Crawl&#34;</span><span class="p">:</span> <span class="p">[[</span><span class="s2">&#34;W&#34;</span><span class="p">,</span><span class="s2">&#34;Debris Room&#34;</span><span class="p">]]}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>serde</code>还包括派生两个关键trait的支持：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="cp">#[derive(Serialize, Deserialize)]</span><span class="w">
</span><span class="w">    </span><span class="k">struct</span> <span class="nc">Player</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">location</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">items</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">health</span>: <span class="kt">u32</span>
    <span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这个<code>#[derive]</code>属性会让编译过程稍微变长，因此当你在 <em>Cargo.toml</em> 文件中将<code>serde</code>列为依赖时需要要求它支持这个特性。这是我们上面的代码用到的依赖：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-toml" data-lang="toml">    <span class="p">[</span><span class="nx">dependencies</span><span class="p">]</span>
    <span class="nx">serde</span> <span class="p">=</span> <span class="p">{</span> <span class="nx">version</span> <span class="p">=</span> <span class="s2">&#34;1.0&#34;</span><span class="p">,</span> <span class="nx">features</span> <span class="p">=</span> <span class="p">[</span><span class="s2">&#34;derive&#34;</span><span class="p">]</span> <span class="p">}</span>
    <span class="nx">serde_json</span> <span class="p">=</span> <span class="s2">&#34;1.0&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>更多的细节可以查阅<code>serde</code>的文档。简单来说，构建系统可以自动为<code>Player</code>生成<code>serde::Serialize</code>和<code>serde::Deserialize</code>，因此序列化一个<code>Player</code>值非常简单：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="n">serde_json</span>::<span class="n">to_writer</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">stdout</span><span class="p">(),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">player</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>输出看起来是这样的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json">    <span class="p">{</span><span class="nt">&#34;location&#34;</span><span class="p">:</span><span class="s2">&#34;Cobble Crawl&#34;</span><span class="p">,</span><span class="nt">&#34;items&#34;</span><span class="p">:[</span><span class="s2">&#34;a wand&#34;</span><span class="p">],</span><span class="nt">&#34;health&#34;</span><span class="p">:</span><span class="mi">3</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="文件和目录">文件和目录</h2>
<p>现在我们已经展示了如何使用reader和writer，下面的几节将介绍Rust中处理文件和目录的特性，它们在<code>std::path</code>和<code>std::fs</code>模块中。这些特性都涉及到文件名，所以我们将以文件名类型开始。</p>
<h3 id="osstr和path"><code>OsStr</code>和<code>Path</code></h3>
<p>很不方便的一点是，你的操作系统并不一定强制文件名是有效的Unicode。这里有两个创建文本文件的Linux shell命令。只有第一个是有效的UTF-8文件名：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">    $ echo &#34;hello world&#34; &gt; ô.txt
    $ echo &#34;O brave new world, that has such filenames in&#39;t&#34; &gt; $&#39;\xf4&#39;.txt
</code></pre></td></tr></table>
</div>
</div><p>两条命令都可以运行，因为Linux内核不知道来自Ogg Vorbis的UTF-8。对于内核来说，任何字节（除了null字节和斜杠）组成的字符串都是可接受的文件名。Windows上也类似：几乎任何16位“宽字符”组成的字符串都是可接受的文件名，即使字符串并不是有效的UTF-16。操作系统处理的其他字符串也是这样，例如命令行参数和环境变量。</p>
<p>Rust的字符串总是有效的Unicode。在实践中文件名 <em>几乎</em> 总是Unicode，但Rust必须提供方式以应对少数不是Unicode的情况。这就是为什么Rust有<code>std::ffi::OsStr</code>和<code>OsString</code>。</p>
<p><code>OsStr</code>是一个作为UTF-8超集的字符串类型。它的任务是能表示当前系统中的所有文件名、命令行参数、环境变量， <em>不管它们是不是Unicode</em> 。在Unix上，<code>OsStr</code>可以存储任意字节序列。在Windows上，<code>OsStr</code>以UTF-8的扩展格式存储，它可以编码任何16位值的序列。</p>
<p>所以我们有了两种字符串类型：<code>str</code>用于实际的Unicode字符串；<code>OsStr</code>用于操作系统可能用到的字符串。我们将再介绍一个用于文件名的<code>std::path::Path</code>，它纯粹是为了方便。<code>Path</code>实际上很像<code>OsStr</code>，但它添加了很多和文件名相关的方法，我们将在下一节中介绍。可以使用<code>Path</code>表示绝对路径和相对路径。对于路径中每个单独的部分，使用<code>OsStr</code>。</p>
<p>最后，每个字符串类型都有一个相应的 <em>有所有权的(owning)</em> 类型：<code>String</code>拥有一个堆上分配的<code>str</code>，一个<code>std::ffi::OsString</code>拥有一个堆上分配的<code>OsStr</code>，一个<code>std::path::PathBuf</code>拥有一个堆上分配的<code>Path</code>。”表18-1”列出了每个类型的一些特性。</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>str</strong></th>
<th><strong>OsStr</strong></th>
<th><strong>Path</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>非固定大小类型，总是以引用传递</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>包含任意Unicode文本</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>通常看起来就像UTF-8</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>可以包含非Unicode数据</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>文本处理方法</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>文件名相关方法</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>对应的有所有权、可增长的、堆上分配的类型</td>
<td><code>String</code></td>
<td><code>OsString</code></td>
<td><code>PathBuf</code></td>
</tr>
<tr>
<td>转换为有所有权的类型</td>
<td><code>.to_string()</code></td>
<td><code>.to_os_string()</code></td>
<td><code>.to_path_buf()</code></td>
</tr>
</tbody>
</table>
<p>所有这些类型都实现了一个公共的trait：<code>AsRef&lt;Path&gt;</code>，所以我们可以轻易地声明一个泛型函数接受“任何文件名类型”作为参数。这使用到了我们之前展示过的“<code>AsRef</code>与<code>AsMut</code>”：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">path</span>::<span class="n">Path</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">swizzle_file</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="n">path_arg</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w">
</span><span class="w">        </span><span class="k">where</span><span class="w"> </span><span class="n">P</span>: <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">path_arg</span><span class="p">.</span><span class="n">as_ref</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>所有接受<code>path</code>参数的标准函数和方法都使用了这项技术，因此你可以自由地向它们传递字符串字面量。</p>
<h3 id="path和pathbuf方法"><code>Path</code>和<code>PathBuf</code>方法</h3>
<p><code>Path</code>提供了下面这些方法：</p>
<p><em><code>Path::new(str)</code></em></p>
<p>  将一个<code>&amp;str</code>或者<code>&amp;OsStr</code>转换为<code>&amp;Path</code>。它不会拷贝字符串，新的<code>&amp;Path</code>和原本的<code>&amp;str</code>或<code>&amp;OsStr</code>指向相同的字节流：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">path</span>::<span class="n">Path</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">home_dir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Path</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;/home/fwolfe&#34;</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>  （类似的方法<code>OsStr::new(str)</code>将<code>&amp;str</code>转换为<code>&amp;OsStr</code>。）</p>
<p><em><code>path.parent()</code></em></p>
<p>  返回<code>path</code>的父目录，如果有的话。返回类型是<code>Option&lt;&amp;Path&gt;</code>。</p>
<p>  它也不会拷贝路径，<code>path</code>的父目录总是<code>path</code>的一个子串：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">Path</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;/home/fwolfe/program.txt&#34;</span><span class="p">).</span><span class="n">parent</span><span class="p">(),</span><span class="w">
</span><span class="w">               </span><span class="nb">Some</span><span class="p">(</span><span class="n">Path</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;/home/fwolfe&#34;</span><span class="p">)));</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><em><code>path.file_name()</code></em></p>
<p>  返回<code>path</code>的最后一个部分，如果有的话。返回类型是<code>Option&lt;&amp;OsStr&gt;</code>。</p>
<p>  在通常的情况下，<code>path</code>由一个目录、一个斜杠、然后是一个文件名组成，这会返回文件名：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ffi</span>::<span class="n">OsStr</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">Path</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;/home/fwolfe/program.txt&#34;</span><span class="p">).</span><span class="n">file_name</span><span class="p">(),</span><span class="w">
</span><span class="w">               </span><span class="nb">Some</span><span class="p">(</span><span class="n">OsStr</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;program.txt&#34;</span><span class="p">)));</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><em><code>path.is_absolute(), path.is_relative()</code></em></p>
<p>  这些方法判断路径是绝对的（例如Unix路径 <em>/usr/bin/advent</em> 或者Windows路径<em>C:\Program Files</em> ）还是相对的（例如 <em>src/main.rs</em> ）。</p>
<p><em><code>path1.join(path2)</code></em></p>
<p>  连接两个路径，返回一个新的<code>PathBuf</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">path1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Path</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;/usr/share/dict&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">path1</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="s">&#34;words&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">               </span><span class="n">Path</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;/usr/share/dict/words&#34;</span><span class="p">));</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>  如果<code>path2</code>是一个绝对路径，这会简单地返回<code>path2</code>的拷贝，因此这个方法可以用于将任何路径转换为一个绝对路径：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">abs_path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">env</span>::<span class="n">current_dir</span><span class="p">()</span><span class="o">?</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">any_path</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><em><code>path.components()</code></em></p>
<p>  返回一个从左到右迭代给定路径的所有部分的迭代器。这个迭代器的item类型是<code>std::path::Component</code>，它可以代表任何可能出现在文件名中的部分：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">Component</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Prefix</span><span class="p">(</span><span class="n">PrefixComponent</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="p">),</span><span class="w">  </span><span class="c1">// 一个驱动器字母或者共享设备（在Windows上）
</span><span class="c1"></span><span class="w">        </span><span class="n">RootDir</span><span class="p">,</span><span class="w">            </span><span class="c1">// 根目录，`/`或`\`
</span><span class="c1"></span><span class="w">        </span><span class="n">CurDir</span><span class="p">,</span><span class="w">             </span><span class="c1">// `.`特殊目录
</span><span class="c1"></span><span class="w">        </span><span class="n">ParentDir</span><span class="p">,</span><span class="w">          </span><span class="c1">// `..`特殊目录
</span><span class="c1"></span><span class="w">        </span><span class="n">Normal</span><span class="p">(</span><span class="o">&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="n">OsStr</span><span class="p">)</span><span class="w">   </span><span class="c1">// 普通的文件和目录名
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>  例如，Windows路径 <em>\\venice\Music\A Love Supreme\04-Psalm.mp3</em> 由一个<code>Prefix</code>（表示 <em>\\venice\Music</em> ）、后跟一个<code>RootDir</code>，然后是两个<code>Normal</code>组件（分别是 <em>A Love Supreme</em> 和 <em>04-Psalm.mp3</em> ）组成。</p>
<p>  细节见<a href="https://doc.rust-lang.org/std/path/struct.Path.html#method.components">在线文档</a>。</p>
<p><em><code>path.ancestors()</code></em></p>
<p>  返回一个从<code>path</code>一直回溯到根目录的迭代器。每一个产生的item都是一个<code>Path</code>：第一个是<code>path</code>本身，然后是它的父目录、它的父目录的父目录，等等：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Path</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;/home/jimb/calendars/calendar-18x18.pdf&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">file</span><span class="p">.</span><span class="n">ancestors</span><span class="p">().</span><span class="n">collect</span>::<span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">(),</span><span class="w">
</span><span class="w">               </span><span class="fm">vec!</span><span class="p">[</span><span class="n">Path</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;/home/jimb/calendars/calendar-18x18.pdf&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">                    </span><span class="n">Path</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;/home/jimb/calendars&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">                    </span><span class="n">Path</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;/home/jimb&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">                    </span><span class="n">Path</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;/home&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">                    </span><span class="n">Path</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">)]);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>  这很像一直调用<code>parent</code>直到它返回<code>None</code>。最终的item总是一个根目录或者前缀路径。</p>
<p>这些方法只考虑内存中的字符串。<code>Path</code>还有一些会查询文件系统的方法：<code>.exists(), .is_file(), .is_dir(), .read_dir(), .canonicalize()</code>等等。更多内容请查阅在线文档。</p>
<p>有三个将<code>Path</code>转换为字符串的方法。每一个都允许<code>Path</code>中可能含有无效的UTF-8：</p>
<p><em><code>path.to_str()</code></em></p>
<p>  将一个<code>Path</code>转换成字符串，返回一个<code>Option&lt;&amp;str&gt;</code>。如果<code>path</code>不是有效的UTF-8，它返回<code>None</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">file_str</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">path</span><span class="p">.</span><span class="n">to_str</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">file_str</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">   </span><span class="c1">// ...否则跳过这个文件名
</span></code></pre></td></tr></table>
</div>
</div><p><em><code>path.to_string_lossy()</code></em></p>
<p>  这个方法功能基本和上面一样，但它在所有情况下都会返回字符串。如果<code>path</code>不是有效的UTF-8，这个方法会创建拷贝，然后将每一个无效的字节序列替换为Unicode占位字符：U+FFFD(&lsquo;�&rsquo;)。</p>
<p>  返回值类型是<code>std::borrow::Cow&lt;str&gt;</code>：可能是字符串的借用也可能是有所有权的字符串。为了从这个值得到一个<code>String</code>，使用它的<code>.to_owned()</code>方法。（更多有关<code>Cow</code>的内容，见“<code>Borrow</code>和<code>ToOwned</code>的配合：<code>Cow</code>”。）</p>
<p><em><code>path.display()</code></em></p>
<p>  这用于打印路径：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;Download found. You put it in: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">dir_path</span><span class="p">.</span><span class="n">display</span><span class="p">());</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>  它返回的值并不是字符串，但它实现了<code>std::fmt::Display</code>，所以它可以和<code>format!(), println!()</code>等一起使用。如果路径不是有效的UTF-8，输出可能会含有�字符。</p>
<h3 id="文件系统访问函数">文件系统访问函数</h3>
<p>”表18-2”展示了<code>std::fs</code>中的一些函数以及它们在Unix和Windows中的类似等价物。所有这些函数都返回<code>io::Result</code>值。除非特意提及，不然就是<code>io::Result&lt;()&gt;</code>。</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>Rust函数</strong></th>
<th><strong>Unix</strong></th>
<th><strong>Windows</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>创建和删除</td>
<td><code>create_dir(path)</code></td>
<td><code>mkdir()</code></td>
<td><code>CreateDirectory()</code></td>
</tr>
<tr>
<td>创建和删除</td>
<td><code>create_dir_all(path)</code></td>
<td>类似<code>mkdir -p</code></td>
<td>类似<code>mkdir</code></td>
</tr>
<tr>
<td>创建和删除</td>
<td><code>remove_dir(path)</code></td>
<td><code>rmdir()</code></td>
<td><code>RemoveDirectory()</code></td>
</tr>
<tr>
<td>创建和删除</td>
<td><code>remove_dir_all(path)</code></td>
<td>类似<code>rm -r</code></td>
<td>类似<code>rmdir /s</code></td>
</tr>
<tr>
<td>创建和删除</td>
<td><code>remove_file(path)</code></td>
<td><code>unlink()</code></td>
<td><code>DeleteFile()</code></td>
</tr>
<tr>
<td>拷贝，移动和链接</td>
<td><code>copy(src_path, dest_path) -&gt; Result&lt;u64&gt;</code></td>
<td>类似<code>cp -p</code></td>
<td><code>CopyFileEx()</code></td>
</tr>
<tr>
<td>拷贝，移动和链接</td>
<td><code>rename(src_path, dest_path)</code></td>
<td><code>rename()</code></td>
<td><code>MoveFileex()</code></td>
</tr>
<tr>
<td>拷贝，移动和链接</td>
<td><code>hard_link(src_path, dest_path)</code></td>
<td><code>link()</code></td>
<td><code>CreateHardLink()</code></td>
</tr>
<tr>
<td>检查</td>
<td><code>canonicalize(path) -&gt; Result&lt;PathBuf&gt;</code></td>
<td><code>realpath</code></td>
<td><code>GetFinalPathNameByHandle()</code></td>
</tr>
<tr>
<td>检查</td>
<td><code>metadata(path) -&gt; Result&lt;Metadata&gt;</code></td>
<td><code>stat()</code></td>
<td><code>GetFileInformationByHandle()</code></td>
</tr>
<tr>
<td>检查</td>
<td><code>symlink_metadata(path) -&gt; Result&lt;Metadata&gt;</code></td>
<td><code>lstat()</code></td>
<td><code>GetFileInformationByHandle()</code></td>
</tr>
<tr>
<td>检查</td>
<td><code>read_dir(path) -&gt; Result&lt;ReadDir&gt;</code></td>
<td><code>opendir()</code></td>
<td><code>FindFirstFile()</code></td>
</tr>
<tr>
<td>检查</td>
<td><code>read_link(path) -&gt; Result&lt;PathBuf&gt;</code></td>
<td><code>readlink()</code></td>
<td><code>FSCTL_GET_REPARSE_POINT</code></td>
</tr>
<tr>
<td>权限</td>
<td><code>set_permission(path, perm)</code></td>
<td><code>chmod()</code></td>
<td><code>SetFileAttributes()</code></td>
</tr>
</tbody>
</table>
<p>（<code>copy()</code>返回的数字是被拷贝的文件的大小，以字节为单位。有关创建符号链接，见“平台特定特性”。）</p>
<p>如你所见，Rust努力提供可以在Windows、macOS、Linux以及其他Unix系统上工作的可移植函数。</p>
<p>文件系统的完整说明超出了本书的范围，但如果你对这些函数中的某些更感兴趣，你可以在网上轻松地找到有关他们的更多信息。我们将在下一节中展示更多示例。</p>
<p>所有这些函数都是通过调用操作系统的功能来实现。例如<code>std::fs::canonicalize(path)</code>不只是使用字符串处理来消除给定的<code>path</code>中的<code>.</code>和<code>..</code> 。它使用当前的工作目录来解析相对路径，并且它会解析符号链接。如果路径不存在它会报错。</p>
<p><code>std::fs::metadata(path)</code>和<code>std::fs::symlink_metadata(path)</code>产生的<code>Metadata</code>类型包含类似于文件类型和大小、权限、时间戳等信息。同样，详细的内容请查阅文档。</p>
<p>为了方便，<code>Path</code>类型将一些这样的函数内建为方法：例如<code>path.metadata()</code>和<code>std::fs::metadata(path)是一样的。</code></p>
<h3 id="读取目录">读取目录</h3>
<p>可以使用<code>std::fs::read_dir</code>列出目录中的内容。或者等价的<code>Path</code>的<code>.read_dir()</code>方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">entry_result</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">path</span><span class="p">.</span><span class="n">read_dir</span><span class="p">()</span><span class="o">?</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">entry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">entry_result</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">entry</span><span class="p">.</span><span class="n">file_name</span><span class="p">().</span><span class="n">to_string_lossy</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>注意这段代码中<code>?</code>的两次使用。第一行的检查打开目录的错误。第二行的检查读取下一个条目的错误。</p>
<p><code>entry</code>的类型是<code>std::fs::DirEntry</code>，它有如下方法：</p>
<p><em><code>entry.file_name()</code></em></p>
<p>  文件或目录的名字，是一个<code>OsString</code>。</p>
<p><em><code>entry.path()</code></em></p>
<p>  和上面相同，但和原本的路径连接在一起，产生一个新的<code>PathBuf</code>。如果我们正在列出的目录是<code>&quot;/home/jimb&quot;</code>，并且<code>entry.file_name()</code>是<code>&quot;.emacs&quot;</code>，那么<code>entry.path()</code>将会返回<code>PathBuf::from(&quot;/home/jimb/.emacs&quot;)</code>。</p>
<p><em><code>entry.file_type()</code></em></p>
<p>  返回一个<code>io::Result&lt;FileType&gt;</code>。<code>FileType</code>类型有<code>.is_file()</code>、<code>.is_dir()</code>、<code>.is_symlink()</code>方法。</p>
<p><em><code>entry.metadata()</code></em></p>
<p>  获取这个条目的其他元数据。</p>
<p>在读取目录时特殊目录<code>.</code>和<code>..</code> <em>不会被</em> 列出。</p>
<p>这里还有另一个示例。下面的代码递归拷贝磁盘上的一个目录树：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">path</span>::<span class="n">Path</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="sd">/// 拷贝现有的目录`src`到目标路径`dst`
</span><span class="sd"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">copy_dir_to</span><span class="p">(</span><span class="n">src</span>: <span class="kp">&amp;</span><span class="nc">Path</span><span class="p">,</span><span class="w"> </span><span class="n">dst</span>: <span class="kp">&amp;</span><span class="nc">Path</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">dst</span><span class="p">.</span><span class="n">is_dir</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> 
</span><span class="w">            </span><span class="n">fs</span>::<span class="n">create_dir</span><span class="p">(</span><span class="n">dst</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">entry_result</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">src</span><span class="p">.</span><span class="n">read_dir</span><span class="p">()</span><span class="o">?</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">entry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">entry_result</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">file_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">entry</span><span class="p">.</span><span class="n">file_type</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="n">copy_to</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="p">.</span><span class="n">path</span><span class="p">(),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">file_type</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dst</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="n">file_name</span><span class="p">()))</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>用一个单独的函数<code>copy_to</code>来拷贝单独的目录项：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="sd">/// 拷贝`src`中的所有东西到目标路径`dst`。
</span><span class="sd"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">copy_to</span><span class="p">(</span><span class="n">src</span>: <span class="kp">&amp;</span><span class="nc">Path</span><span class="p">,</span><span class="w"> </span><span class="n">src_type</span>: <span class="kp">&amp;</span><span class="nc">fs</span>::<span class="n">FileType</span><span class="p">,</span><span class="w"> </span><span class="n">dst</span>: <span class="kp">&amp;</span><span class="nc">Path</span><span class="p">)</span><span class="w">
</span><span class="w">        </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">src_type</span><span class="p">.</span><span class="n">is_file</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">fs</span>::<span class="n">copy</span><span class="p">(</span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="n">dst</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">src_type</span><span class="p">.</span><span class="n">is_dir</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">copy_dir_to</span><span class="p">(</span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="n">dst</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">io</span>::<span class="n">Error</span>::<span class="n">new</span><span class="p">(</span><span class="n">io</span>::<span class="n">ErrorKind</span>::<span class="n">Other</span><span class="p">,</span><span class="w">
</span><span class="w">                                      </span><span class="fm">format!</span><span class="p">(</span><span class="s">&#34;don&#39;t know how to copy: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">src</span><span class="p">.</span><span class="n">display</span><span class="p">())));</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">                                                            
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="平台特定特性">平台特定特性</h3>
<p>到目前为止，我们的<code>copy_to</code>函数可以拷贝文件和目录。假设我们还想在Unix上支持符号链接。</p>
<p>目前并没有可移值的方式能创建同时在Unix和Windows上工作的符号链接，但标准库提供了一个Unix特定的<code>symlink</code>函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">os</span>::<span class="n">unix</span>::<span class="n">fs</span>::<span class="n">symlink</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>有了这个，我们的工作就变得很简单。我们只需要给<code>copy_to</code>里的<code>if</code>表达式添加一个分支：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">src_type</span><span class="p">.</span><span class="n">is_symlink</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">src</span><span class="p">.</span><span class="n">read_link</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="n">symlink</span><span class="p">(</span><span class="n">target</span><span class="p">,</span><span class="w"> </span><span class="n">dst</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="o">..</span><span class="p">.</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>只要我们在Unix系统例如Linux和macOS上编译程序，它就可以工作。</p>
<p><code>std::os</code>模块包含很多平台特定的特性，例如<code>symlink</code>。<code>std::os</code>在标准库中的实际内容看起来像这样（取得了许可）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="sd">//! OS特定的功能
</span><span class="sd"></span><span class="w">
</span><span class="w">    </span><span class="cp">#[cfg(unix)]</span><span class="w">                </span><span class="k">pub</span><span class="w"> </span><span class="k">mod</span> <span class="nn">unix</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="cp">#[cfg(windows)]</span><span class="w">             </span><span class="k">pub</span><span class="w"> </span><span class="k">mod</span> <span class="nn">windows</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="cp">#[cfg(target_os = </span><span class="s">&#34;ios&#34;</span><span class="cp">)]</span><span class="w">   </span><span class="k">pub</span><span class="w"> </span><span class="k">mod</span> <span class="nn">ios</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="cp">#[cfg(target_os = </span><span class="s">&#34;linux&#34;</span><span class="cp">)]</span><span class="w"> </span><span class="k">pub</span><span class="w"> </span><span class="k">mod</span> <span class="nn">linux</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="cp">#[cfg(target_os = </span><span class="s">&#34;macos&#34;</span><span class="cp">)]</span><span class="w"> </span><span class="k">pub</span><span class="w"> </span><span class="k">mod</span> <span class="nn">macos</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>#[cfg]</code>属性表示条件编译：这些模块中的每一个都只在特定平台上可用。这也是为什么我们的修改后使用了<code>std::os::unix</code>的程序在Unix上将会成功编译：在其他平台上，<code>std::os::unix</code>不存在。</p>
<p>如果我们想让我们的代码在所有平台上编译，并且支持Unix上的符号链接，我们必须在我们的程序中也使用<code>#[cfg]</code>。在这种情况下，最简单的方法是在Unix上时导入<code>symlink</code>，而在其它系统上定义我们自己的<code>symlink</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="cp">#[cfg(unix)]</span><span class="w">
</span><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">os</span>::<span class="n">unix</span>::<span class="n">fs</span>::<span class="n">symlink</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="sd">/// 为不支持`symlink`的平台的实现
</span><span class="sd"></span><span class="w">    </span><span class="cp">#[cfg(not(unix))]</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">symlink</span><span class="o">&lt;</span><span class="n">P</span>: <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">Q</span>: <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">src</span>: <span class="nc">P</span><span class="p">,</span><span class="w"> </span><span class="n">_dst</span>: <span class="nc">Q</span><span class="p">)</span><span class="w">
</span><span class="w">        </span>-&gt; <span class="nc">std</span>::<span class="n">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">io</span>::<span class="n">Error</span>::<span class="n">new</span><span class="p">(</span><span class="n">io</span>::<span class="n">ErrorKind</span>::<span class="n">Other</span><span class="p">,</span><span class="w">
</span><span class="w">                           </span><span class="fm">format!</span><span class="p">(</span><span class="s">&#34;can&#39;t copy symbolic link: {}&#34;</span><span class="p">,</span><span class="w"> 
</span><span class="w">                                   </span><span class="n">src</span><span class="p">.</span><span class="n">as_ref</span><span class="p">().</span><span class="n">display</span><span class="p">())))</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>事实证明<code>symlink</code>是一种特殊情况。大多数Unix特定的特性并不是单独的函数而是一些扩展的trait，它们为标准库类型添加了一些的方法（我们在“trait和其他人的类型”中介绍过扩展trait）。这里有一个可以一次性启用所有这些扩展的<code>prelude</code>模块：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">os</span>::<span class="n">unix</span>::<span class="n">prelude</span>::<span class="o">*</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>例如，在Unix上这会给<code>std::fs::Permissions</code>添加一个<code>.mode()</code>方法，它提供Unix上表示权限的底层<code>u32</code>值的访问。类似的，它还扩展了<code>std::fs::Metadata</code>，添加了一些访问底层的<code>struct stat</code>的字段的方法——例如<code>.uid()</code>返回文件所有者的ID。</p>
<p>总而言之，<code>std::os</code>中的内容非常基础。更多的平台特定功能通过第三方crate提供，例如<a href="https://crates.io/crates/winreg"><code>winreg</code></a>提供了访问Windows注册表的支持。</p>
<h2 id="网络">网络</h2>
<p>有关网络编程的教程超出了本书的范围。然而，如果你已经知道一些有关网络编程的知识，那么这一节可以帮助你在Rust中开始网络编程。</p>
<p>底层的网络编程需要使用<code>std::net</code>模块，它提供了TCP和UDP网络的跨平台支持。使用<code>native_tls</code> crate来提供SSL/TLS支持。</p>
<p>这些模块提供了通过网络的直观的、阻塞式的输入和输出。你可以通过<code>std::net</code>用很少的代码编写一个简单的服务器，为每一个连接创建一个线程。例如，这里有一个“echo”服务器：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">net</span>::<span class="n">TcpListener</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>:<span class="err">🧵</span>:<span class="nc">spawn</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="sd">/// 一直等待并接受连接，为每个连接新建一个线程处理。
</span><span class="sd"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">echo_main</span><span class="p">(</span><span class="n">addr</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">listener</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TcpListener</span>::<span class="n">bind</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;listening on {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="c1">// 等待客户端连接。
</span><span class="c1"></span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">listener</span><span class="p">.</span><span class="n">accept</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;connection received from {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">            </span><span class="c1">// 创建一个线程来服务这个客户端。
</span><span class="c1"></span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">write_stream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stream</span><span class="p">.</span><span class="n">try_clone</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="c1">// 把我们从`stream`接收到的所有内容写回。
</span><span class="c1"></span><span class="w">                </span><span class="n">io</span>::<span class="n">copy</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">write_stream</span><span class="p">)</span><span class="w">
</span><span class="w">                    </span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;error in client thread: &#34;</span><span class="p">);</span><span class="w">
</span><span class="w">                </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;connection closed&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">            </span><span class="p">});</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">echo_main</span><span class="p">(</span><span class="s">&#34;127.0.0.1:17007&#34;</span><span class="p">).</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;error: &#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>一个回声服务器简单地把你发送给它的数据返回。这些代码和你在Java或Python中编写的代码并没有多少不同。（我们将在”下一章”中介绍<code>std:🧵:spawn()</code>）</p>
<p>然而，对于高性能的服务器，你将需要使用异步的输入和输出。”第20章”会介绍Rust对异步编程的支持，并展示编写网络客户端和服务器的完整代码。</p>
<p>更高层的协议由第三方crate支持。例如，<code>reqwest</code> crate为HTTP客户端提供了一个漂亮的API。这里有一个完整的命令行程序获取<code>http:</code>或者<code>https:</code> URL的文档并输出到终端。这段代码使用<code>reqwest = &quot;0.11&quot;</code>编写，并启用了它的<code>&quot;blocking&quot;</code>特性。<code>reqwest</code>还提供了一套异步的接口。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">error</span>::<span class="n">Error</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">http_get_main</span><span class="p">(</span><span class="n">url</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// 发送HTTP请求并获取一个响应。
</span><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">response</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">reqwest</span>::<span class="n">blocking</span>::<span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">response</span><span class="p">.</span><span class="n">status</span><span class="p">().</span><span class="n">is_success</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="nb">Err</span><span class="p">(</span><span class="fm">format!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">response</span><span class="p">.</span><span class="n">status</span><span class="p">()))</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="c1">// 读取响应的body并写入到标准输出。
</span><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">stdout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io</span>::<span class="n">stdout</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">io</span>::<span class="n">copy</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">response</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">stdout</span><span class="p">.</span><span class="n">lock</span><span class="p">())</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">args</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">env</span>::<span class="n">args</span><span class="p">().</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="fm">eprintln!</span><span class="p">(</span><span class="s">&#34;usage: http-get URL&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">            </span><span class="k">return</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">http_get_main</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="fm">eprintln!</span><span class="p">(</span><span class="s">&#34;error: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>用于HTTP服务器的<code>actix-web</code>框架提供了更高层的特性，例如<code>Service</code>和<code>Transform</code> trait，它们可以帮助你通过可组合的部分构建一个app。<code>websocket</code> crate实现了WebSocket协议，等等。Rust是一门年轻的语言，有一个繁荣的开源生态系统。对网络的支持正在快速扩张。</p>

    </div>
<div class="post_comments">
  
  
  
</div>




    <hr>

<div id="gitalk-container"></div>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js" crossorigin="anonymous"></script>
    <script type="text/javascript">
      var gitalk = new Gitalk({
        id: '0001-01-01 00:00:00 \u002b0000 UTC',
        title: '',
        clientID: '72786bf87c19beec6abe',
        clientSecret: '93ce647699b49ea6434332d36b0122a4ad8281ad',
        repo: 'buf1024.github.io',
        owner: 'buf1024',
        admin: ['buf1024'],
        body: decodeURI(location.href)
      });
      gitalk.render('gitalk-container');
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/gitalk/gitalk">comments powered by gitalk.</a></noscript>

  </article>
<aside class="sidebar">
  <section class="sidebar_inner">
    <br>
    


    
    
    <h2 class="mt-4">最新文章</h2>
    <ul class="flex-column">
      <li>
        <a href="https://luoguochun.cn/post/2024-01-13-rust-sqlx-sqlbuilder/" class="nav-link" title="Rust sqlx SQLBuilder">Rust sqlx SQLBuilder</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2024-01-08-vite-engineering-config/" class="nav-link" title="前端工程化配置保姆级教程">前端工程化配置保姆级教程</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-12-26-rust-proc-macro/" class="nav-link" title="rust 过程宏">rust 过程宏</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-09-21-rust-panic/" class="nav-link" title="一行代码让 rustc panic">一行代码让 rustc panic</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-07-19-flutter-muti-window/" class="nav-link" title="Flutter 桌面端多窗口支持">Flutter 桌面端多窗口支持</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-07-04-hiqradio/" class="nav-link" title="hiqradio 一个简单的收音机软件">hiqradio 一个简单的收音机软件</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-03-21-android-https/" class="nav-link" title="android https 抓包">android https 抓包</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-03-16-love-for-insterest/" class="nav-link" title="为爱发电终是不能长久的……">为爱发电终是不能长久的……</a>
      </li>
    </ul>
    <div>
      <h2 class="mt-4 taxonomy" id="categories-section">分类</h2>
      <nav class="tags_nav">
        <a href='https://luoguochun.cn/categories/misc/' class="post_tag button button_translucent" title="misc">
          MISC
          <span class="button_tally">11</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/linux/' class="post_tag button button_translucent" title="linux">
          LINUX
          <span class="button_tally">8</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/tcp/' class="post_tag button button_translucent" title="tcp">
          TCP
          <span class="button_tally">8</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/c/' class="post_tag button button_translucent" title="c">
          C
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/flutter/' class="post_tag button button_translucent" title="flutter">
          FLUTTER
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/rust/' class="post_tag button button_translucent" title="rust">
          RUST
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/python/' class="post_tag button button_translucent" title="python">
          PYTHON
          <span class="button_tally">6</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/c&#43;&#43;/' class="post_tag button button_translucent" title="c&#43;&#43;">
          C&#43;&#43;
          <span class="button_tally">4</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/web/' class="post_tag button button_translucent" title="web">
          WEB
          <span class="button_tally">4</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/gcc/' class="post_tag button button_translucent" title="gcc">
          GCC
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/git/' class="post_tag button button_translucent" title="git">
          GIT
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/reactjs/' class="post_tag button button_translucent" title="reactjs">
          REACTJS
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/unittest/' class="post_tag button button_translucent" title="unittest">
          UNITTEST
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/vim/' class="post_tag button button_translucent" title="vim">
          VIM
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/%E6%9E%84%E6%9E%B6/' class="post_tag button button_translucent" title="构架">
          构架
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/asm/' class="post_tag button button_translucent" title="asm">
          ASM
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/docker/' class="post_tag button button_translucent" title="docker">
          DOCKER
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/go/' class="post_tag button button_translucent" title="go">
          GO
          <span class="button_tally">1</span>
        </a>
        
        
      </nav>
    </div>
    <div>
      <h2 class="mt-4 taxonomy" id="tags-section">标签</h2>
      <nav class="tags_nav">
        <a href='https://luoguochun.cn/tags/c/' class="post_tag button button_translucent" title="c">
          C
          <span class="button_tally">21</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/linux/' class="post_tag button button_translucent" title="linux">
          LINUX
          <span class="button_tally">16</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/c&#43;&#43;/' class="post_tag button button_translucent" title="c&#43;&#43;">
          C&#43;&#43;
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/python/' class="post_tag button button_translucent" title="python">
          PYTHON
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/tcp/' class="post_tag button button_translucent" title="tcp">
          TCP
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/dart/' class="post_tag button button_translucent" title="dart">
          DART
          <span class="button_tally">6</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/flutter/' class="post_tag button button_translucent" title="flutter">
          FLUTTER
          <span class="button_tally">6</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/rust/' class="post_tag button button_translucent" title="rust">
          RUST
          <span class="button_tally">4</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/tdd/' class="post_tag button button_translucent" title="tdd">
          TDD
          <span class="button_tally">4</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/android/' class="post_tag button button_translucent" title="android">
          ANDROID
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/git/' class="post_tag button button_translucent" title="git">
          GIT
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/gtest/' class="post_tag button button_translucent" title="gtest">
          GTEST
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/js/' class="post_tag button button_translucent" title="js">
          JS
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/rust-lib/' class="post_tag button button_translucent" title="rust-lib">
          RUST-LIB
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/vcs/' class="post_tag button button_translucent" title="vcs">
          VCS
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/vim/' class="post_tag button button_translucent" title="vim">
          VIM
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/asm/' class="post_tag button button_translucent" title="asm">
          ASM
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/css/' class="post_tag button button_translucent" title="css">
          CSS
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/gas/' class="post_tag button button_translucent" title="gas">
          GAS
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/gcc/' class="post_tag button button_translucent" title="gcc">
          GCC
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/http/' class="post_tag button button_translucent" title="http">
          HTTP
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/libevent/' class="post_tag button button_translucent" title="libevent">
          LIBEVENT
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/macos/' class="post_tag button button_translucent" title="macos">
          MACOS
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/react-native/' class="post_tag button button_translucent" title="react-native">
          REACT-NATIVE
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/redis/' class="post_tag button button_translucent" title="redis">
          REDIS
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/%E6%9E%84%E6%9E%B6/' class="post_tag button button_translucent" title="构架">
          构架
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/api/' class="post_tag button button_translucent" title="api">
          API
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/bt/' class="post_tag button button_translucent" title="bt">
          BT
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/c&#43;/' class="post_tag button button_translucent" title="c&#43;">
          C&#43;
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/coroutine/' class="post_tag button button_translucent" title="coroutine">
          COROUTINE
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/database/' class="post_tag button button_translucent" title="database">
          DATABASE
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/docker/' class="post_tag button button_translucent" title="docker">
          DOCKER
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/endian/' class="post_tag button button_translucent" title="endian">
          ENDIAN
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/frontend/' class="post_tag button button_translucent" title="frontend">
          FRONTEND
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/gdb/' class="post_tag button button_translucent" title="gdb">
          GDB
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/go/' class="post_tag button button_translucent" title="go">
          GO
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/html/' class="post_tag button button_translucent" title="html">
          HTML
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/https/' class="post_tag button button_translucent" title="https">
          HTTPS
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/jquery/' class="post_tag button button_translucent" title="jquery">
          JQUERY
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/ld/' class="post_tag button button_translucent" title="ld">
          LD
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/logger/' class="post_tag button button_translucent" title="logger">
          LOGGER
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/makefile/' class="post_tag button button_translucent" title="makefile">
          MAKEFILE
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/misc/' class="post_tag button button_translucent" title="misc">
          MISC
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/orm/' class="post_tag button button_translucent" title="orm">
          ORM
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/os/' class="post_tag button button_translucent" title="os">
          OS
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/process/' class="post_tag button button_translucent" title="process">
          PROCESS
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/react/' class="post_tag button button_translucent" title="react">
          REACT
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/rpm/' class="post_tag button button_translucent" title="rpm">
          RPM
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/rsa/' class="post_tag button button_translucent" title="rsa">
          RSA
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/server/' class="post_tag button button_translucent" title="server">
          SERVER
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/sqlalchemy/' class="post_tag button button_translucent" title="sqlalchemy">
          SQLALCHEMY
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/ssh/' class="post_tag button button_translucent" title="ssh">
          SSH
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/ssl/tls/' class="post_tag button button_translucent" title="ssl/tls">
          SSL/TLS
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/vc/' class="post_tag button button_translucent" title="vc">
          VC
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/vite/' class="post_tag button button_translucent" title="vite">
          VITE
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/vue/' class="post_tag button button_translucent" title="vue">
          VUE
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/webui/' class="post_tag button button_translucent" title="webui">
          WEBUI
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/wechat/' class="post_tag button button_translucent" title="wechat">
          WECHAT
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/win32/' class="post_tag button button_translucent" title="win32">
          WIN32
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/windows/' class="post_tag button button_translucent" title="windows">
          WINDOWS
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/wireshark/' class="post_tag button button_translucent" title="wireshark">
          WIRESHARK
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/' class="post_tag button button_translucent" title="微服务">
          微服务
          <span class="button_tally">1</span>
        </a>
        
        
      </nav>
    </div>
  </section>
</aside>

  
</div>
  </main><svg width="0" height="0" class="hidden">
  <symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="facebook">
    <path d="M437 0H75C33.648 0 0 33.648 0 75v362c0 41.352 33.648 75 75 75h151V331h-60v-90h60v-61c0-49.629 40.371-90 90-90h91v90h-91v61h91l-15 90h-76v181h121c41.352 0 75-33.648 75-75V75c0-41.352-33.648-75-75-75zm0 0"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18.001 18.001" id="twitter">
    <path d="M15.891 4.013c.808-.496 1.343-1.173 1.605-2.034a8.68 8.68 0 0 1-2.351.861c-.703-.756-1.593-1.14-2.66-1.14-1.043 0-1.924.366-2.643 1.078a3.56 3.56 0 0 0-1.076 2.605c0 .309.039.585.117.819-3.076-.105-5.622-1.381-7.628-3.837-.34.601-.51 1.213-.51 1.846 0 1.301.549 2.332 1.645 3.089-.625-.053-1.176-.211-1.645-.47 0 .929.273 1.705.82 2.388a3.623 3.623 0 0 0 2.115 1.291c-.312.08-.641.118-.979.118-.312 0-.533-.026-.664-.083.23.757.664 1.371 1.291 1.841a3.652 3.652 0 0 0 2.152.743C4.148 14.173 2.625 14.69.902 14.69c-.422 0-.721-.006-.902-.038 1.697 1.102 3.586 1.649 5.676 1.649 2.139 0 4.029-.542 5.674-1.626 1.645-1.078 2.859-2.408 3.639-3.974a10.77 10.77 0 0 0 1.172-4.892v-.468a7.788 7.788 0 0 0 1.84-1.921 8.142 8.142 0 0 1-2.11.593z"
      ></path>
  </symbol>
  <symbol aria-hidden="true" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="mail">
    <path  d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="calendar">
    <path d="M452 40h-24V0h-40v40H124V0H84v40H60C26.916 40 0 66.916 0 100v352c0 33.084 26.916 60 60 60h392c33.084 0 60-26.916 60-60V100c0-33.084-26.916-60-60-60zm20 412c0 11.028-8.972 20-20 20H60c-11.028 0-20-8.972-20-20V188h432v264zm0-304H40v-48c0-11.028 8.972-20 20-20h24v40h40V80h264v40h40V80h24c11.028 0 20 8.972 20 20v48z"></path>
    <path d="M76 230h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zM76 310h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zM76 390h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zm80-80h40v40h-40z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="github">
    <path d="M255.968 5.329C114.624 5.329 0 120.401 0 262.353c0 113.536 73.344 209.856 175.104 243.872 12.8 2.368 17.472-5.568 17.472-12.384 0-6.112-.224-22.272-.352-43.712-71.2 15.52-86.24-34.464-86.24-34.464-11.616-29.696-28.416-37.6-28.416-37.6-23.264-15.936 1.728-15.616 1.728-15.616 25.696 1.824 39.2 26.496 39.2 26.496 22.848 39.264 59.936 27.936 74.528 21.344 2.304-16.608 8.928-27.936 16.256-34.368-56.832-6.496-116.608-28.544-116.608-127.008 0-28.064 9.984-51.008 26.368-68.992-2.656-6.496-11.424-32.64 2.496-68 0 0 21.504-6.912 70.4 26.336 20.416-5.696 42.304-8.544 64.096-8.64 21.728.128 43.648 2.944 64.096 8.672 48.864-33.248 70.336-26.336 70.336-26.336 13.952 35.392 5.184 61.504 2.56 68 16.416 17.984 26.304 40.928 26.304 68.992 0 98.72-59.84 120.448-116.864 126.816 9.184 7.936 17.376 23.616 17.376 47.584 0 34.368-.32 62.08-.32 70.496 0 6.88 4.608 14.88 17.6 12.352C438.72 472.145 512 375.857 512 262.353 512 120.401 397.376 5.329 255.968 5.329z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 212 212" id="gitlab">
    <path d="M12.3 74.7h54L43.3 3c-1-3.6-6.4-3.6-7.6 0L12.3 74.8z" />
    <path d="M12.3 74.7L.5 111c-1 3.2 0 6.8 3 8.8l101.6 74-92.5-119z"/>
    <path d="M105 193.7l-38.6-119h-54l92.7 119z"/>
    <path d="M105 193.7l38.7-119H66.4l38.7 119z"/>
    <path d="M105 193.7l38.7-119H198l-93 119z"/>
    <path d="M198 74.7l11.6 36.2c1 3 0 6.6-3 8.6l-101.5 74 93-119z"/>
    <path d="M198 74.7h-54.3L167 3c1.2-3.6 6.4-3.6 7.6 0L198 74.8z"/>
  </symbol>
  <symbol viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="rss">
    <circle cx="3.429" cy="20.571" r="3.429"></circle>
    <path d="M11.429 24h4.57C15.999 15.179 8.821 8.001 0 8v4.572c6.302.001 11.429 5.126 11.429 11.428z"></path>
    <path d="M24 24C24 10.766 13.234 0 0 0v4.571c10.714 0 19.43 8.714 19.43 19.429z"></path>
  </symbol>
  <symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="linkedin">
    <path d="M437 0H75C33.648 0 0 33.648 0 75v362c0 41.352 33.648 75 75 75h362c41.352 0 75-33.648 75-75V75c0-41.352-33.648-75-75-75zM181 406h-60V196h60zm0-240h-60v-60h60zm210 240h-60V286c0-16.54-13.46-30-30-30s-30 13.46-30 30v120h-60V196h60v11.309C286.719 202.422 296.93 196 316 196c40.691.043 75 36.547 75 79.688zm0 0"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 612 612" id="to-top">
    <path d="M604.501 440.509L325.398 134.956c-5.331-5.357-12.423-7.627-19.386-7.27-6.989-.357-14.056 1.913-19.387 7.27L7.499 440.509c-9.999 10.024-9.999 26.298 0 36.323s26.223 10.024 36.222 0l262.293-287.164L568.28 476.832c9.999 10.024 26.222 10.024 36.221 0 9.999-10.023 9.999-26.298 0-36.323z"></path>
  </symbol>
  <symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="carly">
    <path d="M504.971 239.029L448 182.059V84c0-46.317-37.682-84-84-84h-44c-13.255 0-24 10.745-24 24s10.745 24 24 24h44c19.851 0 36 16.149 36 36v108c0 6.365 2.529 12.47 7.029 16.971L454.059 256l-47.029 47.029A24.002 24.002 0 0 0 400 320v108c0 19.851-16.149 36-36 36h-44c-13.255 0-24 10.745-24 24s10.745 24 24 24h44c46.318 0 84-37.683 84-84v-98.059l56.971-56.971c9.372-9.372 9.372-24.568 0-33.941zM112 192V84c0-19.851 16.149-36 36-36h44c13.255 0 24-10.745 24-24S205.255 0 192 0h-44c-46.318 0-84 37.683-84 84v98.059l-56.971 56.97c-9.373 9.373-9.373 24.568 0 33.941L64 329.941V428c0 46.317 37.682 84 84 84h44c13.255 0 24-10.745 24-24s-10.745-24-24-24h-44c-19.851 0-36-16.149-36-36V320c0-6.365-2.529-12.47-7.029-16.971L57.941 256l47.029-47.029A24.002 24.002 0 0 0 112 192z"></path>
  </symbol>
  <symbol viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="copy">
    <path d="M23 2.75A2.75 2.75 0 0 0 20.25 0H8.75A2.75 2.75 0 0 0 6 2.75v13.5A2.75 2.75 0 0 0 8.75 19h11.5A2.75 2.75 0 0 0 23 16.25zM18.25 14.5h-7.5a.75.75 0 0 1 0-1.5h7.5a.75.75 0 0 1 0 1.5zm0-3h-7.5a.75.75 0 0 1 0-1.5h7.5a.75.75 0 0 1 0 1.5zm0-3h-7.5a.75.75 0 0 1 0-1.5h7.5a.75.75 0 0 1 0 1.5z"></path>
    <path d="M8.75 20.5a4.255 4.255 0 0 1-4.25-4.25V2.75c0-.086.02-.166.025-.25H3.75A2.752 2.752 0 0 0 1 5.25v16A2.752 2.752 0 0 0 3.75 24h12a2.752 2.752 0 0 0 2.75-2.75v-.75z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512.001 512.001" id="closeme">
    <path d="M284.286 256.002L506.143 34.144c7.811-7.811 7.811-20.475 0-28.285-7.811-7.81-20.475-7.811-28.285 0L256 227.717 34.143 5.859c-7.811-7.811-20.475-7.811-28.285 0-7.81 7.811-7.811 20.475 0 28.285l221.857 221.857L5.858 477.859c-7.811 7.811-7.811 20.475 0 28.285a19.938 19.938 0 0 0 14.143 5.857 19.94 19.94 0 0 0 14.143-5.857L256 284.287l221.857 221.857c3.905 3.905 9.024 5.857 14.143 5.857s10.237-1.952 14.143-5.857c7.811-7.811 7.811-20.475 0-28.285L284.286 256.002z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="open-menu">
    <path d="M492 236H20c-11.046 0-20 8.954-20 20s8.954 20 20 20h472c11.046 0 20-8.954 20-20s-8.954-20-20-20zm0-160H20C8.954 76 0 84.954 0 96s8.954 20 20 20h472c11.046 0 20-8.954 20-20s-8.954-20-20-20zm0 320H20c-11.046 0-20 8.954-20 20s8.954 20 20 20h472c11.046 0 20-8.954 20-20s-8.954-20-20-20z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="instagram">
    <path d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948 0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072 3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.163 6.162 6.163 6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zm0 10.162c-2.209 0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796 0-1.441.645-1.441 1.44s.645 1.44 1.441 1.44c.795 0 1.439-.645 1.439-1.44s-.644-1.44-1.439-1.44z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id=youtube>
    <path d="M19.615 3.184c-3.604-.246-11.631-.245-15.23 0-3.897.266-4.356 2.62-4.385 8.816.029 6.185.484 8.549 4.385 8.816 3.6.245 11.626.246 15.23 0 3.897-.266 4.356-2.62 4.385-8.816-.029-6.185-.484-8.549-4.385-8.816zm-10.615 12.816v-8l8 3.993-8 4.007z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="stackoverflow">
    <path d="M21 27v-8h3v11H0V19h3v8h18z"></path><path d="M17.1.2L15 1.8l7.9 10.6 2.1-1.6L17.1.2zm3.7 14.7L10.6 6.4l1.7-2 10.2 8.5-1.7 2zM7.2 12.3l12 5.6 1.1-2.4-12-5.6-1.1 2.4zm-1.8 6.8l13.56 1.96.17-2.38-13.26-2.55-.47 2.97zM19 25H5v-3h14v3z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="xing">
    <path d="M18.188 0c-.517 0-.741.325-.927.66 0 0-7.455 13.224-7.702 13.657.015.024 4.919 9.023 4.919 9.023.17.308.436.66.967.66h3.454c.211 0 .375-.078.463-.22.089-.151.089-.346-.009-.536l-4.879-8.916c-.004-.006-.004-.016 0-.022L22.139.756c.095-.191.097-.387.006-.535C22.056.078 21.894 0 21.686 0h-3.498zM3.648 4.74c-.211 0-.385.074-.473.216-.09.149-.078.339.02.531l2.34 4.05c.004.01.004.016 0 .021L1.86 16.051c-.099.188-.093.381 0 .529.085.142.239.234.45.234h3.461c.518 0 .766-.348.945-.667l3.734-6.609-2.378-4.155c-.172-.315-.434-.659-.962-.659H3.648v.016z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 71 55" id="discord">
    <path d="M60.1045 4.8978C55.5792 2.8214 50.7265 1.2916 45.6527 0.41542C45.5603 0.39851 45.468 0.440769 45.4204 0.525289C44.7963 1.6353 44.105 3.0834 43.6209 4.2216C38.1637 3.4046 32.7345 3.4046 27.3892 4.2216C26.905 3.0581 26.1886 1.6353 25.5617 0.525289C25.5141 0.443589 25.4218 0.40133 25.3294 0.41542C20.2584 1.2888 15.4057 2.8186 10.8776 4.8978C10.8384 4.9147 10.8048 4.9429 10.7825 4.9795C1.57795 18.7309 -0.943561 32.1443 0.293408 45.3914C0.299005 45.4562 0.335386 45.5182 0.385761 45.5576C6.45866 50.0174 12.3413 52.7249 18.1147 54.5195C18.2071 54.5477 18.305 54.5139 18.3638 54.4378C19.7295 52.5728 20.9469 50.6063 21.9907 48.5383C22.0523 48.4172 21.9935 48.2735 21.8676 48.2256C19.9366 47.4931 18.0979 46.6 16.3292 45.5858C16.1893 45.5041 16.1781 45.304 16.3068 45.2082C16.679 44.9293 17.0513 44.6391 17.4067 44.3461C17.471 44.2926 17.5606 44.2813 17.6362 44.3151C29.2558 49.6202 41.8354 49.6202 53.3179 44.3151C53.3935 44.2785 53.4831 44.2898 53.5502 44.3433C53.9057 44.6363 54.2779 44.9293 54.6529 45.2082C54.7816 45.304 54.7732 45.5041 54.6333 45.5858C52.8646 46.6197 51.0259 47.4931 49.0921 48.2228C48.9662 48.2707 48.9102 48.4172 48.9718 48.5383C50.038 50.6034 51.2554 52.5699 52.5959 54.435C52.6519 54.5139 52.7526 54.5477 52.845 54.5195C58.6464 52.7249 64.529 50.0174 70.6019 45.5576C70.6551 45.5182 70.6887 45.459 70.6943 45.3942C72.1747 30.0791 68.2147 16.7757 60.1968 4.9823C60.1772 4.9429 60.1437 4.9147 60.1045 4.8978ZM23.7259 37.3253C20.2276 37.3253 17.3451 34.1136 17.3451 30.1693C17.3451 26.225 20.1717 23.0133 23.7259 23.0133C27.308 23.0133 30.1626 26.2532 30.1066 30.1693C30.1066 34.1136 27.28 37.3253 23.7259 37.3253ZM47.3178 37.3253C43.8196 37.3253 40.9371 34.1136 40.9371 30.1693C40.9371 26.225 43.7636 23.0133 47.3178 23.0133C50.9 23.0133 53.7545 26.2532 53.6986 30.1693C53.6986 34.1136 50.9 37.3253 47.3178 37.3253Z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 17 18" id="mastodon">
    <path
    fill="#ffffff"
    d="m 15.054695,9.8859583 c -0.22611,1.1632697 -2.02517,2.4363497 -4.09138,2.6830797 -1.0774504,0.12856 -2.1382704,0.24673 -3.2694704,0.19484 -1.84996,-0.0848 -3.30971,-0.44157 -3.30971,-0.44157 0,0.1801 0.0111,0.35157 0.0333,0.51194 0.24051,1.82571 1.81034,1.93508 3.29737,1.98607 1.50088,0.0514 2.8373104,-0.37004 2.8373104,-0.37004 l 0.0617,1.35686 c 0,0 -1.0498104,0.56374 -2.9199404,0.66742 -1.03124,0.0567 -2.3117,-0.0259 -3.80308,-0.42069 -3.23454998,-0.85613 -3.79081998,-4.304 -3.87592998,-7.8024197 -0.026,-1.03871 -0.01,-2.01815 -0.01,-2.83732 0,-3.57732 2.34385998,-4.62587996 2.34385998,-4.62587996 1.18184,-0.54277 3.20976,-0.77101 5.318,-0.7882499985409 h 0.0518 C 9.8267646,0.01719834 11.856025,0.24547834 13.037775,0.78824834 c 0,0 2.34377,1.04855996 2.34377,4.62587996 0,0 0.0294,2.63937 -0.32687,4.47183"/>
 <path
    fill="#000000"
    d="m 12.616925,5.6916583 v 4.3315297 h -1.71607 V 5.8189683 c 0,-0.88624 -0.37289,-1.33607 -1.1187604,-1.33607 -0.82467,0 -1.23799,0.53361 -1.23799,1.58875 v 2.30122 h -1.70594 v -2.30122 c 0,-1.05514 -0.4134,-1.58875 -1.23808,-1.58875 -0.74587,0 -1.11876,0.44983 -1.11876,1.33607 v 4.2042197 h -1.71607 V 5.6916583 c 0,-0.88527 0.22541,-1.58876 0.67817,-2.10922 0.46689,-0.52047 1.07833,-0.78727 1.83735,-0.78727 0.87816,0 1.54317,0.33752 1.98288,1.01267 l 0.42744,0.71655 0.42753,-0.71655 c 0.43961,-0.67515 1.10463,-1.01267 1.9828704,-1.01267 0.75893,0 1.37037,0.2668 1.83735,0.78727 0.45268,0.52046 0.67808,1.22395 0.67808,2.10922"/>
  </symbol>
</svg>

<footer class="footer">
  <div class="footer_inner wrap pale">
    <img src='https://luoguochun.cn/icons/apple-touch-icon.png' class="icon icon_2 transparent" alt="BUF1024">
    <p>Copyright&nbsp;2011-&nbsp;<span class="year"></span>&nbsp;BUF1024. All Rights Reserved</p><a class="to_top" href="#documentTop">
  <svg class="icon">
  <title>to-top</title>
  <use xlink:href="#to-top"></use>
</svg>

</a>

  </div>
</footer>

<script type="text/javascript" src="https://luoguochun.cn/zh-cn/js/bundle.884eccc71c2848fb4aeb15945329b5a857717f0313da00cb46b765b5734cfa64b08ce2609627167129c2de17d9b47ed210682f96a2502ebb3aadc73191740211.js" integrity="sha512-iE7MxxwoSPtK6xWUUym1qFdxfwMT2gDLRrdltXNM&#43;mSwjOJglicWcSnC3hfZtH7SEGgvlqJQLrs6rccxkXQCEQ==" crossorigin="anonymous"></script>
</body>

</html>
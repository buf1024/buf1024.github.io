
<!DOCTYPE html>
<html lang="zh-cn" data-figures=""  class="page"   >

<head>
<title>BUF1024</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">





<meta property="og:locale" content="zh-cn" />

<meta property="og:type" content="article">
<meta name="description" content="宏 A cento (from the Latin for “patchwork”) is a poem made up entirely of lines quoted from another poet. ——Matt Madden Rust支持 宏(macros) ，这是一种普通函数无法做到的扩展语" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:creator" content="">
<meta name="twitter:title" content="" />
<meta name="twitter:image" content="https://luoguochun.cn"/>
<meta property="og:url" content="https://luoguochun.cn/prust/ch21/" />
<meta property="og:title" content="" />
<meta property="og:description" content="宏 A cento (from the Latin for “patchwork”) is a poem made up entirely of lines quoted from another poet. ——Matt Madden Rust支持 宏(macros) ，这是一种普通函数无法做到的扩展语" />
<meta property="og:image" content="https://luoguochun.cn" />
  <meta name="keywords" content="blog,computer,luoguochun" />

<link rel="apple-touch-icon" sizes="180x180" href="https://luoguochun.cn/icons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://luoguochun.cn/icons/favicon-32x32.png">
<link rel="manifest" href="https://luoguochun.cn/icons/site.webmanifest">

<link rel="canonical" href="https://luoguochun.cn/prust/ch21/">



<link rel="preload" href="https://luoguochun.cn/css/styles.42e2c5f6d8cf9c52872666f8d8b2678ad0c426978b9d78aff3c33b7a1e7f6f97f54bcdaf0518a25fb0fe26367d04f8b07c683b3b38b331cb098daadee06b1f3e.css" integrity = "sha512-QuLF9tjPnFKHJmb42LJnitDEJpeLnXiv88M7eh5/b5f1S82vBRiiX7D&#43;JjZ9BPiwfGg7OzizMcsJjare4GsfPg==" as="style" crossorigin="anonymous">



<link rel="preload" href="https://luoguochun.cn/zh-cn/js/bundle.884eccc71c2848fb4aeb15945329b5a857717f0313da00cb46b765b5734cfa64b08ce2609627167129c2de17d9b47ed210682f96a2502ebb3aadc73191740211.js" as="script" integrity=
"sha512-iE7MxxwoSPtK6xWUUym1qFdxfwMT2gDLRrdltXNM&#43;mSwjOJglicWcSnC3hfZtH7SEGgvlqJQLrs6rccxkXQCEQ==" crossorigin="anonymous">


<link rel="stylesheet" type="text/css" href="https://luoguochun.cn/css/styles.42e2c5f6d8cf9c52872666f8d8b2678ad0c426978b9d78aff3c33b7a1e7f6f97f54bcdaf0518a25fb0fe26367d04f8b07c683b3b38b331cb098daadee06b1f3e.css" integrity="sha512-QuLF9tjPnFKHJmb42LJnitDEJpeLnXiv88M7eh5/b5f1S82vBRiiX7D&#43;JjZ9BPiwfGg7OzizMcsJjare4GsfPg==" crossorigin="anonymous">

</head>

<body data-code="100" data-lines="false" id="documentTop"
  data-lang="zh-cn">

<header class="nav_header" >
  <nav class="nav"><a href='https://luoguochun.cn' class="nav_brand nav_item" title="BUF1024">BUF1024
  <div class="nav_close">
    <div><svg class="icon">
  <title>open-menu</title>
  <use xlink:href="#open-menu"></use>
</svg>
<svg class="icon">
  <title>closeme</title>
  <use xlink:href="#closeme"></use>
</svg>
</div>
  </div>
</a>

    <div class='nav_body nav_body_left'>
      
      
      
        

  <div class="nav_parent">
    <a href="https://luoguochun.cn/" class="nav_item" title="主页">主页 </a>
  </div>
  <div class="nav_parent">
    <a href="https://luoguochun.cn" class="nav_item" title="链接">链接 <img src='https://luoguochun.cn/icons/caret-icon.svg' alt="icon" class="nav_icon"></a>
    <div class="nav_sub">
      <span class="nav_child"></span>
        <a href="https://luoguochun.cn/talib-doc/" class="nav_child nav_item" title="TA 技术分析库">TA 技术分析库</a>
        <a href="https://luoguochun.cn/hiqradio" class="nav_child nav_item" title="hiqadio网络收音机">hiqadio网络收音机</a>
    </div>
  </div>
  <div class="nav_parent">
    <a href="https://luoguochun.cn/about/" class="nav_item" title="关于">关于 </a>
  </div>
      
<div class='follow'>
<div class="color_mode">
  <input type="checkbox" class="color_choice" id="mode">
</div>

</div>

    </div>
  </nav>
</header>

  <main>
  
<div class="grid-inverse wrap content">
  <article class="post_content">
    <h1 class="post_title"></h1>
  <div class="post_meta">
    <span><svg class="icon">
  <title>calendar</title>
  <use xlink:href="#calendar"></use>
</svg>
</span>
    <span class="post_date">
      Jan 1, 0001</span>
    <span class="post_time"> · 28 min read</span>
    <span class="page_only">&nbsp;·
  <div class="post_share">
    分享到:
    <a href="https://twitter.com/intent/tweet?text=&url=https%3a%2f%2fluoguochun.cn%2fprust%2fch21%2f&tw_p=tweetbutton" class="twitter" title="分享到 Twitter" target="_blank" rel="nofollow">
      <svg class="icon">
  <title>twitter</title>
  <use xlink:href="#twitter"></use>
</svg>

    </a>
    <a href="https://www.facebook.com/sharer.php?u=https%3a%2f%2fluoguochun.cn%2fprust%2fch21%2f&t=" class="facebook" title="分享到 Facebook" target="_blank" rel="nofollow">
      <svg class="icon">
  <title>facebook</title>
  <use xlink:href="#facebook"></use>
</svg>

    </a>
    <a href="#linkedinshare" id = "linkedinshare" class="linkedin" title="分享到 LinkedIn" rel="nofollow">
      <svg class="icon">
  <title>linkedin</title>
  <use xlink:href="#linkedin"></use>
</svg>

    </a>
    <a href="https://luoguochun.cn/prust/ch21/" title="Copy Link" class="link link_yank">
      <svg class="icon">
  <title>copy</title>
  <use xlink:href="#copy"></use>
</svg>

    </a>
  </div>
  </span>
  </div>

    <div class="post_body"><h1 id="宏">宏</h1>
<p><em>A cento (from the Latin for “patchwork”) is a poem made up entirely of lines quoted from another poet.</em></p>
<p align="right">
    ——Matt Madden
</p>
<p>Rust支持 <em>宏(macros)</em> ，这是一种普通函数无法做到的扩展语言的方式。例如，我们已经看到过<code>assert_eq!</code>宏，它可以方便地用来测试：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">gcd</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">),</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这也可以写成一个泛型函数，但<code>assert_eq!</code>可以做到几件函数做不到的事。其中一点是当断言失败时，<code>assert_eq!</code>会生成包含断言所在的文件名和行号的错误消息。函数没有办法获得这些信息，但宏可以，因为它们工作的方式完全不同。</p>
<p>宏是一种缩写。编译期间在类型检查之前、更在生成任何机器码之前，每一个宏调用都会被 <em>展开(expand)</em> ——即被替换为一些Rust代码。上面的宏调用会展开成类似这样的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">gcd</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="n">left_val</span><span class="p">,</span><span class="w"> </span><span class="n">right_val</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">left_val</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">*</span><span class="n">right_val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="fm">panic!</span><span class="p">(</span><span class="err">&#34;</span><span class="n">assertion</span><span class="w"> </span><span class="n">failed</span>: <span class="err">`</span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="err">`</span><span class="p">,</span><span class="w"> </span><span class="err">\</span><span class="w">
</span><span class="w">                        </span><span class="p">(</span><span class="n">left</span>: <span class="err">`</span><span class="p">{</span>:<span class="o">?</span><span class="p">}</span><span class="err">`</span><span class="p">,</span><span class="w"> </span><span class="n">right</span>: <span class="err">`</span><span class="p">{</span>:<span class="o">?</span><span class="p">}</span><span class="err">`</span><span class="p">)</span><span class="err">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">left_val</span><span class="p">,</span><span class="w"> </span><span class="n">right_val</span><span class="p">));</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>panic!</code>也是一个宏，它自己会展开成更多Rust代码（这里没有展示）。那些代码里用到了两个别的宏：<code>file!()</code>和<code>line!()</code>。一旦crate中的每一个宏调用都被完全展开，Rust会进入编译的下一个阶段。</p>
<p>在运行时，一个断言失败看起来像这样（并且可能指示<code>gcd()</code>函数中的一个bug，因为<code>2</code>是正确结果）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">    thread &#39;main&#39; panicked at &#39;assertion failed: `(left == right)`, (left: `17`,
    right: `2`)&#39;, gcd.rs:7
</code></pre></td></tr></table>
</div>
</div><p>如果你是从C++来的，你可能经历过一些宏的糟糕体验。Rust的宏采用了一种不同的方式，类似于Scheme的<code>syntax-rules</code>。相比于C++的宏，Rust的宏和语言的其他部分集成得更好，并且因此更不容易出错。宏调用总是用感叹号标记，这样当你阅读代码时它们会很显眼，并且不会在你想调用函数时偶然错误地调用成了宏。Rust的宏从来不会插入不匹配的花括号或圆括号。并且Rust的宏带有模式匹配，这使得编写既可维护又易于使用的宏变得更容易。</p>
<p>在本章中，我们将通过几个简单的示例展示如何编写宏。但和Rust中的很多部分一样，宏值得深入理解，所以我们将介绍一个更复杂的宏的设计，它允许我们直接在我们的程序中嵌入JSON字面量。但除了本书中介绍的部分之外，宏还有更多的内容。因此我们将以一些进一步学习的点结束，既有我们将在这里向你展示的高级技巧，也有功能更强大的被称为 <em>过程宏(procedural macros)</em> 的设施。</p>
<h2 id="宏基础">宏基础</h2>
<p>”图21-1”展示了<code>assert_eq!</code>宏的部分源码。</p>
<p><figure>
  <picture>

    
      
        
        
        
        
        
        
    <img
      loading="lazy"
      decoding="async"
      alt="&amp;lt;code&amp;gt;assert_eq!&amp;lt;/code&amp;gt;宏"
      
        class="image_figure image_internal image_unprocessed"
        src="../img/f21-1.png"
      
      
    />

    </picture>
</figure>
</p>
<p align="center">图21-1 <code>assert_eq!</code>宏</p>
<p><code>macro_rules!</code>是Rust中定义宏的主要方法。注意，宏定义里<code>assert_eq</code>后边没有<code>!</code>：只有在调用宏时才需要<code>!</code>，定义时不需要。</p>
<p>并不是所有的宏都是以这种方式定义的：少数的宏，例如<code>file!</code>、<code>line!</code>和<code>macro_rules!</code>自身，是编译器内建的。我们将在本章的末尾讨论另一种方法，称为过程宏。但我们的主要精力还是集中在<code>macro_rules!</code>，这是（目前为止）最容易的编写自己的宏的方法。</p>
<p>一个用<code>macro_rules!</code>定义的宏完全靠模式匹配工作。宏的主体只是一系列规则：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">    ( pattern1 ) =&gt; ( template1 );
    ( pattern2 ) =&gt; ( template2 );
    ...
</code></pre></td></tr></table>
</div>
</div><p>”图21-1”中的<code>assert_eq!</code>版本只有一个模式和一个模板。</p>
<p>顺带一提，你可以使用方括号或者花括号来代替模式或模板两侧的圆括号，对Rust来说它们并没有任何区别。另外，当你调用一个宏时，这些都是等价的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">gcd</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">),</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">[</span><span class="n">gcd</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">),</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">{</span><span class="n">gcd</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">),</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>唯一的不同是花括号后边的分号是可选的。为了方便，我们在调用<code>assert_eq!</code>时使用圆括号，调用<code>vec!</code>时使用方括号，<code>macro_rules!</code>时使用花括号。</p>
<p>现在我们展示了一个宏展开的简单示例和生成这个宏的定义，我们可以深入了解它工作的细节：</p>
<ul>
<li>我们将详细地解释Rust是怎么发现和展开你的程序中的宏定义的。</li>
<li>我们将指出在根据宏模板生成代码时的一些细节之处。</li>
<li>最后，我们将展示模式如何处理重复的结构。</li>
</ul>
<h3 id="宏展开基础">宏展开基础</h3>
<p>Rust会在编译的前期展开宏。编译器会从头到尾读取源码，在这个过程中定义和展开宏。宏只有在定义之后才能被调用，因为Rust会立刻展开每一个宏调用，而不会去看程序的剩余部分。（相反，函数和其他的”item”的定义不需要按照任何顺序。调用一个后面才定义的函数也是OK的。）</p>
<p>当Rust展开一个<code>assert_eq!</code>宏调用时，行为和执行一个<code>match</code>表达式非常像。Rust首先根据模式匹配参数，如”图21-2”所示：</p>
<p><figure>
  <picture>

    
      
        
        
        
        
        
        
    <img
      loading="lazy"
      decoding="async"
      alt="展开一个宏，第1部分：用模式匹配参数"
      
        class="image_figure image_internal image_unprocessed"
        src="../img/f21-2.png"
      
      
    />

    </picture>
</figure>
</p>
<p align="center">图21-2 展开一个宏，第1部分：用模式匹配参数</p>
<p>宏的模式是Rust的mini语言。它们本质上是匹配代码的正则表达式。但普通的正则表达式是操作字符，而模式操作 <em>token(词元)</em> ——数字、变量名、标点符号等Rust中的构建块。这意味着你可以在宏模式中自由地使用注释和空格来提升它们的可读性。注释和空格不是token，因此它们不会影响到匹配。</p>
<p>正则表达式和宏模式的另一个重要不同之处是圆括号、方括号、花括号在Rust中总是成对出现。这一点会在宏展开之前就检查，不仅仅是在宏模式中，而且是在整个语言中。</p>
<p>在这个例子中，我们的模式包含了 <em>fragment(片段)</em>  <code>$left:expr</code>，这告诉Rust去匹配一个表达式（在这个例子中，就是<code>gcd(6, 10)</code>）并把它复制到名称<code>$left</code>。然后Rust用<code>gcd</code>调用后边的逗号匹配模式中的逗号。类似于正则表达式，模式只有少数特殊字符会触发有趣的匹配行为；其它的所有字符，例如逗号，都必须逐字匹配相同的字符，否则就会匹配失败。</p>
<p>这个模式中的两个代码片段都是<code>expr</code>类型：它们代表表达式。我们将在“片段类型”中看到其他类型的代码片段。</p>
<p>因为这个模式匹配到了所有的参数，Rust会展开相应的 <em>template(模板)</em> (”图21-3”)：</p>
<p><figure>
  <picture>

    
      
        
        
        
        
        
        
    <img
      loading="lazy"
      decoding="async"
      alt="展开一个宏，第2部分：填充模板"
      
        class="image_figure image_internal image_unprocessed"
        src="../img/f21-3.png"
      
      
    />

    </picture>
</figure>
</p>
<p align="center">图21-3 展开一个宏，第2部分：填充模板</p>
<p>Rust会用匹配阶段发现的代码片段来替换<code>$left</code>和<code>$right</code>。</p>
<p>一个常见的错误是在输出模板中包含片段的类型：写<code>$left:expr</code>而不是<code>$left</code>。Rust不会立刻检测出这种错误。它会把<code>$left</code>看做一个整体，然后把<code>:expr</code>看作和模板中其他部分一样的东西：要包含在宏的输出中的词元。因此只有当你 <em>调用</em> 这个宏时这个错误才会出现；然后它会生成错误的不能编译的输出。如果你在使用一个新的宏时得到了类似<code>cannot find type `expr` in this scope`</code>和<code>help: maybe you meant to use a path separator here</code>这样的错误消息，可以检查下它是不是有这个错误。（“调试宏”提供了更多类似这种情况的建议。）</p>
<p>宏模板和web编程中常用的很多种模板语言中的任意一种都没有太大的区别。唯一的不同——也是很重要的一点——就是它的输出是Rust代码。</p>
<h3 id="意外的结果">意外的结果</h3>
<p>把代码片段插入模板和普通的处理值的代码有一些区别。这些区别一开始可能并不明显。我们之前看到的<code>assert_eq!</code>宏包含了一些有些奇怪的代码，这是宏编程特有的。让我们重点看看其中两个有趣的部分。</p>
<p>首先，为什么这个宏创建了两个变量<code>left_val</code>和<code>right_val</code>？为什么我们不能把模板简化成这样？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="cp">$left</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="cp">$right</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="fm">panic!</span><span class="p">(</span><span class="err">&#34;</span><span class="n">assertion</span><span class="w"> </span><span class="n">failed</span>: <span class="err">`</span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="err">`</span><span class="w"> </span><span class="err">\</span><span class="w">
</span><span class="w">                </span><span class="p">(</span><span class="n">left</span>: <span class="err">`</span><span class="p">{</span>:<span class="o">?</span><span class="p">}</span><span class="err">`</span><span class="p">,</span><span class="w"> </span><span class="n">right</span>: <span class="err">`</span><span class="p">{</span>:<span class="o">?</span><span class="p">}</span><span class="err">`</span><span class="p">)</span><span class="err">&#34;</span><span class="p">,</span><span class="w"> </span><span class="cp">$left</span><span class="p">,</span><span class="w"> </span><span class="cp">$right</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>为了回答这个问题，尝试手动展开宏调用<code>assert_eq!(letters.pop(), Some('z'))</code>。输出将会是什么？Rust会把匹配到的表达式插入模板中的多个位置。看起来在构建错误消息时重新求值表达式是一个坏主意，原因不仅仅是因为它需要消耗两倍的时间：因为<code>letters.pop()</code>从vector中移除一个值，所以在我们第二次调用它时会产生一个和第一次不同的值！这就是为什么真正的宏只计算一次<code>$left</code>和<code>$right</code>，然后存储它们的值。</p>
<p>来到第二个问题：为什么这个宏借用了<code>$left</code>和<code>$right</code>的值的引用？为什么不直接把它们的 <em>值</em> 存进变量中，像这样？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="fm">macro_rules!</span><span class="w"> </span><span class="n">bad_assert_eq</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="cp">$left</span>:<span class="nc">expr</span><span class="p">,</span><span class="w"> </span><span class="cp">$right</span>:<span class="nc">expr</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">({</span><span class="w">
</span><span class="w">            </span><span class="k">match</span><span class="w"> </span><span class="p">(</span><span class="cp">$left</span><span class="p">,</span><span class="w"> </span><span class="cp">$right</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="p">(</span><span class="n">left_val</span><span class="p">,</span><span class="w"> </span><span class="n">right_val</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="n">left_val</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">right_val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                        </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&#34;assertion failed&#34;</span><span class="w"> </span><span class="cm">/* ... */</span><span class="p">);</span><span class="w">
</span><span class="w">                    </span><span class="p">}</span><span class="w">
</span><span class="w">                </span><span class="p">}</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">});</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>对于我们展示过的特殊情况，即宏的参数是整数的情况下，这可以正常工作。但如果调用者传递了一个<code>String</code>变量作为<code>$left</code>或<code>$right</code>，这段代码将会移动变量的值！</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;a rose&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">bad_assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;a rose&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;confirmed: {} is a rose&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">);</span><span class="w">    </span><span class="c1">// error: use of moved value &#34;s&#34;
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>因为我们不想让断言移动值，所以宏里使用了引用。</p>
<p>（你可能想知道为什么这个宏使用了<code>match</code>而不是<code>let</code>来定义变量。我们也想知道。事实证明并没有特殊的原因这么做。<code>let</code>是等价的。）</p>
<p>简而言之，宏可能做出令人惊讶的行为。如果一个你写的宏附近发生了奇怪的事，那很可能是这个宏有问题。</p>
<p>C++里的这个经典bug你 <em>将不会</em> 看到：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="c1">// buggy C++ macro to add 1 to a number
</span><span class="c1"></span><span class="w">    </span>#<span class="n">define</span><span class="w"> </span><span class="n">ADD_ONE</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>原因大部分的C++程序员应该很熟悉了，并且不值得详细解释，类似<code>ADD_ONE(1) * 10</code>或者<code>ADD_ONE(1 &lt;&lt; 4)</code>这样的代码可能会产生令人惊讶的行为。为了修复它，你需要在宏定义中加上更多括号。这在Rust中是不必要的，因为Rust宏和语言集成的更好。Rust知道它什么时候是在处理表达式，因此在把一个表达式粘贴到另一个地方时它会自动添加括号。</p>
<h3 id="重复">重复</h3>
<p>标准的<code>vec!</code>宏有两种形式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="c1">// 重复一个值N次
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">0_</span><span class="k">u8</span><span class="p">;</span><span class="w"> </span><span class="mi">1000</span><span class="p">];</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// 一个逗号分隔的值的列表
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">numbers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="s">&#34;udon&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;ramen&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;soba&#34;</span><span class="p">];</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>它可以像这样实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="fm">macro_rules!</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="cp">$elem</span>:<span class="nc">expr</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="cp">$n</span>:<span class="nc">expr</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span>::<span class="n">std</span>::<span class="n">vec</span>::<span class="n">from_elem</span><span class="p">(</span><span class="cp">$elem</span><span class="p">,</span><span class="w"> </span><span class="cp">$n</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">};</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="w"> </span><span class="cp">$(</span><span class="w"> </span><span class="cp">$x</span>:<span class="nc">expr</span><span class="w"> </span><span class="p">),</span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="o">&lt;</span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="o">&gt;</span>::<span class="n">into_vec</span><span class="p">(</span><span class="nb">Box</span>::<span class="n">new</span><span class="p">([</span><span class="w"> </span><span class="cp">$(</span><span class="w"> </span><span class="cp">$x</span><span class="w"> </span><span class="p">),</span><span class="o">*</span><span class="w"> </span><span class="p">]))</span><span class="w">
</span><span class="w">        </span><span class="p">};</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="w"> </span><span class="cp">$(</span><span class="w"> </span><span class="cp">$x</span>:<span class="nc">expr</span><span class="w"> </span><span class="p">),</span><span class="o">+</span><span class="w"> </span><span class="p">,)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="fm">vec!</span><span class="p">[</span><span class="w"> </span><span class="cp">$(</span><span class="w"> </span><span class="cp">$x</span><span class="w"> </span><span class="p">),</span><span class="o">*</span><span class="w"> </span><span class="p">]</span><span class="w">
</span><span class="w">        </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这里有三个规则。我们将解释多个规则是如何工作的，然后依次看看每一个规则。</p>
<p>当Rust展开一个例如<code>vec![1, 2, 3]</code>的宏调用时，它首先尝试匹配参数<code>1, 2, 3</code>和第一条规则的模式，即<code>$elem:expr ; $n:expr</code>。这会匹配失败：<code>1</code>是一个表达式，但这个模式要求它后边有一个分号，然而并没有。因此Rust会移动到第二个规则，等等。如果没有规则可以匹配，就会报错。</p>
<p>第一个规则处理类似<code>vec![0u8; 1000]</code>这样的调用。恰好有一个标准（但不在文档里的）函数<code>std::vec::from_elem</code>，正好可以完成我们需要的功能，因此这个规则很直观。</p>
<p>第二个规则处理<code>vec![&quot;udon&quot;, &quot;ramen&quot;, &quot;soba&quot;]</code>。模式<code>$( $x:expr ),*</code>使用了一个我们之前没有提过的的特性：重复。它匹配0个或多个逗号分隔的表达式。更一般地来说，语法<code>$( PATTERN ),*</code>用来匹配任意逗号分割的列表，其中列表中的每一项与<code>PATTERN</code>匹配。</p>
<p>这里的<code>*</code>和正则表达式中的<code>*</code>有相同的含义（“0次或多次”），尽管正则表达式没有特殊的<code>,*</code>重复器。你也可以用<code>+</code>来要求至少一次匹配，或者用<code>?</code>要求0次或1次匹配。”表21-1”列出了全套的重复模式。</p>
<table>
<thead>
<tr>
<th><strong>模式</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$( ... )*</code></td>
<td>匹配0次或多次，无分隔符</td>
</tr>
<tr>
<td><code>$( ... ),*</code></td>
<td>匹配0次或多次，逗号分隔</td>
</tr>
<tr>
<td><code>$( ... );*</code></td>
<td>匹配0次或多次，分号分隔</td>
</tr>
<tr>
<td><code>$( ... )+</code></td>
<td>匹配1次或多次，无分隔符</td>
</tr>
<tr>
<td><code>$( ... ),+</code></td>
<td>匹配1次或多次，逗号分隔</td>
</tr>
<tr>
<td><code>$( ... );+</code></td>
<td>匹配1次或多次，分号分隔</td>
</tr>
<tr>
<td><code>$( ... )?</code></td>
<td>匹配0次或1次，无分隔符</td>
</tr>
<tr>
<td><code>$( ... ),?</code></td>
<td>匹配0次或1次，逗号分隔</td>
</tr>
<tr>
<td><code>$( ... );?</code></td>
<td>匹配0次或1次，分号分隔</td>
</tr>
</tbody>
</table>
<p>代码片段<code>$x</code>不是单个表达式，而是一个表达式的列表。这个规则的模板也使用了重复语法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="o">&lt;</span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="o">&gt;</span>::<span class="n">into_vec</span><span class="p">(</span><span class="nb">Box</span>::<span class="n">new</span><span class="p">([</span><span class="w"> </span><span class="cp">$(</span><span class="w"> </span><span class="cp">$x</span><span class="w"> </span><span class="p">),</span><span class="o">*</span><span class="w"> </span><span class="p">]))</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>再一次，恰好有标准方法可以满足我们的需要。这段代码创建了一个装箱的数组，然后使用<code>[T]::into_vec</code>方法把这个装箱的数组转换成一个vector。</p>
<p>开头的<code>&lt;[_]&gt;</code>，是一种不常见的写法，它表示类型“某些东西的切片”，由Rust来推断元素类型。名字是普通标识符的类型可以直接在表达式中使用，但类似<code>fn()</code>、<code>&amp;str</code>，或者<code>[_]</code>这样的类型必须用尖括号包裹。</p>
<p>重复模式出现在模板的末尾，即<code>$($x),*</code>。这个<code>$(...),*</code>和我们在模式中看到的是相同的语法。它迭代<code>$x</code>匹配到的表达式列表并把它们全部插入模板，用逗号分隔。</p>
<p>在这种情况下看，重复的输出看起来和输入一样。但并不总是这样。我们可以编写类似这样的规则：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="p">(</span><span class="w"> </span><span class="cp">$(</span><span class="w"> </span><span class="cp">$x</span>:<span class="nc">expr</span><span class="w"> </span><span class="p">),</span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="cp">$(</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="cp">$x</span><span class="p">);</span><span class="w"> </span><span class="p">)</span><span class="o">*</span><span class="w">
</span><span class="w">            </span><span class="n">v</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这里，模板中<code>$( v.push($x); )*</code>这一部分会对<code>$x</code>中的每个表达式插入一个<code>v.push()</code>调用。一个宏分支可以展开成一个表达式序列，但这里我们只需要单个表达式，所以我们把vector的处理包装在一个块中。</p>
<p>和Rust中其他部分不同，使用<code>$( ... ),*</code>并不能自动支持可选的尾部逗号。然而，有一种标准的技巧是通过添加一个额外的规则来支持尾部逗号。也就是我们的<code>vec!</code>宏的第三条规则所做的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="p">(</span><span class="w"> </span><span class="cp">$(</span><span class="w"> </span><span class="cp">$x</span>:<span class="nc">expr</span><span class="w"> </span><span class="p">),</span><span class="o">+</span><span class="w"> </span><span class="p">,)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">    </span><span class="c1">// 如果存在尾部的逗号，
</span><span class="c1"></span><span class="w">        </span><span class="fm">vec!</span><span class="p">[</span><span class="w"> </span><span class="cp">$(</span><span class="w"> </span><span class="cp">$x</span><span class="w"> </span><span class="p">),</span><span class="o">*</span><span class="w"> </span><span class="p">]</span><span class="w">       </span><span class="c1">// 重试没有它的情况
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>我们使用<code>$( ... ),+ ,</code>来匹配一个有额外逗号的列表。然后，我们在模板中递归调用了<code>vec!</code>，但排除了那个逗号。这一次第二条规则将会匹配。</p>
<h2 id="内建的宏">内建的宏</h2>
<p>Rust编译器提供了几个宏，如果你要定义自己的宏，它们可能会发挥作用。这些宏都不能使用<code>macro_rules!</code>来实现。它们被硬编码进<code>rustc</code>：</p>
<p><em><code>file!(), line!(), column!()</code></em></p>
<p>  <code>file!()</code>展开成一个字符串字面量：当前的文件名。<code>line!()</code>和<code>column!()</code>展开成<code>u32</code>字面量，表示当前的行号和列号（从1开始计数）。</p>
<p>  如果一个宏调用了另一个宏，那个宏又调用了另一个宏，这三个宏在不同的文件中，并且最后一个宏调用了<code>file!(), line!()</code>或者<code>column!()</code>，它会展开成 <em>第一个</em> 宏调用的位置。</p>
<p><em><code>stringify!(...tokens...)</code></em></p>
<p>  展开成一个包含给定token的字符串字面量。<code>assert!</code>宏就是使用了它来生成一条包含了断言代码的错误信息。</p>
<p>  参数中的宏调用 <em>不会</em> 被展开：<code>stringify!(line!())</code>会展开为<code>&quot;line!()&quot;</code>。</p>
<p>  Rust根据token构建字符串，因此生成的字符串里没有换行符或者注释。</p>
<p><em><code>concat!(str0, str1, ...)</code></em></p>
<p>  连接参数展开为单个字符串字面量。</p>
<p>Rust还定义了下面这些宏用来查询构建环境：</p>
<p><em><code>cfg!(...)</code></em></p>
<p>  展开为一个bool常量，如果当前的构建环境满足括号里的条件则为<code>true</code>。例如，如果在编译时启用了调试断言那么<code>cfg!(debug_assertions)</code>为真。</p>
<p>  这个宏和“属性”中介绍过的<code>#[cfg(...)]</code>属性的语法完全相同，但它不是条件编译，而是得到一个true或者false。</p>
<p><em><code>env!(&quot;VAR_NAME&quot;)</code></em></p>
<p>  展开为一个字符串：在编译时该环境变量的值。如果这个变量不存在，会产生编译错误。</p>
<p>  除了Cargo在编译crate时设置的几个有趣的环境变量之外，这个宏毫无价值。例如，为了得到crate当前的版本，你可以写：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">version</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">env!</span><span class="p">(</span><span class="s">&#34;CARGO_PKG_VERSION&#34;</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>  这些环境变量的完整列表见<a href="https://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-crates">Cargo文档</a>。</p>
<p><em><code>option_env!(&quot;VAR_NAME&quot;)</code></em></p>
<p>  它和<code>env!</code>宏一样，除了它返回一个<code>Option&lt;&amp;'static str&gt;</code>，当环境变量没有设置时返回<code>None</code>。</p>
<p>还有更多内建的宏可以让你引入另一个文件中的代码或者数据：</p>
<p><em><code>include!(&quot;file.rs&quot;)</code></em></p>
<p>  展开为指定文件的内容，必须是有效的Rust代码——表达式或者”item”的序列。</p>
<p><em><code>include_str!(&quot;file.txt&quot;)</code></em></p>
<p>  展开成一个包含指定文件内容的<code>&amp;'static str</code>。你可以像这样使用它：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">COMPOSITOR_SHADER</span>: <span class="kp">&amp;</span><span class="kt">str</span> <span class="o">=</span><span class="w">
</span><span class="w">            </span><span class="fm">include_str!</span><span class="p">(</span><span class="s">&#34;../resources/compositor.glsl&#34;</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>  如果文件不存在或者不是有效的UTF-8，会产生编译错误。</p>
<p><em><code>include_bytes!(&quot;file.dat&quot;)</code></em></p>
<p>  和上一个基本相同，除了它把文件当作二进制数据而不是UTF-8文本，结果是一个<code>&amp;'static [u8]</code>。</p>
<p>和所有的宏一样，这些宏也是在编译时进行处理。如果文件不存在或者不能被读取，就会编译失败。它们不可能在运行时出错。在任何情况下，如果文件名是一个相对路径，它会被解析为相对于当前文件所在的目录的路径。</p>
<p>Rust还提供了几个方便的宏：</p>
<p><em><code>todo!(), unimplemented!()</code></em></p>
<p>  这些等价于<code>panic!()</code>，但用于表示不同的意图。<code>unimplemented!()</code>出现在<code>if</code>分支、<code>match</code>分支，以及其它还未处理的case中。它总是会panic。<code>todo!()</code>大致相同，但传达的意图是代码还没写完；一些IDE使用它来进行标记。</p>
<p><em><code>matches!(value, pattern)</code></em></p>
<p>  比较一个值和一个模式，当它们匹配时返回<code>true</code>，否则返回<code>false</code>。它等价于写：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">pattern</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kc">false</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>  如果你在寻找基本的编写宏的练习，这是一个很好的例子——尤其是你可以在标准库文档中看到它的实际实现非常简单。</p>
<h2 id="调试宏">调试宏</h2>
<p>调试宏可能很有挑战性。最大的问题是在宏展开的过程中缺少可视性。Rust总是展开所有宏，找到一些错误，然后打印出一条错误信息，但这个错误信息并没有显示出完整的展开后的代码！</p>
<p>这里有三个工具可以帮助你调试宏。（这些特性都是unstable的，但因为它们被设计为用在开发的过程中，而不是最后的代码中，因此在实践中这不是一个很大的问题。）</p>
<p>第一个也是最简单的一个，你可以让<code>rustc</code>显示你的代码在展开所有宏之后是什么样的。使用<code>cargo build --verbose</code>来看看Cargo是怎么调用<code>rustc</code>的。拷贝<code>rustc</code>的命令行并加上<code>-Z unstable-options --pretty expanded</code>选项。完全展开后的代码会输出到终端。不幸的是，只有当你的代码没有语法错误时这种方式才能生效。</p>
<p>第二，Rust提供了一个<code>log_syntax!()</code>宏简单地在编译期把它的参数打印到终端。你可以使用它来进行<code>println!</code>风格的调试。这个宏需要<code>#![feature(log_syntax)]</code>特性标记。</p>
<p>第三，你可以让Rust编译器把所有宏调用记录到终端。在代码中插入<code>trace_macros!(true)</code>，之后每当Rust展开一个宏时，它都会打印出宏的名字和参数。例如，考虑这个程序：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="cp">#![feature(trace_macros)]</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="fm">trace_macros!</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">numbers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w">
</span><span class="w">        </span><span class="fm">trace_macros!</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;total: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">numbers</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">sum</span>::<span class="o">&lt;</span><span class="kt">u64</span><span class="o">&gt;</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>它会产生如下输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">    $ rustup override set nightly
    ...
    $ rustc trace_example.rs
    note: trace_macro
     --&gt; trace_example.rs:5:19
      |
    5 |     let numbers = vec![1, 2, 3];
      |                   ^^^^^^^^^^^^^
      |
      = note: expanding `vec! { 1 , 2 , 3 }`
      = note: to `&lt; [ _ ] &gt; :: into_vec ( box [ 1 , 2 , 3 ] )`
</code></pre></td></tr></table>
</div>
</div><p>编译器会显示每一个宏调用的代码，包括展开之前和展开之后的代码。<code>trace_macros!(false);</code>这一行关闭了追踪，因此<code>println!()</code>的调用不会被追踪。</p>
<h2 id="构建json宏">构建<code>json!</code>宏</h2>
<p>我们已经讨论了<code>macro_rules!</code>的核心特性。在这一节，我们将渐进式开发一个构建JSON数据的宏。我们将用这个例子来展示开发一个宏的过程、展示<code>macro_rules!</code>剩余的部分、并提供一些保证你的宏正确工作的建议。</p>
<p>回到”第10章”，我们使用了这个枚举来代表JSON数据：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="cp">#[derive(Clone, PartialEq, Debug)]</span><span class="w">
</span><span class="w">    </span><span class="k">enum</span> <span class="nc">Json</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Null</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">Boolean</span><span class="p">(</span><span class="kt">bool</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">Number</span><span class="p">(</span><span class="kt">f64</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="nb">String</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">Array</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Json</span><span class="o">&gt;</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">Object</span><span class="p">(</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">Json</span><span class="o">&gt;&gt;</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>不幸的是，编写<code>Json</code>值的语法非常复杂：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">students</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Json</span>::<span class="n">Array</span><span class="p">(</span><span class="fm">vec!</span><span class="p">[</span><span class="w">
</span><span class="w">        </span><span class="n">Json</span>::<span class="n">Object</span><span class="p">(</span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="fm">vec!</span><span class="p">[</span><span class="w">
</span><span class="w">            </span><span class="p">(</span><span class="s">&#34;name&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w"> </span><span class="n">Json</span>::<span class="nb">String</span><span class="p">(</span><span class="s">&#34;Jim Blandy&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">())),</span><span class="w">
</span><span class="w">            </span><span class="p">(</span><span class="s">&#34;class_of&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w"> </span><span class="n">Json</span>::<span class="n">Number</span><span class="p">(</span><span class="mf">1926.0</span><span class="p">)),</span><span class="w">
</span><span class="w">            </span><span class="p">(</span><span class="s">&#34;major&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w"> </span><span class="n">Json</span>::<span class="nb">String</span><span class="p">(</span><span class="s">&#34;Tibetan throat singing&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">()))</span><span class="w">
</span><span class="w">        </span><span class="p">].</span><span class="n">into_iter</span><span class="p">().</span><span class="n">collect</span><span class="p">())),</span><span class="w">
</span><span class="w">        </span><span class="n">Json</span>::<span class="n">Object</span><span class="p">(</span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="fm">vec!</span><span class="p">[</span><span class="w">
</span><span class="w">            </span><span class="p">(</span><span class="s">&#34;name&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w"> </span><span class="n">Json</span>::<span class="nb">String</span><span class="p">(</span><span class="s">&#34;Jason Orendorff&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">())),</span><span class="w">
</span><span class="w">            </span><span class="p">(</span><span class="s">&#34;class_of&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w"> </span><span class="n">Json</span>::<span class="n">Number</span><span class="p">(</span><span class="mf">1702.0</span><span class="p">)),</span><span class="w">
</span><span class="w">            </span><span class="p">(</span><span class="s">&#34;major&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w"> </span><span class="n">Json</span>::<span class="nb">String</span><span class="p">(</span><span class="s">&#34;Knots&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">()))</span><span class="w">
</span><span class="w">        </span><span class="p">].</span><span class="n">into_iter</span><span class="p">().</span><span class="n">collect</span><span class="p">()))</span><span class="w">
</span><span class="w">    </span><span class="p">]);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>我们希望能使用更类似JSON的语法来实现同样的效果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">students</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">json</span><span class="o">!</span><span class="p">([</span><span class="w">
</span><span class="w">        </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;name&#34;</span>: <span class="s">&#34;Jim Blandy&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;class_of&#34;</span>: <span class="mi">1926</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;major&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Tibetan throat singing&#34;</span><span class="w">
</span><span class="w">        </span><span class="p">},</span><span class="w">
</span><span class="w">        </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;name&#34;</span>: <span class="s">&#34;Jason Orendorff&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;class_of&#34;</span>: <span class="mi">1702</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;major&#34;</span>: <span class="s">&#34;Knots&#34;</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">]);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>我们要实现的是一个<code>json!</code>宏，它获取一个JSON值作为参数并展开为类似上一个例子中的表达式。</p>
<h3 id="片段类型">片段类型</h3>
<p>编写任何复杂宏的第一步都是指明如何匹配或 <em>解析</em> 期望的输入。</p>
<p>我们已经能看到这个宏将会有好几条规则，因为JSON数据中有几种不同的东西：对象，数组，数字等等。实际上，我们可能会猜测我们将为每一种JSON类型编写一条规则：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="fm">macro_rules!</span><span class="w"> </span><span class="n">json</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="n">null</span><span class="p">)</span><span class="w">    </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Json</span>::<span class="n">Null</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">        </span><span class="p">([</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"> </span><span class="p">])</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Json</span>::<span class="n">Array</span><span class="p">(</span><span class="o">..</span><span class="p">.)</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">        </span><span class="p">({</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Json</span>::<span class="n">Object</span><span class="p">(</span><span class="o">..</span><span class="p">.)</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="o">???</span><span class="p">)</span><span class="w">     </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Json</span>::<span class="n">Boolean</span><span class="p">(</span><span class="o">..</span><span class="p">.)</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="o">???</span><span class="p">)</span><span class="w">     </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Json</span>::<span class="n">Number</span><span class="p">(</span><span class="o">..</span><span class="p">.)</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="o">???</span><span class="p">)</span><span class="w">     </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Json</span>::<span class="nb">String</span><span class="p">(</span><span class="o">..</span><span class="p">.)</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这并不完全正确，因为宏模式没法区分最后三种情况，但我们稍后将会看到怎么处理它们。前三种情况至少很明显地以不同的token开头，因此我们可以用这些token进行区分。</p>
<p>第一个规则已经可以工作了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="fm">macro_rules!</span><span class="w"> </span><span class="n">json</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="n">null</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Json</span>::<span class="n">Null</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="cp">#[test]</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">json_null</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">json</span><span class="o">!</span><span class="p">(</span><span class="n">null</span><span class="p">),</span><span class="w"> </span><span class="n">json</span>::<span class="n">Null</span><span class="p">);</span><span class="w">    </span><span class="c1">// passes!
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>为了支持JSON数组，我们可能要尝试匹配元素为<code>expr</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="fm">macro_rules!</span><span class="w"> </span><span class="n">json</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="n">null</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Json</span>::<span class="n">Null</span><span class="w">
</span><span class="w">        </span><span class="p">};</span><span class="w">
</span><span class="w">        </span><span class="p">([</span><span class="w"> </span><span class="cp">$(</span><span class="w"> </span><span class="cp">$element</span>:<span class="nc">expr</span><span class="w"> </span><span class="p">),</span><span class="o">*</span><span class="w"> </span><span class="p">])</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Json</span>::<span class="n">Array</span><span class="p">(</span><span class="fm">vec!</span><span class="p">[</span><span class="w"> </span><span class="cp">$(</span><span class="w"> </span><span class="cp">$element</span><span class="w"> </span><span class="p">),</span><span class="o">*</span><span class="w"> </span><span class="p">])</span><span class="w">
</span><span class="w">        </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>不幸的是，这不能匹配所有的JSON数组。这里有一个会产生问题的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="cp">#[test]</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">json_array_with_json_element</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">macro_generated_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">json</span><span class="o">!</span><span class="p">(</span><span class="w">
</span><span class="w">            </span><span class="p">[</span><span class="w">
</span><span class="w">                </span><span class="c1">// 有效的JSON，但不匹配`$element:expr`
</span><span class="c1"></span><span class="w">                </span><span class="p">{</span><span class="w">
</span><span class="w">                    </span><span class="s">&#34;pitch&#34;</span>: <span class="mf">440.0</span><span class="w">
</span><span class="w">                </span><span class="p">}</span><span class="w">
</span><span class="w">            </span><span class="p">]</span><span class="w">
</span><span class="w">        </span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">hand_coded_value</span><span class="w"> </span><span class="o">=</span><span class="w">
</span><span class="w">            </span><span class="n">Json</span>::<span class="n">Array</span><span class="p">(</span><span class="fm">vec!</span><span class="p">[</span><span class="w">
</span><span class="w">                </span><span class="n">Json</span>::<span class="n">Object</span><span class="p">(</span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="fm">vec!</span><span class="p">[</span><span class="w">
</span><span class="w">                    </span><span class="p">(</span><span class="s">&#34;pitch&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w"> </span><span class="n">Json</span>::<span class="n">Number</span><span class="p">(</span><span class="mf">440.0</span><span class="p">))</span><span class="w">
</span><span class="w">                </span><span class="p">].</span><span class="n">into_iter</span><span class="p">().</span><span class="n">collect</span><span class="p">()))</span><span class="w">
</span><span class="w">            </span><span class="p">]);</span><span class="w">
</span><span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">macro_generated_value</span><span class="p">,</span><span class="w"> </span><span class="n">hand_coded_value</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>模式<code>$( $element:expr ),*</code>意思是“一个逗号分隔的Rust表达式的列表”。但很多JSON值尤其是对象，不是有效的Rust表达式，它们不能匹配。</p>
<p>因为你想要匹配的代码并不都是表达式，所以Rust还支持其他几种片段类型，如”表21-2”所示。</p>
<table>
<thead>
<tr>
<th><strong>片段类型</strong></th>
<th><strong>匹配的内容（及示例）</strong></th>
<th><strong>后边可以跟</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>expr</code></td>
<td>一个表达式：<code>2 + 2, &quot;udon&quot;, x.len()</code></td>
<td><code>=&gt; , ;</code></td>
</tr>
<tr>
<td><code>stmt</code></td>
<td>一个表达式或者声明，不包括尾部的分号（很难用；尝试用<code>expr</code>或<code>block</code>代替）</td>
<td><code>=&gt; , ;</code></td>
</tr>
<tr>
<td><code>ty</code></td>
<td>一个类型：<code>String, Vec&lt;u8&gt;, (&amp;str, bool), dyn Read + Send</code></td>
<td><code>=&gt; , ; | { [ : &gt; as where</code></td>
</tr>
<tr>
<td><code>path</code></td>
<td>一个路径（已讨论过）：<code>ferns, ::std::sync::mpsc</code></td>
<td><code>=&gt; , ; | { [ : &gt; as where</code></td>
</tr>
<tr>
<td><code>pat</code></td>
<td>一个模式（已讨论过）：<code>_, Some(ref x)</code></td>
<td><code>=&gt; , = | if in</code></td>
</tr>
<tr>
<td><code>item</code></td>
<td>一个item（已讨论过）：<code>struct Point { x: f64, y: f64 }, mod ferns;</code></td>
<td>任何东西</td>
</tr>
<tr>
<td><code>block</code></td>
<td>一个块（已讨论过）：<code>{ s += &quot;ok\n&quot;; true }</code></td>
<td>任何东西</td>
</tr>
<tr>
<td><code>meta</code></td>
<td>一个属性的内容（已讨论过）：<code>inline, derive(Copy, Clone), doc=&quot;3D models.&quot;</code></td>
<td>任何东西</td>
</tr>
<tr>
<td><code>ident</code></td>
<td>一个标识符：<code>std, Json, longish_variable_name</code></td>
<td>任何东西</td>
</tr>
<tr>
<td><code>literal</code></td>
<td>一个字面值：<code>1024, &quot;Hello, world!&quot;, 1_000_000f64</code></td>
<td>任何东西</td>
</tr>
<tr>
<td><code>lifetime</code></td>
<td>一个生命周期：<code>'a, 'item, 'static</code></td>
<td>任何东西</td>
</tr>
<tr>
<td><code>vis</code></td>
<td>可见性说明符：<code>pub, pub(crate), pub(in module::submodule)</code></td>
<td>任何东西</td>
</tr>
<tr>
<td><code>tt</code></td>
<td>一个token树：<code>;, &gt;=, {}, [0 1 (+ 0 1)]</code></td>
<td>任何东西</td>
</tr>
</tbody>
</table>
<p>表格中的大部分选项严格要求Rust语法。<code>expr</code>类型只匹配Rust表达式（不是JSON值），<code>ty</code>只匹配Rust类型，等等。它们是不可扩展的：没有办法定义一种新的可以用<code>expr</code>识别的运算符或关键字。我们不能用这些来实现匹配任意JSON数据。</p>
<p>最后两个，<code>ident</code>和<code>tt</code>，支持匹配不是Rust代码的参数。<code>ident</code>匹配任何标识符。<code>tt</code>匹配单个 <em>token树</em> ：一对正确匹配的括号：<code>(...), [...], {...}</code>，以及其中的任何内容，包括嵌套的token树；或者一个没有括号的单个token，例如<code>1926</code>或<code>&quot;Knots&quot;</code>。</p>
<p>token树正是我们的<code>json!</code>宏所需要的。每一个JSON值都是单个token树：数字、字符串、bool值、<code>null</code>都是单个token，对象和数组是token树。因此我们可以写出像这样的模式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="fm">macro_rules!</span><span class="w"> </span><span class="n">json</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="n">null</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Json</span>::<span class="n">Null</span><span class="w">
</span><span class="w">        </span><span class="p">};</span><span class="w">
</span><span class="w">        </span><span class="p">([</span><span class="w"> </span><span class="cp">$(</span><span class="w"> </span><span class="cp">$element</span>:<span class="nc">tt</span><span class="w"> </span><span class="p">),</span><span class="o">*</span><span class="w"> </span><span class="p">])</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Json</span>::<span class="n">Array</span><span class="p">(</span><span class="o">..</span><span class="p">.)</span><span class="w">
</span><span class="w">        </span><span class="p">};</span><span class="w">
</span><span class="w">        </span><span class="p">({</span><span class="w"> </span><span class="cp">$(</span><span class="w"> </span><span class="cp">$key</span>:<span class="nc">tt</span><span class="w"> </span>: <span class="cp">$value</span>: <span class="nc">tt</span><span class="w"> </span><span class="p">),</span><span class="o">*</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Json</span>::<span class="n">Object</span><span class="p">(</span><span class="o">..</span><span class="p">.)</span><span class="w">
</span><span class="w">        </span><span class="p">};</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="cp">$other</span>::<span class="n">tt</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="o">..</span><span class="p">.</span><span class="w"> </span><span class="c1">// TODO: 返回数字、字符串、bool值
</span><span class="c1"></span><span class="w">        </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这个版本的<code>json!</code>宏可以匹配任何JSON数据。现在我们只需要产生正确的Rust代码。</p>
<p>为了保证Rust在未来可以添加新的语法特性而不会破坏任何你今天写的宏，Rust限制了模式中紧跟在片段之后的token。”表21-2”中“后边可以跟”这一列展示了哪些token可以跟在模式后面。例如，模式<code>$x:expr ~ $y:expr</code>是错的，因为<code>~</code>不允许出现在<code>expr</code>后面。模式<code>$vars:pat =&gt; $handler:expr</code>是可以的，因为<code>$vars:pat</code>后跟的是箭头<code>=&gt;</code>，它允许跟在<code>pat</code>后面，而<code>$handler:expr</code>后面没有跟任何东西，这种情况总是允许的。</p>
<h3 id="宏中的递归">宏中的递归</h3>
<p>我们已经见过了一个在宏里调用自身的小例子：我们的<code>vec!</code>的实现使用了递归来支持尾部的逗号。这里我们可以展示一个更加显著的例子：<code>json!</code>需要递归调用它自身。</p>
<p>我们可能会尝试在不递归的情况下支持JSON数组，像这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="p">([</span><span class="w"> </span><span class="cp">$(</span><span class="w"> </span><span class="cp">$element</span>:<span class="nc">tt</span><span class="w"> </span><span class="p">),</span><span class="o">*</span><span class="w"> </span><span class="p">])</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Json</span>::<span class="n">Array</span><span class="p">(</span><span class="fm">vec!</span><span class="p">[</span><span class="w"> </span><span class="cp">$(</span><span class="w"> </span><span class="cp">$element</span><span class="w"> </span><span class="p">),</span><span class="o">*</span><span class="w"> </span><span class="p">])</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>但这段代码并不能工作。这样只是把JSON数据（<code>$element</code> token树）粘贴到了Rust表达式之中，但它们是两种不同的语言。</p>
<p>我们需要把数组中的每一个元素从JSON格式转换为Rust代码。幸运的是，有一个宏可以做到这件事：就是我们正在写的这个宏！</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="p">([</span><span class="w"> </span><span class="cp">$(</span><span class="w"> </span><span class="cp">$element</span>:<span class="nc">tt</span><span class="w"> </span><span class="p">),</span><span class="o">*</span><span class="w"> </span><span class="p">])</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Json</span>::<span class="n">Array</span><span class="p">(</span><span class="fm">vec!</span><span class="p">[</span><span class="w"> </span><span class="cp">$(</span><span class="w"> </span><span class="n">json</span><span class="o">!</span><span class="p">(</span><span class="cp">$element</span><span class="p">)</span><span class="w"> </span><span class="p">),</span><span class="o">*</span><span class="w"> </span><span class="p">])</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这种方式还可以支持对象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="p">({</span><span class="w"> </span><span class="cp">$(</span><span class="w"> </span><span class="cp">$key</span>:<span class="nc">tt</span><span class="w"> </span>: <span class="cp">$value</span>:<span class="nc">tt</span><span class="w"> </span><span class="p">),</span><span class="o">*</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Json</span>::<span class="n">Object</span><span class="p">(</span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="fm">vec!</span><span class="p">[</span><span class="w">
</span><span class="w">            </span><span class="cp">$(</span><span class="w"> </span><span class="p">(</span><span class="cp">$key</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w"> </span><span class="n">json</span><span class="o">!</span><span class="p">(</span><span class="cp">$value</span><span class="p">))</span><span class="w"> </span><span class="p">),</span><span class="o">*</span><span class="w">
</span><span class="w">        </span><span class="p">].</span><span class="n">into_iter</span><span class="p">().</span><span class="n">collect</span><span class="p">()))</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>默认情况下编译器会把宏的递归次数上限设置为64。对于<code>json!</code>宏的常规使用这肯定已经足够了，但有时复杂的递归宏会达到这个上限。你可以在使用这个宏的crate的开头加上这一行来调整上限</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="cp">#![recursion_limit = </span><span class="s">&#34;256&#34;</span><span class="cp">]</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>我们的<code>json!</code>宏基本已经完成了。剩下的只有支持布尔、数字和字符串值。</p>
<h3 id="宏和trait">宏和trait</h3>
<p>编写复杂的宏时总是会遇到困难。重要的是要记住，宏并不是解决问题的唯一途径。</p>
<p>这里，我们需要支持<code>json!(true)</code>、<code>json!(1.0)</code>、<code>json!(&quot;yes&quot;)</code>，把这些值转换成对应的<code>Json</code>值。但宏并不擅长区分类型。假如我们这么写：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="fm">macro_rules!</span><span class="w"> </span><span class="n">json</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Json</span>::<span class="n">Boolean</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">};</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="kc">false</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Json</span>::<span class="n">Boolean</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">};</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>显然这种方案是行不通的。布尔类型只有两个值，但数字和字符串有很多值。</p>
<p>幸运的是，有一种标准的把多种类型的值转换成另一种特定类型的方法：<code>From</code> trait。我们可以简单地为几种类型实现这个trait：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Json</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">b</span>: <span class="kt">bool</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Json</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Json</span>::<span class="n">Boolean</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Json</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">i</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Json</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Json</span>::<span class="n">Number</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">f64</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Json</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">s</span>: <span class="nb">String</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Json</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Json</span>::<span class="nb">String</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">impl</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="kt">str</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Json</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Json</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Json</span>::<span class="nb">String</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">to_string</span><span class="p">())</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="o">..</span><span class="p">.</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>事实上，所有的12种数字类型应该有非常相似的实现，因此编写一个宏来避免复制粘贴是有意义的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="fm">macro_rules!</span><span class="w"> </span><span class="n">impl_from_num_for_json</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="w"> </span><span class="cp">$(</span><span class="w"> </span><span class="cp">$t</span>:<span class="nc">ident</span><span class="w"> </span><span class="p">)</span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="cp">$(</span><span class="w">
</span><span class="w">                </span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="cp">$t</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Json</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">n</span>: <span class="cp">$t</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Json</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                        </span><span class="n">Json</span>::<span class="n">Number</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">f64</span><span class="p">)</span><span class="w">
</span><span class="w">                    </span><span class="p">}</span><span class="w">
</span><span class="w">                </span><span class="p">}</span><span class="w">
</span><span class="w">            </span><span class="p">)</span><span class="o">*</span><span class="w">
</span><span class="w">        </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="n">impl_from_num_for_json</span><span class="o">!</span><span class="p">(</span><span class="kt">u8</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="kt">u16</span><span class="w"> </span><span class="kt">i16</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="kt">u64</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="kt">u128</span><span class="w"> </span><span class="kt">i128</span><span class="w">
</span><span class="w">                            </span><span class="kt">usize</span><span class="w"> </span><span class="kt">isize</span><span class="w"> </span><span class="kt">f32</span><span class="w"> </span><span class="kt">f64</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>现在我们可以使用<code>Json::from(value)</code>来把<code>value</code>转换成<code>Json</code>。在我们的宏中，看起来像这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="p">(</span><span class="w"> </span><span class="cp">$other</span>:<span class="nc">tt</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Json</span>::<span class="n">from</span><span class="p">(</span><span class="cp">$other</span><span class="p">)</span><span class="w">  </span><span class="c1">// 处理布尔/数字/字符串
</span><span class="c1"></span><span class="w">    </span><span class="p">};</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>向我们的<code>json!</code>宏中添加了这个规则之后，它就可以通过我们目前写过的所有测试了。把所有部分汇总起来，它现在看起来像这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="fm">macro_rules!</span><span class="w"> </span><span class="n">json</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="n">null</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Json</span>::<span class="n">Null</span><span class="w">
</span><span class="w">        </span><span class="p">};</span><span class="w">
</span><span class="w">        </span><span class="p">([</span><span class="w"> </span><span class="cp">$(</span><span class="w"> </span><span class="cp">$element</span>:<span class="nc">tt</span><span class="p">),</span><span class="o">*</span><span class="w"> </span><span class="p">])</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Json</span>::<span class="n">Array</span><span class="p">(</span><span class="fm">vec!</span><span class="p">[</span><span class="w"> </span><span class="cp">$(</span><span class="w"> </span><span class="n">json</span><span class="o">!</span><span class="p">(</span><span class="cp">$element</span><span class="p">)</span><span class="w"> </span><span class="p">),</span><span class="o">*</span><span class="w"> </span><span class="p">])</span><span class="w">
</span><span class="w">        </span><span class="p">};</span><span class="w">
</span><span class="w">        </span><span class="p">({</span><span class="w"> </span><span class="cp">$(</span><span class="w"> </span><span class="cp">$key</span>:<span class="nc">tt</span><span class="w"> </span>: <span class="cp">$value</span>:<span class="nc">tt</span><span class="w"> </span><span class="p">),</span><span class="o">*</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Json</span>::<span class="n">Object</span><span class="p">(</span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="fm">vec!</span><span class="p">[</span><span class="w">
</span><span class="w">                </span><span class="cp">$(</span><span class="w"> </span><span class="p">(</span><span class="cp">$key</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w"> </span><span class="n">json</span><span class="o">!</span><span class="p">(</span><span class="cp">$value</span><span class="p">))</span><span class="w"> </span><span class="p">),</span><span class="o">*</span><span class="w">
</span><span class="w">            </span><span class="p">].</span><span class="n">into_iter</span><span class="p">().</span><span class="n">collect</span><span class="p">()))</span><span class="w">
</span><span class="w">        </span><span class="p">};</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="w"> </span><span class="cp">$other</span>:<span class="nc">tt</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Json</span>::<span class="n">from</span><span class="p">(</span><span class="cp">$other</span><span class="p">)</span><span class="w">  </span><span class="c1">// 处理布尔/数字/字符串
</span><span class="c1"></span><span class="w">        </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>事实证明，这个宏意外地支持在JSON数据中使用变量甚至任意的Rust表达式，这是一个有趣的特性：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4.0</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">desc</span><span class="w"> </span><span class="o">=</span><span class="w"> 
</span><span class="w">        </span><span class="n">json</span><span class="o">!</span><span class="p">({</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;width&#34;</span>: <span class="nc">width</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;height&#34;</span>: <span class="p">(</span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">9.0</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">4.0</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">});</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>因为<code>(width * 9.0 / 4.0)</code>是用括号括起来的，所以它是单个的token树，因此在解析这个对象时宏可以成功地用<code>$value:tt</code>匹配它。</p>
<h3 id="作用域和hygiene">作用域和hygiene</h3>
<p>在编写宏时一个令人惊讶的问题是它们将来自不同范围的代码粘贴在一起。因此接下来的几页将介绍Rust处理作用域的两种方式：一种用于局部变量和参数，另一种用于其他的东西。</p>
<p>为了展示为什么会有这个问题，让我们重写解析JSON对象的规则（之前展示过的<code>json!</code>宏的第三条规则），让它不再使用临时的vector。我们可以像这样写：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="p">({</span><span class="w"> </span><span class="cp">$($key</span>:<span class="nc">tt</span><span class="w"> </span>: <span class="cp">$value</span>:<span class="nc">tt</span><span class="p">),</span><span class="o">*</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">fields</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">HashMap</span>::<span class="n">new</span><span class="p">());</span><span class="w">
</span><span class="w">            </span><span class="cp">$(</span><span class="w"> </span><span class="n">fields</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="cp">$key</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w"> </span><span class="n">json</span><span class="o">!</span><span class="p">(</span><span class="cp">$value</span><span class="p">));</span><span class="w"> </span><span class="p">)</span><span class="o">*</span><span class="w">
</span><span class="w">            </span><span class="n">Json</span>::<span class="n">Object</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>现在我们不再使用<code>collect()</code>，而是通过重复调用<code>.insert()</code>方法来填充<code>HashMap</code>。这意味着我们需要把map存储在一个临时的变量中，这里命名为<code>fields</code>。</p>
<p>但如果调用<code>json!</code>宏的代码中恰好也有一个叫<code>fields</code>的变量，会发生什么呢？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">fields</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;Fields, W.C.&#34;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">role</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">json</span><span class="o">!</span><span class="p">({</span><span class="w">
</span><span class="w">        </span><span class="s">&#34;name&#34;</span>: <span class="s">&#34;Larson E. Whipsnade&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="s">&#34;actor&#34;</span>: <span class="nc">fields</span><span class="w">
</span><span class="w">    </span><span class="p">});</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>展开这个宏时将会把两段代码拼在一起，两段代码中都用了变量<code>fields</code>来表示不同的东西！</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">fields</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;Fields, W.C.&#34;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">role</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">fields</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">HashMap</span>::<span class="n">new</span><span class="p">());</span><span class="w">
</span><span class="w">        </span><span class="n">fields</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&#34;name&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w"> </span><span class="n">Json</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;Larson E. Whipsnade&#34;</span><span class="p">));</span><span class="w">
</span><span class="w">        </span><span class="n">fields</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&#34;actor&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w"> </span><span class="n">Json</span>::<span class="n">from</span><span class="p">(</span><span class="n">fields</span><span class="p">));</span><span class="w">
</span><span class="w">        </span><span class="n">Json</span>::<span class="n">Object</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>看起来好像只要宏里使用了临时变量就无法避免这个问题，并且你可能已经正在思考可能的解决方案了。也许我们应该把<code>json!</code>宏中的变量重命名为一般情况下调用者不会传入的名字：例如用<code>__json$fields</code>代替<code>fields</code>。</p>
<p>这里令人惊讶的是 <em>宏可以正常工作</em> 。Rust会为你重命名变量！这个特性一开始在Scheme宏中实现，被称为 <em>hygiene</em> ，因此Rust被认为有 <em>hygienic宏</em> 。</p>
<p>理解hygiene宏的最简单的方式就是想象每一次展开宏时，展开的部分都被染成了不同的颜色。</p>
<p>不同颜色的变量，就好像有不同的名字一样：</p>
<p><figure>
  <picture>

    
      
        
        
        
        
        
        
    <img
      loading="lazy"
      decoding="async"
      alt="hygiene宏"
      
        class="image_figure image_internal image_unprocessed"
        src="../img/f21-x.png"
      
      
    />

    </picture>
</figure>
</p>
<p>注意这里宏的调用者传入并被粘贴到输出中的代码，例如<code>&quot;name&quot;</code>和<code>&quot;actor&quot;</code>，保持了它们原本的颜色（黑色）。只有宏模板生成的token被染成了另一种颜色。</p>
<p>现在这里有一个叫<code>fields</code>的变量（在调用者中声明）和另一个叫<code>fields</code>的变量（宏引入的）。因为这两个名字的颜色不同，所以这两个变量不会混淆。</p>
<p>如果一个宏真的需要引用一个在调用者作用域里的变量，那么调用者必须向宏传递这个变量的名字。</p>
<p>（染色的比喻并不意味着hygiene真的就是这么工作的。实际的机制要更聪明一些：不管是什么颜色，如果两个标识符引用了宏和调用者作用域里的同一个变量，那么就认为它们是相同的。但在Rust中像这样的例子非常少见。如果你理解了上面的例子，那么就使用hygiene宏来说已经足够了。）</p>
<p>你可能已经注意到了很多别的标识符也被染上了一种或多种的颜色：例如<code>Box</code>、<code>HashMap</code>、<code>Json</code>等。就算没有颜色，Rust也可以辨认出这些类型的名字。这是因为Rust中的hygiene仅限于局部变量和参数。对于常量、类型、昂发、模块、静态变量、宏名来说，Rust是“色盲”。</p>
<p>这意味着如果我们的<code>json!</code>宏被用在了<code>Box</code>、<code>HashMap</code>或<code>Json</code>不在作用域里的模块中时，这个宏将不能工作。我们将在下一节中展示怎么避免这个问题。</p>
<p>首先，我们将考虑一个Rust的hygiene会产生阻碍的例子，并且我们需要解决它。假设我们有很多函数都包含下面这一行代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">req</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ServerRequest</span>::<span class="n">new</span><span class="p">(</span><span class="n">server_socket</span><span class="p">.</span><span class="n">session</span><span class="p">());</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>如果复制粘贴这一行将会很痛苦。我们可以使用宏来代替吗？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="fm">macro_rules!</span><span class="w"> </span><span class="n">setup_req</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">req</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ServerRequest</span>::<span class="n">new</span><span class="p">(</span><span class="n">server_socket</span><span class="p">.</span><span class="n">session</span><span class="p">());</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">handle_http_request</span><span class="p">(</span><span class="n">server_socket</span>: <span class="kp">&amp;</span><span class="nc">ServerSocket</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">setup_req</span><span class="o">!</span><span class="p">();</span><span class="w">   </span><span class="c1">// 声明`req`，使用了`server_socket`
</span><span class="c1"></span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w"> </span><span class="c1">// 使用`req`的代码
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>显然这么写不能工作。必须要让宏里的<code>server_socket</code>这个名字指向函数里声明的参数<code>server_socket</code>，<code>req</code>变量恰好相反。但hygiene会保护宏里的名字不会和其他作用域里的名字“碰撞”——即使这正是你想要的行为。</p>
<p>解决方案是把你计划在宏里宏外都要使用的变量全部传进宏里：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="fm">macro_rules!</span><span class="w"> </span><span class="n">setup_req</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="cp">$req</span>:<span class="nc">ident</span><span class="p">,</span><span class="w"> </span><span class="cp">$server_socket</span>:<span class="nc">ident</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="cp">$req</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ServerRequest</span>::<span class="n">new</span><span class="p">(</span><span class="cp">$server_socket</span><span class="p">.</span><span class="n">session</span><span class="p">());</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">handle_http_request</span><span class="p">(</span><span class="n">server_socket</span>: <span class="kp">&amp;</span><span class="nc">ServerSocket</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">setup_req</span><span class="o">!</span><span class="p">(</span><span class="n">req</span><span class="p">,</span><span class="w"> </span><span class="n">server_socket</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w"> </span><span class="c1">// 使用`req`的代码
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>因为<code>req</code>和<code>server_socket</code>现在由函数提供，所以它们的“颜色”和那个作用域一样。</p>
<p>hygiene让宏的使用变得更繁琐了一点，但这是一个特性，而不是bug：知道了它们不会在背后扰乱局部变量之后，可以更容易地推理hygiene宏。如果你在一个函数里搜索一个类似<code>server_socket</code>的标识符，你将会发现所有使用了它的地方，包括宏调用。</p>
<h3 id="导入和导出宏">导入和导出宏</h3>
<p>因为宏在编译的早期被展开，此时Rust还不知道你的项目的完整的模块结构，因此编译器有特殊的方法来导入和导出它们。</p>
<p>在一个模块中可见的宏自动地在它的子模块中可见。为了从一个模块“逆向”导出到它的父模块，可以使用<code>#[macro_use]</code>属性。例如，假设我们的 <em>lib.rs</em> 看起来像这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="cp">#[macro_use]</span><span class="w"> </span><span class="k">mod</span> <span class="nn">macros</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">mod</span> <span class="nn">client</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">mod</span> <span class="nn">server</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>macros</code>模块中定义的所有的宏都被导入到了<code>lib.rs</code>，因此它们对crate中的其他部分都可见，包括在<code>client</code>和<code>server</code>中。</p>
<p>使用<code>#[macro_export]</code>标记的宏自动地变为<code>pub</code>并可以和其他item一样通过路径引用。</p>
<p>例如，<code>lazy_static</code> crate提供了一个叫<code>lazy_static</code>的被<code>#[macro_export]</code>标记的宏。为了在你自己的crate中使用这个宏，你可以写：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">lazy_static</span>::<span class="n">lazy_static</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">lazy_static</span><span class="o">!</span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>一旦一个宏被导入之后，就可以像其他的item一样使用它：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">lazy_static</span>::<span class="n">lazy_static</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">mod</span> <span class="nn">m</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">crate</span>::<span class="n">lazy_static</span><span class="o">!</span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>当然，实际上这也意味着你的宏可能会在其他的模块中被调用。因此一个导出的宏不应该依赖任何作用域中的东西——没有办法预测使用它的作用域中会有什么。甚至标准prelude的特性也可以被遮蔽。</p>
<p>因此，宏应该使用绝对路径来表示它用到的任何名称。为此<code>macro_rules!</code>提供了特殊的片段<code>$crate</code>。它和<code>crate</code>不同，后者是一个可以在任何地方的路径中使用的关键字，而不仅仅是在宏里。<code>$crate</code>的含义类似于定义这个宏的crate的根模块的绝对路径。我们可以使用<code>$crate::Json</code>来代替<code>Json</code>，这样即使<code>Json</code>没有被导入也可以工作。<code>HashMap</code>可以改为<code>::std::collections::HashMap</code>或者<code>$crate::macros::HashMap</code>。在后者的情况下，我们需要重新导出<code>HashMap</code>，因为<code>$crate</code>不能用来访问crate的私有特性。它实际上会被展开成类似<code>::jsonlib</code>的普通路径。可见性规则不受影响。</p>
<p>在将宏移动到了它自己的<code>macros</code>模块，并修改它使用<code>$crate</code>之后，它看起来像这样。这是最终的版本：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="c1">// macro.rs
</span><span class="c1"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">collections</span>::<span class="n">HashMap</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">boxed</span>::<span class="nb">Box</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">string</span>::<span class="nb">ToString</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="cp">#[macro_export]</span><span class="w">
</span><span class="w">    </span><span class="fm">macro_rules!</span><span class="w"> </span><span class="n">json</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="n">null</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="cp">$crate</span>::<span class="n">Json</span>::<span class="n">Null</span><span class="w">
</span><span class="w">        </span><span class="p">};</span><span class="w">
</span><span class="w">        </span><span class="p">([</span><span class="w"> </span><span class="cp">$(</span><span class="w"> </span><span class="cp">$element</span>:<span class="nc">tt</span><span class="w"> </span><span class="p">),</span><span class="o">*</span><span class="w"> </span><span class="p">])</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="cp">$crate</span>::<span class="n">Json</span>::<span class="n">Array</span><span class="p">(</span><span class="fm">vec!</span><span class="p">[</span><span class="w"> </span><span class="cp">$(</span><span class="w"> </span><span class="n">json</span><span class="o">!</span><span class="p">(</span><span class="cp">$element</span><span class="p">)</span><span class="w"> </span><span class="p">),</span><span class="o">*</span><span class="w"> </span><span class="p">])</span><span class="w">
</span><span class="w">        </span><span class="p">};</span><span class="w">
</span><span class="w">        </span><span class="p">({</span><span class="w"> </span><span class="cp">$(</span><span class="w"> </span><span class="cp">$key</span>:<span class="nc">tt</span><span class="w"> </span>: <span class="cp">$value</span>:<span class="nc">tt</span><span class="w"> </span><span class="p">),</span><span class="o">*</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">fields</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="cp">$crate</span>::<span class="n">macros</span>::<span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="w">
</span><span class="w">                    </span><span class="cp">$crate</span>::<span class="n">macros</span>::<span class="n">HashMap</span>::<span class="n">new</span><span class="p">());</span><span class="w">
</span><span class="w">                </span><span class="cp">$(</span><span class="w">
</span><span class="w">                    </span><span class="n">fields</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="cp">$crate</span>::<span class="n">macros</span>::<span class="nb">ToString</span>::<span class="n">to_string</span><span class="p">(</span><span class="cp">$key</span><span class="p">),</span><span class="w"> 
</span><span class="w">                                  </span><span class="n">json</span><span class="o">!</span><span class="p">(</span><span class="cp">$value</span><span class="p">));</span><span class="w">
</span><span class="w">                </span><span class="p">)</span><span class="o">*</span><span class="w">
</span><span class="w">                </span><span class="cp">$crate</span>::<span class="n">Json</span>::<span class="n">Object</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">};</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="cp">$other</span>:<span class="nc">tt</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="cp">$crate</span>::<span class="n">Json</span>::<span class="n">from</span><span class="p">(</span><span class="cp">$other</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>因为<code>.to_string()</code>方法是标准的<code>ToString</code> trait的一部分，所以我们也使用了<code>$crate</code>来引用它，并使用了我们在“完全限定方法调用”中介绍过的语法：<code>$crate::macors::ToString::to_string($key)</code>。在我们的例子中，为了让宏能正常工作，这并不是必须的，因为<code>ToString</code>在标准prelude里。但如果你在调用一个trait的方法，并且这个trait可能不在调用处的作用域里，那么完全限定方法调用将是最好的方式。</p>
<h2 id="在匹配时避免语法错误">在匹配时避免语法错误</h2>
<p>下面的宏看起来是有原因的，但它会给Rust带来一些麻烦：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="fm">macro_rules!</span><span class="w"> </span><span class="n">complain</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="cp">$msg</span>:<span class="nc">expr</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;Complaint filed: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="cp">$msg</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">};</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="n">user</span><span class="w"> </span>: <span class="cp">$userid</span>:<span class="nc">tt</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="cp">$msg</span>:<span class="nc">expr</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;Complaint from user {}: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="cp">$userid</span><span class="p">,</span><span class="w"> </span><span class="cp">$msg</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>假如我们像这样调用它：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="n">complain</span><span class="o">!</span><span class="p">(</span><span class="n">user</span>: <span class="s">&#34;jimb&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;the AI lab&#39;s chatbots keep picking on me&#34;</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>以人眼来看，显然这会匹配第二个模式。但Rust会首先尝试第一个规则，尝试用<code>$msg:expr</code>匹配所有的输入。这时事情会变得糟糕起来。<code>user: &quot;jimb&quot;</code>显然不是一个表达式，因此我们会得到一个语法错误。Rust拒绝掩盖语法错误——宏已经足够难调试了。它会立刻报错并中断编译。</p>
<p>如果模式中的其他token匹配失败，rust会移动到下一条规则。只有语法错误会导致终止，并且只有当尝试匹配片段时才会出现语法错误。</p>
<p>这里的问题并不难理解：我们尝试在一条错误的规则中用<code>$msg:expr</code>匹配一个片段。它会匹配失败，因为我们没想过用这条规则来匹配，调用者是希望用另一条规则来匹配。有两种避免这个错误的方式：</p>
<p>第一，避免易混淆的规则。例如，我们可以修改宏，让每一个模式都以一个不同的标识符开头：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="fm">macro_rules!</span><span class="w"> </span><span class="n">complain</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="n">msg</span><span class="w"> </span>: <span class="cp">$msg</span>:<span class="nc">expr</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;Complaint filed: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="cp">$msg</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">};</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="n">user</span><span class="w"> </span>: <span class="cp">$userid</span>:<span class="nc">tt</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span>: <span class="cp">$msg</span>:<span class="nc">expr</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;Complaint from user {}: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="cp">$userid</span><span class="p">,</span><span class="w"> </span><span class="cp">$msg</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>当宏的参数以<code>msg</code>开头时，我们会得到规则1。当它们以<code>user</code>开头时，我们会得到规则2。我们现在可以在尝试匹配一个片段之前得到正确的规则。</p>
<p>另一种避免伪语法错误的方式是把更加具体的规则放在前面。把<code>user :</code>规则放在第一个就可以解决<code>complain!</code>的问题，会导致语法错误的规则不会再被触发。</p>
<h2 id="macro_rules之外"><code>macro_rules!</code>之外</h2>
<p>宏模式可以解析比JSON更复杂得多的输入，但我们会发现它的复杂性很快就脱离了控制。</p>
<p>Daniel Keep等人的<a href="https://danielkeep.github.io/tlborm/book/">The Little Book of Rust Macros</a>是一本优秀的讲解高级<code>macro_rules!</code>编程的书。这本书非常的清楚和聪明，它比我们这里更加详细地描述了宏展开的每一个概念。它还提出了几种非常巧妙的技术，将<code>macro_rules!</code>模式作为一种编程语言来解析复杂的输入。这一点我们不太热衷。请小心使用。</p>
<p>Rust 1.15引入了一种单独的机制称为 <em>过程宏(procedural macros)</em> 。过程宏支持扩展<code>#[derive]</code>属性来实现自定义派生，如”图21-4”所示。还可以创造自定义的属性以及新的和之前介绍的<code>macro_rules!</code>宏调用方式一样的宏。</p>
<p><figure>
  <picture>

    
      
        
        
        
        
        
        
    <img
      loading="lazy"
      decoding="async"
      alt="通过&amp;lt;code&amp;gt;#[derive]&amp;lt;/code&amp;gt;属性来调用一个&amp;lt;code&amp;gt;IntoJson&amp;lt;/code&amp;gt;过程宏"
      
        class="image_figure image_internal image_unprocessed"
        src="../img/f21-4.png"
      
      
    />

    </picture>
</figure>
</p>
<p align="center">图21-4 通过<code>#[derive]</code>属性来调用一个<code>IntoJson</code>过程宏</p>
<p>并不存在<code>IntoJson</code> trait，但没关系：一个过程宏可以使用这种方式来插入它需要的代码（在这个例子中，可能是<code>impl From&lt;Money&gt; for Json { ... }</code>）。</p>
<p>过程宏之所以被称为“过程”是因为它被实现为一个Rust函数，而不是声明规则集。这个函数通过一个简单的抽象层和编译器交互，并且可以非常复杂。例如，<code>diesel</code>数据库的库使用了过程宏来连接到一个数据库并在编译期根据该数据库的模式生成代码。</p>
<p>因为过程宏要和编译器内部交互，编写高效的宏需要了解编译器的工作原理，这超出了本书的范围。然而，它在<a href="https://doc.rust-lang.org/book/ch19-06-macros.html#procedural-macros-for-generating-code-from-attributes">在线文档</a>中有充分的介绍。</p>
<p>也许当读到这里时，你已经决定了你很讨厌宏。那该怎么办呢？一种替代方案是使用构建脚本来生成Rust代码。<a href="https://doc.crates.io/build-script.html#case-study-code-generation">Cargo文档</a>一步步地展示了怎么做到这点。它包含编写一个程序生成你想要的Rust代码、在 <em>Cargo.toml</em> 中添加一行以在构建过程中运行这个程序、使用<code>include!</code>把生成的代码引入你的crate。</p>

    </div>
<div class="post_comments">
  
  
  
</div>




    <hr>

<div id="gitalk-container"></div>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js" crossorigin="anonymous"></script>
    <script type="text/javascript">
      var gitalk = new Gitalk({
        id: '0001-01-01 00:00:00 \u002b0000 UTC',
        title: '',
        clientID: '72786bf87c19beec6abe',
        clientSecret: '93ce647699b49ea6434332d36b0122a4ad8281ad',
        repo: 'buf1024.github.io',
        owner: 'buf1024',
        admin: ['buf1024'],
        body: decodeURI(location.href)
      });
      gitalk.render('gitalk-container');
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/gitalk/gitalk">comments powered by gitalk.</a></noscript>

  </article>
<aside class="sidebar">
  <section class="sidebar_inner">
    <br>
    


    
    
    <h2 class="mt-4">最新文章</h2>
    <ul class="flex-column">
      <li>
        <a href="https://luoguochun.cn/post/2024-01-13-rust-sqlx-sqlbuilder/" class="nav-link" title="Rust sqlx SQLBuilder">Rust sqlx SQLBuilder</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2024-01-08-vite-engineering-config/" class="nav-link" title="前端工程化配置保姆级教程">前端工程化配置保姆级教程</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-12-26-rust-proc-macro/" class="nav-link" title="rust 过程宏">rust 过程宏</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-09-21-rust-panic/" class="nav-link" title="一行代码让 rustc panic">一行代码让 rustc panic</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-07-19-flutter-muti-window/" class="nav-link" title="Flutter 桌面端多窗口支持">Flutter 桌面端多窗口支持</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-07-04-hiqradio/" class="nav-link" title="hiqradio 一个简单的收音机软件">hiqradio 一个简单的收音机软件</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-03-21-android-https/" class="nav-link" title="android https 抓包">android https 抓包</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-03-16-love-for-insterest/" class="nav-link" title="为爱发电终是不能长久的……">为爱发电终是不能长久的……</a>
      </li>
    </ul>
    <div>
      <h2 class="mt-4 taxonomy" id="categories-section">分类</h2>
      <nav class="tags_nav">
        <a href='https://luoguochun.cn/categories/misc/' class="post_tag button button_translucent" title="misc">
          MISC
          <span class="button_tally">11</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/linux/' class="post_tag button button_translucent" title="linux">
          LINUX
          <span class="button_tally">8</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/tcp/' class="post_tag button button_translucent" title="tcp">
          TCP
          <span class="button_tally">8</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/c/' class="post_tag button button_translucent" title="c">
          C
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/flutter/' class="post_tag button button_translucent" title="flutter">
          FLUTTER
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/rust/' class="post_tag button button_translucent" title="rust">
          RUST
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/python/' class="post_tag button button_translucent" title="python">
          PYTHON
          <span class="button_tally">6</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/c&#43;&#43;/' class="post_tag button button_translucent" title="c&#43;&#43;">
          C&#43;&#43;
          <span class="button_tally">4</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/web/' class="post_tag button button_translucent" title="web">
          WEB
          <span class="button_tally">4</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/gcc/' class="post_tag button button_translucent" title="gcc">
          GCC
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/git/' class="post_tag button button_translucent" title="git">
          GIT
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/reactjs/' class="post_tag button button_translucent" title="reactjs">
          REACTJS
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/unittest/' class="post_tag button button_translucent" title="unittest">
          UNITTEST
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/vim/' class="post_tag button button_translucent" title="vim">
          VIM
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/%E6%9E%84%E6%9E%B6/' class="post_tag button button_translucent" title="构架">
          构架
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/asm/' class="post_tag button button_translucent" title="asm">
          ASM
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/docker/' class="post_tag button button_translucent" title="docker">
          DOCKER
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/go/' class="post_tag button button_translucent" title="go">
          GO
          <span class="button_tally">1</span>
        </a>
        
        
      </nav>
    </div>
    <div>
      <h2 class="mt-4 taxonomy" id="tags-section">标签</h2>
      <nav class="tags_nav">
        <a href='https://luoguochun.cn/tags/c/' class="post_tag button button_translucent" title="c">
          C
          <span class="button_tally">21</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/linux/' class="post_tag button button_translucent" title="linux">
          LINUX
          <span class="button_tally">16</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/c&#43;&#43;/' class="post_tag button button_translucent" title="c&#43;&#43;">
          C&#43;&#43;
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/python/' class="post_tag button button_translucent" title="python">
          PYTHON
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/tcp/' class="post_tag button button_translucent" title="tcp">
          TCP
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/dart/' class="post_tag button button_translucent" title="dart">
          DART
          <span class="button_tally">6</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/flutter/' class="post_tag button button_translucent" title="flutter">
          FLUTTER
          <span class="button_tally">6</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/rust/' class="post_tag button button_translucent" title="rust">
          RUST
          <span class="button_tally">4</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/tdd/' class="post_tag button button_translucent" title="tdd">
          TDD
          <span class="button_tally">4</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/android/' class="post_tag button button_translucent" title="android">
          ANDROID
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/git/' class="post_tag button button_translucent" title="git">
          GIT
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/gtest/' class="post_tag button button_translucent" title="gtest">
          GTEST
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/js/' class="post_tag button button_translucent" title="js">
          JS
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/rust-lib/' class="post_tag button button_translucent" title="rust-lib">
          RUST-LIB
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/vcs/' class="post_tag button button_translucent" title="vcs">
          VCS
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/vim/' class="post_tag button button_translucent" title="vim">
          VIM
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/asm/' class="post_tag button button_translucent" title="asm">
          ASM
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/css/' class="post_tag button button_translucent" title="css">
          CSS
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/gas/' class="post_tag button button_translucent" title="gas">
          GAS
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/gcc/' class="post_tag button button_translucent" title="gcc">
          GCC
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/http/' class="post_tag button button_translucent" title="http">
          HTTP
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/libevent/' class="post_tag button button_translucent" title="libevent">
          LIBEVENT
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/macos/' class="post_tag button button_translucent" title="macos">
          MACOS
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/react-native/' class="post_tag button button_translucent" title="react-native">
          REACT-NATIVE
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/redis/' class="post_tag button button_translucent" title="redis">
          REDIS
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/%E6%9E%84%E6%9E%B6/' class="post_tag button button_translucent" title="构架">
          构架
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/api/' class="post_tag button button_translucent" title="api">
          API
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/bt/' class="post_tag button button_translucent" title="bt">
          BT
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/c&#43;/' class="post_tag button button_translucent" title="c&#43;">
          C&#43;
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/coroutine/' class="post_tag button button_translucent" title="coroutine">
          COROUTINE
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/database/' class="post_tag button button_translucent" title="database">
          DATABASE
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/docker/' class="post_tag button button_translucent" title="docker">
          DOCKER
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/endian/' class="post_tag button button_translucent" title="endian">
          ENDIAN
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/frontend/' class="post_tag button button_translucent" title="frontend">
          FRONTEND
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/gdb/' class="post_tag button button_translucent" title="gdb">
          GDB
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/go/' class="post_tag button button_translucent" title="go">
          GO
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/html/' class="post_tag button button_translucent" title="html">
          HTML
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/https/' class="post_tag button button_translucent" title="https">
          HTTPS
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/jquery/' class="post_tag button button_translucent" title="jquery">
          JQUERY
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/ld/' class="post_tag button button_translucent" title="ld">
          LD
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/logger/' class="post_tag button button_translucent" title="logger">
          LOGGER
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/makefile/' class="post_tag button button_translucent" title="makefile">
          MAKEFILE
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/misc/' class="post_tag button button_translucent" title="misc">
          MISC
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/orm/' class="post_tag button button_translucent" title="orm">
          ORM
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/os/' class="post_tag button button_translucent" title="os">
          OS
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/process/' class="post_tag button button_translucent" title="process">
          PROCESS
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/react/' class="post_tag button button_translucent" title="react">
          REACT
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/rpm/' class="post_tag button button_translucent" title="rpm">
          RPM
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/rsa/' class="post_tag button button_translucent" title="rsa">
          RSA
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/server/' class="post_tag button button_translucent" title="server">
          SERVER
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/sqlalchemy/' class="post_tag button button_translucent" title="sqlalchemy">
          SQLALCHEMY
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/ssh/' class="post_tag button button_translucent" title="ssh">
          SSH
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/ssl/tls/' class="post_tag button button_translucent" title="ssl/tls">
          SSL/TLS
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/vc/' class="post_tag button button_translucent" title="vc">
          VC
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/vite/' class="post_tag button button_translucent" title="vite">
          VITE
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/vue/' class="post_tag button button_translucent" title="vue">
          VUE
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/webui/' class="post_tag button button_translucent" title="webui">
          WEBUI
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/wechat/' class="post_tag button button_translucent" title="wechat">
          WECHAT
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/win32/' class="post_tag button button_translucent" title="win32">
          WIN32
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/windows/' class="post_tag button button_translucent" title="windows">
          WINDOWS
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/wireshark/' class="post_tag button button_translucent" title="wireshark">
          WIRESHARK
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/' class="post_tag button button_translucent" title="微服务">
          微服务
          <span class="button_tally">1</span>
        </a>
        
        
      </nav>
    </div>
  </section>
</aside>

  
</div>
  </main><svg width="0" height="0" class="hidden">
  <symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="facebook">
    <path d="M437 0H75C33.648 0 0 33.648 0 75v362c0 41.352 33.648 75 75 75h151V331h-60v-90h60v-61c0-49.629 40.371-90 90-90h91v90h-91v61h91l-15 90h-76v181h121c41.352 0 75-33.648 75-75V75c0-41.352-33.648-75-75-75zm0 0"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18.001 18.001" id="twitter">
    <path d="M15.891 4.013c.808-.496 1.343-1.173 1.605-2.034a8.68 8.68 0 0 1-2.351.861c-.703-.756-1.593-1.14-2.66-1.14-1.043 0-1.924.366-2.643 1.078a3.56 3.56 0 0 0-1.076 2.605c0 .309.039.585.117.819-3.076-.105-5.622-1.381-7.628-3.837-.34.601-.51 1.213-.51 1.846 0 1.301.549 2.332 1.645 3.089-.625-.053-1.176-.211-1.645-.47 0 .929.273 1.705.82 2.388a3.623 3.623 0 0 0 2.115 1.291c-.312.08-.641.118-.979.118-.312 0-.533-.026-.664-.083.23.757.664 1.371 1.291 1.841a3.652 3.652 0 0 0 2.152.743C4.148 14.173 2.625 14.69.902 14.69c-.422 0-.721-.006-.902-.038 1.697 1.102 3.586 1.649 5.676 1.649 2.139 0 4.029-.542 5.674-1.626 1.645-1.078 2.859-2.408 3.639-3.974a10.77 10.77 0 0 0 1.172-4.892v-.468a7.788 7.788 0 0 0 1.84-1.921 8.142 8.142 0 0 1-2.11.593z"
      ></path>
  </symbol>
  <symbol aria-hidden="true" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="mail">
    <path  d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="calendar">
    <path d="M452 40h-24V0h-40v40H124V0H84v40H60C26.916 40 0 66.916 0 100v352c0 33.084 26.916 60 60 60h392c33.084 0 60-26.916 60-60V100c0-33.084-26.916-60-60-60zm20 412c0 11.028-8.972 20-20 20H60c-11.028 0-20-8.972-20-20V188h432v264zm0-304H40v-48c0-11.028 8.972-20 20-20h24v40h40V80h264v40h40V80h24c11.028 0 20 8.972 20 20v48z"></path>
    <path d="M76 230h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zM76 310h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zM76 390h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zm80-80h40v40h-40z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="github">
    <path d="M255.968 5.329C114.624 5.329 0 120.401 0 262.353c0 113.536 73.344 209.856 175.104 243.872 12.8 2.368 17.472-5.568 17.472-12.384 0-6.112-.224-22.272-.352-43.712-71.2 15.52-86.24-34.464-86.24-34.464-11.616-29.696-28.416-37.6-28.416-37.6-23.264-15.936 1.728-15.616 1.728-15.616 25.696 1.824 39.2 26.496 39.2 26.496 22.848 39.264 59.936 27.936 74.528 21.344 2.304-16.608 8.928-27.936 16.256-34.368-56.832-6.496-116.608-28.544-116.608-127.008 0-28.064 9.984-51.008 26.368-68.992-2.656-6.496-11.424-32.64 2.496-68 0 0 21.504-6.912 70.4 26.336 20.416-5.696 42.304-8.544 64.096-8.64 21.728.128 43.648 2.944 64.096 8.672 48.864-33.248 70.336-26.336 70.336-26.336 13.952 35.392 5.184 61.504 2.56 68 16.416 17.984 26.304 40.928 26.304 68.992 0 98.72-59.84 120.448-116.864 126.816 9.184 7.936 17.376 23.616 17.376 47.584 0 34.368-.32 62.08-.32 70.496 0 6.88 4.608 14.88 17.6 12.352C438.72 472.145 512 375.857 512 262.353 512 120.401 397.376 5.329 255.968 5.329z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 212 212" id="gitlab">
    <path d="M12.3 74.7h54L43.3 3c-1-3.6-6.4-3.6-7.6 0L12.3 74.8z" />
    <path d="M12.3 74.7L.5 111c-1 3.2 0 6.8 3 8.8l101.6 74-92.5-119z"/>
    <path d="M105 193.7l-38.6-119h-54l92.7 119z"/>
    <path d="M105 193.7l38.7-119H66.4l38.7 119z"/>
    <path d="M105 193.7l38.7-119H198l-93 119z"/>
    <path d="M198 74.7l11.6 36.2c1 3 0 6.6-3 8.6l-101.5 74 93-119z"/>
    <path d="M198 74.7h-54.3L167 3c1.2-3.6 6.4-3.6 7.6 0L198 74.8z"/>
  </symbol>
  <symbol viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="rss">
    <circle cx="3.429" cy="20.571" r="3.429"></circle>
    <path d="M11.429 24h4.57C15.999 15.179 8.821 8.001 0 8v4.572c6.302.001 11.429 5.126 11.429 11.428z"></path>
    <path d="M24 24C24 10.766 13.234 0 0 0v4.571c10.714 0 19.43 8.714 19.43 19.429z"></path>
  </symbol>
  <symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="linkedin">
    <path d="M437 0H75C33.648 0 0 33.648 0 75v362c0 41.352 33.648 75 75 75h362c41.352 0 75-33.648 75-75V75c0-41.352-33.648-75-75-75zM181 406h-60V196h60zm0-240h-60v-60h60zm210 240h-60V286c0-16.54-13.46-30-30-30s-30 13.46-30 30v120h-60V196h60v11.309C286.719 202.422 296.93 196 316 196c40.691.043 75 36.547 75 79.688zm0 0"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 612 612" id="to-top">
    <path d="M604.501 440.509L325.398 134.956c-5.331-5.357-12.423-7.627-19.386-7.27-6.989-.357-14.056 1.913-19.387 7.27L7.499 440.509c-9.999 10.024-9.999 26.298 0 36.323s26.223 10.024 36.222 0l262.293-287.164L568.28 476.832c9.999 10.024 26.222 10.024 36.221 0 9.999-10.023 9.999-26.298 0-36.323z"></path>
  </symbol>
  <symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="carly">
    <path d="M504.971 239.029L448 182.059V84c0-46.317-37.682-84-84-84h-44c-13.255 0-24 10.745-24 24s10.745 24 24 24h44c19.851 0 36 16.149 36 36v108c0 6.365 2.529 12.47 7.029 16.971L454.059 256l-47.029 47.029A24.002 24.002 0 0 0 400 320v108c0 19.851-16.149 36-36 36h-44c-13.255 0-24 10.745-24 24s10.745 24 24 24h44c46.318 0 84-37.683 84-84v-98.059l56.971-56.971c9.372-9.372 9.372-24.568 0-33.941zM112 192V84c0-19.851 16.149-36 36-36h44c13.255 0 24-10.745 24-24S205.255 0 192 0h-44c-46.318 0-84 37.683-84 84v98.059l-56.971 56.97c-9.373 9.373-9.373 24.568 0 33.941L64 329.941V428c0 46.317 37.682 84 84 84h44c13.255 0 24-10.745 24-24s-10.745-24-24-24h-44c-19.851 0-36-16.149-36-36V320c0-6.365-2.529-12.47-7.029-16.971L57.941 256l47.029-47.029A24.002 24.002 0 0 0 112 192z"></path>
  </symbol>
  <symbol viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="copy">
    <path d="M23 2.75A2.75 2.75 0 0 0 20.25 0H8.75A2.75 2.75 0 0 0 6 2.75v13.5A2.75 2.75 0 0 0 8.75 19h11.5A2.75 2.75 0 0 0 23 16.25zM18.25 14.5h-7.5a.75.75 0 0 1 0-1.5h7.5a.75.75 0 0 1 0 1.5zm0-3h-7.5a.75.75 0 0 1 0-1.5h7.5a.75.75 0 0 1 0 1.5zm0-3h-7.5a.75.75 0 0 1 0-1.5h7.5a.75.75 0 0 1 0 1.5z"></path>
    <path d="M8.75 20.5a4.255 4.255 0 0 1-4.25-4.25V2.75c0-.086.02-.166.025-.25H3.75A2.752 2.752 0 0 0 1 5.25v16A2.752 2.752 0 0 0 3.75 24h12a2.752 2.752 0 0 0 2.75-2.75v-.75z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512.001 512.001" id="closeme">
    <path d="M284.286 256.002L506.143 34.144c7.811-7.811 7.811-20.475 0-28.285-7.811-7.81-20.475-7.811-28.285 0L256 227.717 34.143 5.859c-7.811-7.811-20.475-7.811-28.285 0-7.81 7.811-7.811 20.475 0 28.285l221.857 221.857L5.858 477.859c-7.811 7.811-7.811 20.475 0 28.285a19.938 19.938 0 0 0 14.143 5.857 19.94 19.94 0 0 0 14.143-5.857L256 284.287l221.857 221.857c3.905 3.905 9.024 5.857 14.143 5.857s10.237-1.952 14.143-5.857c7.811-7.811 7.811-20.475 0-28.285L284.286 256.002z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="open-menu">
    <path d="M492 236H20c-11.046 0-20 8.954-20 20s8.954 20 20 20h472c11.046 0 20-8.954 20-20s-8.954-20-20-20zm0-160H20C8.954 76 0 84.954 0 96s8.954 20 20 20h472c11.046 0 20-8.954 20-20s-8.954-20-20-20zm0 320H20c-11.046 0-20 8.954-20 20s8.954 20 20 20h472c11.046 0 20-8.954 20-20s-8.954-20-20-20z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="instagram">
    <path d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948 0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072 3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.163 6.162 6.163 6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zm0 10.162c-2.209 0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796 0-1.441.645-1.441 1.44s.645 1.44 1.441 1.44c.795 0 1.439-.645 1.439-1.44s-.644-1.44-1.439-1.44z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id=youtube>
    <path d="M19.615 3.184c-3.604-.246-11.631-.245-15.23 0-3.897.266-4.356 2.62-4.385 8.816.029 6.185.484 8.549 4.385 8.816 3.6.245 11.626.246 15.23 0 3.897-.266 4.356-2.62 4.385-8.816-.029-6.185-.484-8.549-4.385-8.816zm-10.615 12.816v-8l8 3.993-8 4.007z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="stackoverflow">
    <path d="M21 27v-8h3v11H0V19h3v8h18z"></path><path d="M17.1.2L15 1.8l7.9 10.6 2.1-1.6L17.1.2zm3.7 14.7L10.6 6.4l1.7-2 10.2 8.5-1.7 2zM7.2 12.3l12 5.6 1.1-2.4-12-5.6-1.1 2.4zm-1.8 6.8l13.56 1.96.17-2.38-13.26-2.55-.47 2.97zM19 25H5v-3h14v3z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="xing">
    <path d="M18.188 0c-.517 0-.741.325-.927.66 0 0-7.455 13.224-7.702 13.657.015.024 4.919 9.023 4.919 9.023.17.308.436.66.967.66h3.454c.211 0 .375-.078.463-.22.089-.151.089-.346-.009-.536l-4.879-8.916c-.004-.006-.004-.016 0-.022L22.139.756c.095-.191.097-.387.006-.535C22.056.078 21.894 0 21.686 0h-3.498zM3.648 4.74c-.211 0-.385.074-.473.216-.09.149-.078.339.02.531l2.34 4.05c.004.01.004.016 0 .021L1.86 16.051c-.099.188-.093.381 0 .529.085.142.239.234.45.234h3.461c.518 0 .766-.348.945-.667l3.734-6.609-2.378-4.155c-.172-.315-.434-.659-.962-.659H3.648v.016z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 71 55" id="discord">
    <path d="M60.1045 4.8978C55.5792 2.8214 50.7265 1.2916 45.6527 0.41542C45.5603 0.39851 45.468 0.440769 45.4204 0.525289C44.7963 1.6353 44.105 3.0834 43.6209 4.2216C38.1637 3.4046 32.7345 3.4046 27.3892 4.2216C26.905 3.0581 26.1886 1.6353 25.5617 0.525289C25.5141 0.443589 25.4218 0.40133 25.3294 0.41542C20.2584 1.2888 15.4057 2.8186 10.8776 4.8978C10.8384 4.9147 10.8048 4.9429 10.7825 4.9795C1.57795 18.7309 -0.943561 32.1443 0.293408 45.3914C0.299005 45.4562 0.335386 45.5182 0.385761 45.5576C6.45866 50.0174 12.3413 52.7249 18.1147 54.5195C18.2071 54.5477 18.305 54.5139 18.3638 54.4378C19.7295 52.5728 20.9469 50.6063 21.9907 48.5383C22.0523 48.4172 21.9935 48.2735 21.8676 48.2256C19.9366 47.4931 18.0979 46.6 16.3292 45.5858C16.1893 45.5041 16.1781 45.304 16.3068 45.2082C16.679 44.9293 17.0513 44.6391 17.4067 44.3461C17.471 44.2926 17.5606 44.2813 17.6362 44.3151C29.2558 49.6202 41.8354 49.6202 53.3179 44.3151C53.3935 44.2785 53.4831 44.2898 53.5502 44.3433C53.9057 44.6363 54.2779 44.9293 54.6529 45.2082C54.7816 45.304 54.7732 45.5041 54.6333 45.5858C52.8646 46.6197 51.0259 47.4931 49.0921 48.2228C48.9662 48.2707 48.9102 48.4172 48.9718 48.5383C50.038 50.6034 51.2554 52.5699 52.5959 54.435C52.6519 54.5139 52.7526 54.5477 52.845 54.5195C58.6464 52.7249 64.529 50.0174 70.6019 45.5576C70.6551 45.5182 70.6887 45.459 70.6943 45.3942C72.1747 30.0791 68.2147 16.7757 60.1968 4.9823C60.1772 4.9429 60.1437 4.9147 60.1045 4.8978ZM23.7259 37.3253C20.2276 37.3253 17.3451 34.1136 17.3451 30.1693C17.3451 26.225 20.1717 23.0133 23.7259 23.0133C27.308 23.0133 30.1626 26.2532 30.1066 30.1693C30.1066 34.1136 27.28 37.3253 23.7259 37.3253ZM47.3178 37.3253C43.8196 37.3253 40.9371 34.1136 40.9371 30.1693C40.9371 26.225 43.7636 23.0133 47.3178 23.0133C50.9 23.0133 53.7545 26.2532 53.6986 30.1693C53.6986 34.1136 50.9 37.3253 47.3178 37.3253Z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 17 18" id="mastodon">
    <path
    fill="#ffffff"
    d="m 15.054695,9.8859583 c -0.22611,1.1632697 -2.02517,2.4363497 -4.09138,2.6830797 -1.0774504,0.12856 -2.1382704,0.24673 -3.2694704,0.19484 -1.84996,-0.0848 -3.30971,-0.44157 -3.30971,-0.44157 0,0.1801 0.0111,0.35157 0.0333,0.51194 0.24051,1.82571 1.81034,1.93508 3.29737,1.98607 1.50088,0.0514 2.8373104,-0.37004 2.8373104,-0.37004 l 0.0617,1.35686 c 0,0 -1.0498104,0.56374 -2.9199404,0.66742 -1.03124,0.0567 -2.3117,-0.0259 -3.80308,-0.42069 -3.23454998,-0.85613 -3.79081998,-4.304 -3.87592998,-7.8024197 -0.026,-1.03871 -0.01,-2.01815 -0.01,-2.83732 0,-3.57732 2.34385998,-4.62587996 2.34385998,-4.62587996 1.18184,-0.54277 3.20976,-0.77101 5.318,-0.7882499985409 h 0.0518 C 9.8267646,0.01719834 11.856025,0.24547834 13.037775,0.78824834 c 0,0 2.34377,1.04855996 2.34377,4.62587996 0,0 0.0294,2.63937 -0.32687,4.47183"/>
 <path
    fill="#000000"
    d="m 12.616925,5.6916583 v 4.3315297 h -1.71607 V 5.8189683 c 0,-0.88624 -0.37289,-1.33607 -1.1187604,-1.33607 -0.82467,0 -1.23799,0.53361 -1.23799,1.58875 v 2.30122 h -1.70594 v -2.30122 c 0,-1.05514 -0.4134,-1.58875 -1.23808,-1.58875 -0.74587,0 -1.11876,0.44983 -1.11876,1.33607 v 4.2042197 h -1.71607 V 5.6916583 c 0,-0.88527 0.22541,-1.58876 0.67817,-2.10922 0.46689,-0.52047 1.07833,-0.78727 1.83735,-0.78727 0.87816,0 1.54317,0.33752 1.98288,1.01267 l 0.42744,0.71655 0.42753,-0.71655 c 0.43961,-0.67515 1.10463,-1.01267 1.9828704,-1.01267 0.75893,0 1.37037,0.2668 1.83735,0.78727 0.45268,0.52046 0.67808,1.22395 0.67808,2.10922"/>
  </symbol>
</svg>

<footer class="footer">
  <div class="footer_inner wrap pale">
    <img src='https://luoguochun.cn/icons/apple-touch-icon.png' class="icon icon_2 transparent" alt="BUF1024">
    <p>Copyright&nbsp;2011-&nbsp;<span class="year"></span>&nbsp;BUF1024. All Rights Reserved</p><a class="to_top" href="#documentTop">
  <svg class="icon">
  <title>to-top</title>
  <use xlink:href="#to-top"></use>
</svg>

</a>

  </div>
</footer>

<script type="text/javascript" src="https://luoguochun.cn/zh-cn/js/bundle.884eccc71c2848fb4aeb15945329b5a857717f0313da00cb46b765b5734cfa64b08ce2609627167129c2de17d9b47ed210682f96a2502ebb3aadc73191740211.js" integrity="sha512-iE7MxxwoSPtK6xWUUym1qFdxfwMT2gDLRrdltXNM&#43;mSwjOJglicWcSnC3hfZtH7SEGgvlqJQLrs6rccxkXQCEQ==" crossorigin="anonymous"></script>
</body>

</html>
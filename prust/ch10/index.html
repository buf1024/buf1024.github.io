
<!DOCTYPE html>
<html lang="zh-cn" data-figures=""  class="page"   >

<head>
<title>BUF1024</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">





<meta property="og:locale" content="zh-cn" />

<meta property="og:type" content="article">
<meta name="description" content="枚举与模式 Surprising how much computer stuff makes sense viewed as tragic deprivation of sum types (cf. deprivation of lambdas). ——Graydon Hoare 这一章的第一个话题将是一个古老的、强大 …" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:creator" content="">
<meta name="twitter:title" content="" />
<meta name="twitter:image" content="https://luoguochun.cn"/>
<meta property="og:url" content="https://luoguochun.cn/prust/ch10/" />
<meta property="og:title" content="" />
<meta property="og:description" content="枚举与模式 Surprising how much computer stuff makes sense viewed as tragic deprivation of sum types (cf. deprivation of lambdas). ——Graydon Hoare 这一章的第一个话题将是一个古老的、强大 …" />
<meta property="og:image" content="https://luoguochun.cn" />
  <meta name="keywords" content="blog,computer,luoguochun" />

<link rel="apple-touch-icon" sizes="180x180" href="https://luoguochun.cn/icons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://luoguochun.cn/icons/favicon-32x32.png">
<link rel="manifest" href="https://luoguochun.cn/icons/site.webmanifest">

<link rel="canonical" href="https://luoguochun.cn/prust/ch10/">



<link rel="preload" href="https://luoguochun.cn/css/styles.42e2c5f6d8cf9c52872666f8d8b2678ad0c426978b9d78aff3c33b7a1e7f6f97f54bcdaf0518a25fb0fe26367d04f8b07c683b3b38b331cb098daadee06b1f3e.css" integrity = "sha512-QuLF9tjPnFKHJmb42LJnitDEJpeLnXiv88M7eh5/b5f1S82vBRiiX7D&#43;JjZ9BPiwfGg7OzizMcsJjare4GsfPg==" as="style" crossorigin="anonymous">



<link rel="preload" href="https://luoguochun.cn/zh-cn/js/bundle.884eccc71c2848fb4aeb15945329b5a857717f0313da00cb46b765b5734cfa64b08ce2609627167129c2de17d9b47ed210682f96a2502ebb3aadc73191740211.js" as="script" integrity=
"sha512-iE7MxxwoSPtK6xWUUym1qFdxfwMT2gDLRrdltXNM&#43;mSwjOJglicWcSnC3hfZtH7SEGgvlqJQLrs6rccxkXQCEQ==" crossorigin="anonymous">


<link rel="stylesheet" type="text/css" href="https://luoguochun.cn/css/styles.42e2c5f6d8cf9c52872666f8d8b2678ad0c426978b9d78aff3c33b7a1e7f6f97f54bcdaf0518a25fb0fe26367d04f8b07c683b3b38b331cb098daadee06b1f3e.css" integrity="sha512-QuLF9tjPnFKHJmb42LJnitDEJpeLnXiv88M7eh5/b5f1S82vBRiiX7D&#43;JjZ9BPiwfGg7OzizMcsJjare4GsfPg==" crossorigin="anonymous">

</head>

<body data-code="100" data-lines="false" id="documentTop"
  data-lang="zh-cn">

<header class="nav_header" >
  <nav class="nav"><a href='https://luoguochun.cn' class="nav_brand nav_item" title="BUF1024">BUF1024
  <div class="nav_close">
    <div><svg class="icon">
  <title>open-menu</title>
  <use xlink:href="#open-menu"></use>
</svg>
<svg class="icon">
  <title>closeme</title>
  <use xlink:href="#closeme"></use>
</svg>
</div>
  </div>
</a>

    <div class='nav_body nav_body_left'>
      
      
      
        

  <div class="nav_parent">
    <a href="https://luoguochun.cn/" class="nav_item" title="主页">主页 </a>
  </div>
  <div class="nav_parent">
    <a href="https://luoguochun.cn" class="nav_item" title="链接">链接 <img src='https://luoguochun.cn/icons/caret-icon.svg' alt="icon" class="nav_icon"></a>
    <div class="nav_sub">
      <span class="nav_child"></span>
        <a href="https://luoguochun.cn/talib-doc/" class="nav_child nav_item" title="TA 技术分析库">TA 技术分析库</a>
        <a href="https://luoguochun.cn/hiqradio" class="nav_child nav_item" title="hiqadio网络收音机">hiqadio网络收音机</a>
    </div>
  </div>
  <div class="nav_parent">
    <a href="https://luoguochun.cn/about/" class="nav_item" title="关于">关于 </a>
  </div>
      
<div class='follow'>
<div class="color_mode">
  <input type="checkbox" class="color_choice" id="mode">
</div>

</div>

    </div>
  </nav>
</header>

  <main>
  
<div class="grid-inverse wrap content">
  <article class="post_content">
    <h1 class="post_title"></h1>
  <div class="post_meta">
    <span><svg class="icon">
  <title>calendar</title>
  <use xlink:href="#calendar"></use>
</svg>
</span>
    <span class="post_date">
      Jan 1, 0001</span>
    <span class="post_time"> · 24 min read</span>
    <span class="page_only">&nbsp;·
  <div class="post_share">
    分享到:
    <a href="https://twitter.com/intent/tweet?text=&url=https%3a%2f%2fluoguochun.cn%2fprust%2fch10%2f&tw_p=tweetbutton" class="twitter" title="分享到 Twitter" target="_blank" rel="nofollow">
      <svg class="icon">
  <title>twitter</title>
  <use xlink:href="#twitter"></use>
</svg>

    </a>
    <a href="https://www.facebook.com/sharer.php?u=https%3a%2f%2fluoguochun.cn%2fprust%2fch10%2f&t=" class="facebook" title="分享到 Facebook" target="_blank" rel="nofollow">
      <svg class="icon">
  <title>facebook</title>
  <use xlink:href="#facebook"></use>
</svg>

    </a>
    <a href="#linkedinshare" id = "linkedinshare" class="linkedin" title="分享到 LinkedIn" rel="nofollow">
      <svg class="icon">
  <title>linkedin</title>
  <use xlink:href="#linkedin"></use>
</svg>

    </a>
    <a href="https://luoguochun.cn/prust/ch10/" title="Copy Link" class="link link_yank">
      <svg class="icon">
  <title>copy</title>
  <use xlink:href="#copy"></use>
</svg>

    </a>
  </div>
  </span>
  </div>

    <div class="post_body"><h1 id="枚举与模式">枚举与模式</h1>
<p><em>Surprising how much computer stuff makes sense viewed as tragic deprivation of sum types (cf. deprivation of lambdas).</em></p>
<p align="right">
    ——Graydon Hoare
</p>
<p>这一章的第一个话题将是一个古老的、强大的、可以帮你在短期内完成很多工作的（有代价地）、并且在许多语言中以不同的名字广为人知的特性。但它并不是魔鬼。而是一种用户自定义的数据类型，它是ML和Haskell程序员们熟知的和类型、也是互斥的联合、还是代数数据类型。在Rust中，它们被称为 <em>枚举(enumerations)</em> ，或者简写为 <em>enum</em> 。和魔鬼不同的是，它们非常安全、索取的代价也很小。</p>
<p>C++和C#都有枚举，你可以使用它们来定义自己的类型，这种类型的取值范围是一些命名常量的集合。例如，你可能定义过一个叫<code>Color</code>的类型，取值范围为<code>Red</code>、<code>Orange</code>、<code>Yellow</code>等等。这种枚举在Rust中也能工作，但Rust进一步扩展了枚举。一个Rust枚举可以包含多种不同类型的数据。例如，Rust的<code>Result&lt;String, io::Error&gt;</code>类型就是一个枚举：该类型的值要么是一个包含<code>String</code>的<code>Ok</code>值要么是一个包含<code>io::Error</code>的<code>Err</code>值。这就超出了C++和C#中枚举的能力。它更像C中的<code>union</code>——但和联合不同的是，Rust的枚举是类型安全的。</p>
<p>枚举适用于一个值有多种可能的情况。使用它们的“代价”是你必须使用模式匹配来安全地访问数据，这也是我们这一章中的第二个话题。</p>
<p>如果你使用过Python的解包或者JavaScript中的解构，那你可能觉得模式也很熟悉，但Rust同样扩展了模式。Rust的模式有点像匹配数据的正则表达式。它们被用来测试一个值是否具有特定的期望的形态。它们可以一次从结构体或这元组中提取出多个字段存入局部变量。并且和正则表达式类似，它们很简洁，通常只用单行代码就能完成任务。</p>
<p>这一章将以枚举的基础开始，展示数据怎么被关联到枚举选项以及枚举是怎么存储在内存中的。然后我们会展示Rust的模式和<code>match</code>表达式如何简洁地指定基于枚举、结构体、数组、切片的逻辑。模式也可以包含引用、move和<code>if</code>条件，这让它们的功能更加强大。</p>
<h2 id="枚举">枚举</h2>
<p>简单的C风格枚举非常直观：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">enum</span> <span class="nc">Ordering</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Less</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">Equal</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">Greater</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这里声明了一个有三个可能的值的<code>Ordering</code>类型，这些值被称为 <em>variant</em> 或者 <em>constructor</em> ：<code>Ordering::Less</code>、<code>Ordering::Equal</code>、<code>Ordering::Greater</code>。这个枚举是标准库的一部分，因此Rust代码可以导入它：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">cmp</span>::<span class="n">Ordering</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">compare</span><span class="p">(</span><span class="n">n</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">m</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Ordering</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Ordering</span>::<span class="n">Less</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Ordering</span>::<span class="n">Greater</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Ordering</span>::<span class="n">Equal</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>或者它的所有constructor：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">cmp</span>::<span class="n">Ordering</span>::<span class="p">{</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="p">};</span><span class="w">  </span><span class="c1">// `*`意思是导入所有的子item
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">compare</span><span class="p">(</span><span class="n">n</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">m</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Ordering</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Less</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Greater</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Equal</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>导入constructor之后，我们可以写<code>Less</code>来代替<code>Ordering::Less</code>等，但因为这样不够明显，因此一般认为 <em>不要</em> 导入它们是更好的风格，除非它能使你的代码可读性更强。</p>
<p>为了导入一个在当前模块中声明的枚举的constructor，可以使用<code>self</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">enum</span> <span class="nc">Pet</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Orca</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">Giraffe</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="bp">self</span>::<span class="n">Pet</span>::<span class="o">*</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>在内存中，C风格的枚举值被存储为整数。有时告诉Rust使用哪些整数会很有用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">enum</span> <span class="nc">HttpStatus</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">200</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">NotModified</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">304</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">NotFound</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">404</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>否则，Rust会从0开始自动分配值。</p>
<p>默认情况下，Rust用能容纳所有值的最小的内建整数类型来存储C风格枚举。大多数情况下都是一个单独的字节：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">mem</span>::<span class="n">size_of</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">size_of</span>::<span class="o">&lt;</span><span class="n">Ordering</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">size_of</span>::<span class="o">&lt;</span><span class="n">HttpStatus</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"> </span><span class="c1">// 404不能存储在u8中
</span></code></pre></td></tr></table>
</div>
</div><p>你可以通过添加<code>#[repr]</code>属性来覆盖Rust选择的内存表示方式。更多的细节见“寻找公共的数据表示”。</p>
<p>将C风格的枚举转换为整数是允许的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">HttpStatus</span>::<span class="nb">Ok</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="mi">200</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>然而，反过来把整数转换为枚举是不允许的。和C和C++不同，Rust保证枚举的值只能是<code>enum</code>生命中列出的值之一。未经检查的从整数类型到枚举类型的转换会打破这种保证，所以它是不允许的。你可以写出你自己的带检查的版本：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">http_status_from_u32</span><span class="p">(</span><span class="n">n</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">HttpStatus</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="mi">200</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">HttpStatus</span>::<span class="nb">Ok</span><span class="p">),</span><span class="w">
</span><span class="w">            </span><span class="mi">304</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">HttpStatus</span>::<span class="n">NotModified</span><span class="p">),</span><span class="w">
</span><span class="w">            </span><span class="mi">404</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">HttpStatus</span>::<span class="n">NotFound</span><span class="p">),</span><span class="w">
</span><span class="w">            </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">            </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>或者使用<a href="https://crates.io/crates/enum_primitive"><code>enum_primitive</code></a> crate。它包含一个宏可以为你自动生成这种类型的转换代码。</p>
<p>和结构体一样，编译器也可以为枚举自动生成类似<code>==</code>运算符这样的特性，但需要显式地要求：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="cp">#[derive(Copy, Clone, Debug, PartialEq, Eq)]</span><span class="w">
</span><span class="w">    </span><span class="k">enum</span> <span class="nc">TimeUnit</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Seconds</span><span class="p">,</span><span class="w"> </span><span class="n">Minutes</span><span class="p">,</span><span class="w"> </span><span class="n">Hours</span><span class="p">,</span><span class="w"> </span><span class="n">Days</span><span class="p">,</span><span class="w"> </span><span class="n">Months</span><span class="p">,</span><span class="w"> </span><span class="n">Years</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>枚举也和结构体一样可以拥有方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="n">TimeUnit</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="sd">/// 返回该时间单位的复数名词。
</span><span class="sd"></span><span class="w">        </span><span class="k">fn</span> <span class="nf">plural</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">&#39;</span><span class="nb">static</span> <span class="kt">str</span> <span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="n">TimeUnit</span>::<span class="n">Seconds</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&#34;seconds&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">                </span><span class="n">TimeUnit</span>::<span class="n">Minutes</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&#34;minutes&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">                </span><span class="n">TimeUnit</span>::<span class="n">Hours</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&#34;hours&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">                </span><span class="n">TimeUnit</span>::<span class="n">Days</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&#34;days&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">                </span><span class="n">TimeUnit</span>::<span class="n">Months</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&#34;months&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">                </span><span class="n">TimeUnit</span>::<span class="n">Years</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&#34;years&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="sd">/// 返回该时间单位的单数名词。
</span><span class="sd"></span><span class="w">        </span><span class="k">fn</span> <span class="nf">singular</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">&#39;</span><span class="nb">static</span> <span class="kt">str</span> <span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">plural</span><span class="p">().</span><span class="n">trim_end_matches</span><span class="p">(</span><span class="sc">&#39;s&#39;</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>C风格的枚举就这么多内容了。Rust中最有趣的一类枚举是那些带有数据的枚举。我们将展示这些枚举如何存储在内存中、如何通过添加类型参数将它们变为泛型的，以及如何通过枚举构建复杂的数据结构。</p>
<h3 id="带有数据的枚举">带有数据的枚举</h3>
<p>一些程序总是需要显示完整的日期和时间，并且精确到毫秒。但对于大多数程序，显示大概的时间范围会更加友好，例如“两个月以前”。我们可以用之前定义的枚举编写一个新的枚举来实现这一点：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="sd">/// 一个故意舍入的时间戳，因此我们的程序会显示“6个月以前”
</span><span class="sd"></span><span class="w">    </span><span class="sd">/// 而不是“February 9, 2016, at 9:49 AM”。
</span><span class="sd"></span><span class="w">    </span><span class="cp">#[derive(Copy, Clone, Debug, PartialEq)]</span><span class="w">
</span><span class="w">    </span><span class="k">enum</span> <span class="nc">RoughTime</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">InThePast</span><span class="p">(</span><span class="n">TimeUnit</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">JustNow</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">InTheFuture</span><span class="p">(</span><span class="n">TimeUnit</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这个枚举中的两个variant，即<code>InThePast</code>和<code>InTheFuture</code>都有参数。这些被称为 <em>tuple variant</em> 。就像类元组结构体一样，它们的constructor是创建新的<code>RoughTime</code>值的函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">four_score_and_seven_years_ago</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RoughTime</span>::<span class="n">InThePast</span><span class="p">(</span><span class="n">TimeUnit</span>::<span class="n">Years</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">7</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">three_hours_from_now</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RoughTime</span>::<span class="n">InTheFuture</span><span class="p">(</span><span class="n">TimeUnit</span>::<span class="n">Hours</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>枚举也可以有 <em>struct variant</em> ，它们和普通的结构体一样拥有命名字段：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">enum</span> <span class="nc">Shape</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Sphere</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">center</span>: <span class="nc">Point3d</span><span class="p">,</span><span class="w"> </span><span class="n">radius</span>: <span class="kt">f32</span> <span class="p">},</span><span class="w">
</span><span class="w">        </span><span class="n">Cuboid</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">corner1</span>: <span class="nc">Point3d</span><span class="p">,</span><span class="w"> </span><span class="n">corner2</span>: <span class="nc">Point3d</span><span class="w"> </span><span class="p">},</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">unit_sphere</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Shape</span>::<span class="n">Sphere</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">center</span>: <span class="nc">ORIGIN</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">radius</span>: <span class="mf">1.0</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>总的来说，Rust有三种枚举variant，分别对应我们在上一章中展示的三种结构体。没有数据的variant对应类单元结构体。元组variant对应类元组结构体。结构体variant对应有花括号和命名字段的结构体。一个枚举可以同时有这三种variant：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">enum</span> <span class="nc">RelationshipStatus</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Single</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">InARelationship</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">ItsComplicated</span><span class="p">(</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">ItsExtremelyComplicated</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">car</span>: <span class="nc">DifferentialEquation</span><span class="p">,</span><span class="w"> 
</span><span class="w">            </span><span class="n">cdr</span>: <span class="nc">EarlyModernistPoem</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">},</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>所有种类的constructor都和枚举自身有相同的可见性。</p>
<h3 id="内存中的枚举">内存中的枚举</h3>
<p>在内存中，带有数据的枚举被存储为一个很小的整数 <em>标签(tag)</em> ，加上一块足够存储所有variant中最大的那个的内存。标签字段是Rust内部要使用的，它表示是哪一个constructor创建了这个值，进而得知这个值有哪些字段。</p>
<p>在Rust 1.50中，<code>RoughTime</code>存储为8个字节，如”图10-1”所示。</p>
<p><figure>
  <picture>

    
      
        
        
        
        
        
        
    <img
      loading="lazy"
      decoding="async"
      alt="内存中的&amp;lt;code&amp;gt;RoughTime&amp;lt;/code&amp;gt;值"
      
        class="image_figure image_internal image_unprocessed"
        src="../img/f10-1.png"
      
      
    />

    </picture>
</figure>
</p>
<p align="center">图10-1 内存中的<code>RoughTime</code>值</p>
<p>对于枚举的布局Rust不做任何保证。然而，为了给将来的优化留下余地，在一些情况下它可能会用比图中所示更加高效的方式包装一个枚举。例如，一些泛型结构体可以不用标签存储，我们稍后会讲到它。</p>
<h3 id="使用枚举实现富数据结构">使用枚举实现富数据结构</h3>
<p>枚举在实现树形结构时也很有用。例如，假设一个Rust程序要处理任意的Json数据。在内存中，任何Json文档都可以被表示为一个这种Rust类型的值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">collections</span>::<span class="n">HashMap</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">enum</span> <span class="nc">Json</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Null</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">Boolean</span><span class="p">(</span><span class="kt">bool</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">Number</span><span class="p">(</span><span class="kt">f64</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="nb">String</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">Array</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Json</span><span class="o">&gt;</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">Object</span><span class="p">(</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">Json</span><span class="o">&gt;&gt;</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>与Rust代码相比，用英文来解释这个数据结构也不会再有太大的改进了。JSON标准定义了可以出现在JSON文档中的数据类型：<code>null</code>、布尔值、数字、字符串、JSON值的数组、以及带有字符串键和JSON值的对象。这个<code>Json</code>枚举简单地列出了这些类型。</p>
<p>这并不是一个假想的例子。你可以在<code>serde_json</code> crate中找到一个非常相似的枚举，它是一个用于Rust结构体序列化的库，也是crates.io上下载次数最多的crate之一。</p>
<p>用于表示<code>Object</code>的<code>HashMap</code>外层的<code>Box</code>只是为了让<code>Json</code>值更加紧凑。在内存中，<code>Json</code>类型的值将占据4个机器字。<code>String</code>和<code>Vec</code>都是3个字，Rust会再添加一个字节的标签，再加上对齐所以总共是4个字。<code>Null</code>和<code>Boolean</code>值没有足够的数据利用全部的空间，但所有的<code>Json</code>值大小必须相同，因此这时多余的空间就被浪费了。”图10-2”展示了一些示例的<code>Json</code>值在内存中的实际视图。</p>
<p><figure>
  <picture>

    
      
        
        
        
        
        
        
    <img
      loading="lazy"
      decoding="async"
      alt="内存中的&amp;lt;code&amp;gt;Json&amp;lt;/code&amp;gt;值"
      
        class="image_figure image_internal image_unprocessed"
        src="../img/f10-2.png"
      
      
    />

    </picture>
</figure>
</p>
<p align="center">图10-2 内存中的<code>Json</code>值</p>
<p><code>HashMap</code>会更大一些，如果我们一定要在每一个<code>Json</code>值中给它留出空间，它会变大到8个字。但<code>Box&lt;HashMap&gt;</code>是单个字：它只是一个指向堆上分配的数据的指针。我们甚至可以通过装箱更多的字段来让<code>Json</code>变得更加紧凑。</p>
<p>这里优秀的地方在于，我们如此简单的就完成了这一切。如果是在C++中，可能要写一个这样的一个类才行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="n">class</span><span class="w"> </span><span class="n">JSON</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">private</span>:
        <span class="nc">enum</span><span class="w"> </span><span class="n">Tag</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Null</span><span class="p">,</span><span class="w"> </span><span class="n">Boolean</span><span class="p">,</span><span class="w"> </span><span class="n">Number</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">Array</span><span class="p">,</span><span class="w"> </span><span class="n">Object</span><span class="w">
</span><span class="w">        </span><span class="p">};</span><span class="w">
</span><span class="w">        </span><span class="k">union</span> <span class="nc">Data</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kt">bool</span><span class="w"> </span><span class="n">boolean</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="n">double</span><span class="w"> </span><span class="n">number</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="kt">str</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">JSON</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">array</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">JSON</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">object</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">            </span><span class="n">Data</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">            </span><span class="o">~</span><span class="n">Data</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">            </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">        </span><span class="p">};</span><span class="w">
</span><span class="w">        
</span><span class="w">        </span><span class="n">Tag</span><span class="w"> </span><span class="n">tag</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="n">Data</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="n">public</span>:
        <span class="kt">bool</span> <span class="nc">is_null</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">tag</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Null</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_boolean</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">tag</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Boolean</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">get_boolean</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">assert</span><span class="p">(</span><span class="n">is_boolean</span><span class="p">());</span><span class="w">
</span><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">boolean</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="n">void</span><span class="w"> </span><span class="n">set_boolean</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">this</span>-&gt;<span class="o">~</span><span class="n">JSON</span><span class="p">();</span><span class="w">  </span><span class="c1">// 清除string/array/object值
</span><span class="c1"></span><span class="w">            </span><span class="n">tag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Boolean</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="n">data</span><span class="p">.</span><span class="n">boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>30行代码，我们才刚刚开始。这个类还需要构造函数、析构函数、一个赋值运算符。另一种方案是通过继承，首先创建一个基类<code>JSON</code>和它的子类<code>JSONBoolean</code>、<code>JSONString</code>等等。无论哪种方式，等到完成之后，我们的C++ JSON库都要有一堆代码了。其他程序员需要花费不少精力来阅读和使用它。而Rust的整个枚举只需要8行代码。</p>
<h3 id="泛型枚举">泛型枚举</h3>
<p>枚举可以是泛型的。标准库的两个例子几乎是整个语言中使用最广泛的数据类型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">enum</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">T</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">enum</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">T</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">E</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>到现在这些类型你应该已经很熟悉了，泛型枚举的语法和泛型结构体完全相同。</p>
<p>一个不明显的细节是当类型<code>T</code>是引用、<code>Box</code>或其他智能指针类型时，Rust可以省略<code>Option&lt;T&gt;</code>的标签字段。因为这些指针类型中的任何一个都不允许为0，所以Rust可以用单个机器字来表示<code>Option&lt;Box&lt;i32&gt;&gt;</code>：用0表示<code>None</code>，用非0表示<code>Some</code>指针。这使得这样的<code>Option</code>类型与C和C++中可以为空的指针值非常相似。不同之处在于Rust的类型系统要求你必须先检查<code>Option</code>的值是<code>Some</code>，然后才能使用它内含的值。这有效的避免了空指针解引用。</p>
<p>泛型数据结构体可以用很少的几行代码构建：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="c1">// 一个`T`类型的有序集合
</span><span class="c1"></span><span class="w">    </span><span class="k">enum</span> <span class="nc">BinaryTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Empty</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">NonEmpty</span><span class="p">(</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// 二叉树的一部分
</span><span class="c1"></span><span class="w">    </span><span class="k">struct</span> <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">element</span>: <span class="nc">T</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">left</span>: <span class="nc">BinaryTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">right</span>: <span class="nc">BinaryTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这几行代码定义了一个可以存储任意数量的<code>T</code>类型值的<code>BinaryTree</code>类型。</p>
<p>这两个定义包含了大量信息，所以我们将花费一些时间把代码翻译为中文。每一个<code>BinaryTree</code>值是<code>Empty</code>或者<code>NonEmpty</code>。如果它是<code>Empty</code>，那么它不包含任何数据。如果是<code>NonEmpty</code>，那么它会包含一个<code>Box</code>，这个指针指向一个在堆上分配的<code>TreeNode</code>值。</p>
<p>每一个<code>TreeNode</code>值包含一个实际的元素，和两个<code>BinaryTree</code>值。这意味着一棵树可以包含子树，因此一个<code>NonEmpty</code>树可以包含任意数量的后代节点。</p>
<p>一个<code>BinaryTree&lt;&amp;str&gt;</code>类型的值的视图如”图10-3”所示。因为对于<code>Option&lt;Box&lt;T&gt;&gt;</code>，Rust会省略标签字段，所以一个<code>BinaryTree</code>值只占一个机器字。</p>
<p><figure>
  <picture>

    
      
        
        
        
        
        
        
    <img
      loading="lazy"
      decoding="async"
      alt="一个包含6个字符串的&amp;lt;code&amp;gt;BinaryTree&amp;lt;/code&amp;gt;"
      
        class="image_figure image_internal image_unprocessed"
        src="../img/f10-3.png"
      
      
    />

    </picture>
</figure>
</p>
<p align="center">图10-3 一个包含6个字符串的<code>BinaryTree</code></p>
<p>构建这棵树中的节点非常直观：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="bp">self</span>::<span class="n">BinaryTree</span>::<span class="o">*</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">jupiter_tree</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NonEmpty</span><span class="p">(</span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">TreeNode</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">element</span>: <span class="s">&#34;Jupiter&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">left</span>: <span class="nc">Empty</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">right</span>: <span class="nc">Empty</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">}));</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>更大的树可以通过较小的树构建：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">mars_tree</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NonEmpty</span><span class="p">(</span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">TreeNode</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">element</span>: <span class="s">&#34;Mars&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">left</span>: <span class="nc">jupiter_tree</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">right</span>: <span class="nc">mercury_tree</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">}));</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>自然地，这个赋值会把<code>jupiter_node</code>和<code>mercury_node</code>的所有权移动到新的父节点里。</p>
<p>树的其他部分遵循相同的模式。根节点和其它节点不同：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">tree</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NonEmpty</span><span class="p">(</span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">TreeNode</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">element</span>: <span class="s">&#34;Saturn&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">left</span>: <span class="nc">mars_tree</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">right</span>: <span class="nc">uranus_tree</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">}));</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>在这一章的后续部分中，我们将介绍怎么在<code>BinaryTree</code>类型上实现一个<code>add</code>方法，这样我们就可以这样写：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">tree</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BinaryTree</span>::<span class="n">Empty</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">planet</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">planets</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">tree</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">planet</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>无论你之前用什么语言，在Rust中创建像<code>BinaryTree</code>这样的数据结构都需要一些练习。一开始把<code>Box</code>放在哪可能并不明显。一种寻找设计的方法是画一幅像”图10-3”这样的内存布局图。然后根据图设计代码：每一个矩形都是一个结构体或者元组，每一个箭头都是一个<code>Box</code>或者其他智能指针。搞清楚每个字段的类型有点困难，但解决难题的回报是控制程序的内存使用。</p>
<p>现在就到了我们在本章开始时提到的“代价”。枚举的标签字段要占用很小的内存，最糟的情况下要占用8个字节，但这种情况通常非常少见。枚举真正的缺点（如果它能被称为缺点的话）是Rust不能忽略安全性、不管当前的值是什么直接尝试访问字段：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shape</span><span class="p">.</span><span class="n">radius</span><span class="p">;</span><span class="w">   </span><span class="c1">// 错误：`Shape`类型没有字段`radius`
</span></code></pre></td></tr></table>
</div>
</div><p>访问枚举中的值的唯一方式是：使用模式，这是一种安全的方式。</p>
<h2 id="模式">模式</h2>
<p>回顾一下我们在本章中定义过的<code>RoughTime</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">enum</span> <span class="nc">RoughTime</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">InThePast</span><span class="p">(</span><span class="n">TimeUnit</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">JustNow</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">InTheFuture</span><span class="p">(</span><span class="n">TimeUnit</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>假设你有一个<code>RoughTime</code>值并且你想在网页中显示它。你需要访问值里的<code>TimeUnit</code>和<code>u32</code>字段。Rust不允许你直接通过<code>rough_time.0</code>和<code>rough_time.1</code>访问它们，因为毕竟此时值也可能是<code>RoughTime::JustNow</code>，而它没有字段。那么，你怎么获取数据呢？</p>
<p>你需要一个<code>match</code>表达式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">rough_time_to_english</span><span class="p">(</span><span class="n">rt</span>: <span class="nc">RoughTime</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">rt</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">RoughTime</span>::<span class="n">InThePast</span><span class="p">(</span><span class="n">units</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w">
</span><span class="w">                </span><span class="fm">format!</span><span class="p">(</span><span class="s">&#34;{} {} ago&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">units</span><span class="p">.</span><span class="n">plural</span><span class="p">()),</span><span class="w">
</span><span class="w">            </span><span class="n">RoughTime</span>::<span class="n">JustNow</span><span class="w"> </span><span class="o">=&gt;</span><span class="w">
</span><span class="w">                </span><span class="fm">format!</span><span class="p">(</span><span class="s">&#34;just now&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">            </span><span class="n">RoughTime</span>::<span class="n">InTheFuture</span><span class="p">(</span><span class="n">units</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w">
</span><span class="w">                </span><span class="fm">format!</span><span class="p">(</span><span class="s">&#34;{} {} from now&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">units</span><span class="p">.</span><span class="n">plural</span><span class="p">()),</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>match</code>会进行模式匹配。在这个例子中， <em>模式</em> 是第3、5、7行中出现在<code>=&gt;</code>符号左边的部分。匹配<code>RoughTime</code>值的模式看起来就像是一个创建<code>RoughTime</code>值的表达式。这并不是巧合。表达式 <em>产生</em> 值，模式 <em>消耗</em> 值。它们使用相同的语法。</p>
<p>让我们逐步看看运行这个 <em>match</em> 表达式时发生了什么。假设<code>rt</code>的值是<code>RoughTime::InTheFuture(TimeUnit::Months, 1)</code>。Rust首先尝试将这个值和第3行的模式匹配。正如”图10-4”所示，它并不能匹配。</p>
<p><figure>
  <picture>

    
      
        
        
        
        
        
        
    <img
      loading="lazy"
      decoding="async"
      alt="一个&amp;lt;code&amp;gt;RoughTime&amp;lt;/code&amp;gt;值和不匹配的模式"
      
        class="image_figure image_internal image_unprocessed"
        src="../img/f10-4.png"
      
      
    />

    </picture>
</figure>
</p>
<p align="center">图10-4 一个<code>RoughTime</code>值和不匹配的模式</p>
<p>Rust中使用模式来匹配一个枚举、结构体或者元组，它的工作原理就好像简单地从左到右扫描，检查模式中的每个部分来看看是不是和值匹配。如果不是，Rust会移动到下一个模式。</p>
<p>第3和第5行的模式都匹配失败。但第7行的模式成功了（”图10-5”）。</p>
<p><figure>
  <picture>

    
      
        
        
        
        
        
        
    <img
      loading="lazy"
      decoding="async"
      alt="一个成功的匹配"
      
        class="image_figure image_internal image_unprocessed"
        src="../img/f10-5.png"
      
      
    />

    </picture>
</figure>
</p>
<p align="center">图10-5 一个成功的匹配</p>
<p>如果模式包含像<code>units</code>和<code>count</code>这样的简单标识符时，在匹配后的代码中它们会变为局部变量。被匹配的值里的任何内容都会被拷贝或移动到新变量中。Rust把<code>TimeUnit::Months</code>存储在<code>units</code>中，把<code>1</code>存储在<code>count</code>中，然后运行第8行的代码，最后返回字符串<code>&quot;1 months from now&quot;</code>。</p>
<p>这个输出有一点语法上的错误，可以通过给<code>match</code>添加另一个分支来修正：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="n">RoughTime</span>::<span class="n">InTheFuture</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w">
</span><span class="w">        </span><span class="fm">format!</span><span class="p">(</span><span class="s">&#34;a {} from now&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">unit</span><span class="p">.</span><span class="n">singular</span><span class="p">()),</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>只有当<code>count</code>字段恰好是1时这个分支才能匹配。注意这一段新代码必须添加到第7行之前。如果我们把它添加在最后，那么执行流永远不会到达它，因为第7行匹配所有的<code>InTheFuture</code>值。如果你犯了这种错误，Rust编译器会给出一个“不可达的模式”警告。</p>
<p>即使有了新的代码，<code>RoughTime::InTheFuture(TimeUnit::Hours, 1)</code>仍然有一个问题：结果<code>&quot;a hour from now&quot;</code>在英语中并不是完全正确。这可以通过给<code>match</code>添加另一个分支来修复。</p>
<p>正如这个例子所示，模式匹配和枚举协同工作，甚至可以测试它们包含的值，这使得<code>match</code>表达式成为C的<code>switch</code>语句的一个更强大、更灵活的替代。</p>
<p>到目前为止，我们只见到了匹配枚举值的模式。其实它还有更多用途。Rust的模式有它们自己的语言，”表10-1”中进行了总结。我们将用本章中剩下的大部分内容来展示表中的特性。</p>
<table>
<thead>
<tr>
<th><strong>模式类型</strong></th>
<th><strong>示例</strong></th>
<th><strong>注释</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>字面量</td>
<td><code>100</code> <br> <code>&quot;name&quot;</code></td>
<td>匹配一个精确值，也可以使用一个<code>const</code>的值的名称</td>
</tr>
<tr>
<td>范围</td>
<td><code>0 ..= 100</code> <br> <code>'a' ..= 'k'</code></td>
<td>匹配范围内的任何值，包括终点值</td>
</tr>
<tr>
<td>通配符</td>
<td><code>_</code></td>
<td>匹配任何值并忽略</td>
</tr>
<tr>
<td>变量</td>
<td><code>name</code> <br> <code>mut count</code></td>
<td>类似<code>_</code>但是把值移动或拷贝进新的局部变量</td>
</tr>
<tr>
<td><code>ref</code>变量</td>
<td><code>ref field</code> <br> <code>ref mut field</code></td>
<td>借用匹配的值的引用，而不是移动或拷贝它</td>
</tr>
<tr>
<td>带子模式的绑定</td>
<td><code>val @ 0 ..= 99</code> <br> <code>ref circle @ Shape::Circle { .. }</code></td>
<td>匹配@右侧的模式，使用左侧作为变量名</td>
</tr>
<tr>
<td>枚举模式</td>
<td><code>Some(value)</code> <br> <code>None</code> <br> <code>Pet::Orca</code></td>
<td></td>
</tr>
<tr>
<td>元组模式</td>
<td><code>(key, value)</code> <br> <code>(r, g, b)</code></td>
<td></td>
</tr>
<tr>
<td>数组模式</td>
<td><code>[a, b, c, d, e, f, g]</code> <br> <code>[heading, carom, correction]</code></td>
<td></td>
</tr>
<tr>
<td>切片模式</td>
<td><code>[first, second]</code> <br> <code>[first, _, third]</code> <br> <code>[first, .., nth]</code> <br> <code>[]</code></td>
<td></td>
</tr>
<tr>
<td>结构体模式</td>
<td><code>Color(r, g, b)</code> <br> <code>Point { x, y }</code> <br> <code>Card { suit: Clubs, rank: n }</code> <br> <code>Account { id, name, .. }</code></td>
<td></td>
</tr>
<tr>
<td>引用</td>
<td><code>&amp;value</code> <br> <code>&amp;(k, v)</code></td>
<td>只匹配引用值</td>
</tr>
<tr>
<td>多重模式</td>
<td><code>'a' | 'A'</code></td>
<td>只能用作可反驳的模式（<code>match, if let, while let</code>）</td>
</tr>
<tr>
<td>守卫表达式</td>
<td><code>x if x * x &lt;= r2</code></td>
<td>只能在<code>match</code>中使用（在<code>let</code>等表达式中无效）</td>
</tr>
</tbody>
</table>
<h3 id="模式中的字面量变量和通配符">模式中的字面量、变量和通配符</h3>
<p>到目前为止，我们已经展示了<code>match</code>表达式和枚举一起使用，其实其他类型也可以用模式来匹配。当你需要类似C的<code>switch</code>语句的功能时，可以使用处理整数值的<code>match</code>表达式。整数字面量例如<code>0</code>和<code>1</code>可以用作模式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">meadow</span><span class="p">.</span><span class="n">count_rabbits</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="mi">0</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// 什么都不输出
</span><span class="c1"></span><span class="w">        </span><span class="mi">1</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;A rabbit is nosing around in the clover.&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">n</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;There are {} rabbits hopping about in the meadow&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>当草地上没有兔子时模式<code>0</code>会匹配，当只有一只时<code>1</code>会匹配。如果有两只或者更多兔子，就会到达第三个模式<code>n</code>。这个模式只有一个变量名。它可以匹配任何值，被匹配的值会被移动或拷贝进新的局部变量。因此在这个例子中，<code>meadow.count_rabbits()</code>的值被存储在一个新的局部变量<code>n</code>中，然后我们打印出它。</p>
<p>其他的字面量也可以用作模式，包括布尔值、字符、甚至字符串：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">calendar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">settings</span><span class="p">.</span><span class="n">get_string</span><span class="p">(</span><span class="s">&#34;calendar&#34;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="s">&#34;gregorian&#34;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w">  </span><span class="n">Calendar</span>::<span class="n">Gregorian</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="s">&#34;chinese&#34;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">Calendar</span>::<span class="n">Chinese</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="s">&#34;ethiopian&#34;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">Calendar</span>::<span class="n">Ethiopian</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">other</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">parse_error</span><span class="p">(</span><span class="s">&#34;calendar&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>在这个例子中，<code>other</code>和上个例子中的<code>n</code>一样用作匹配任何值的模式。这些模式和<code>switch</code>语句中的<code>default</code>标签一样，用来匹配其他所有模式都匹配不了的值。</p>
<p>如果你需要一个匹配所有值的模式，但又不关心匹配到的值，你可以使用单个下划线<code>_</code>作为模式，也就是 <em>通配模式</em> ：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">caption</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">photo</span><span class="p">.</span><span class="n">tagged_pet</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Pet</span>::<span class="n">Tyrannosaur</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&#34;RRRAAAAAHHHHHH&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">Pet</span>::<span class="n">Samoyed</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&#34;*dog thoughts*&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&#34;I&#39;m cute, love me&#34;</span><span class="p">,</span><span class="w">   </span><span class="c1">// 通用标题，用于任何宠物
</span><span class="c1"></span><span class="w">    </span><span class="p">};</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>通配模式匹配任何值，但并不存储它。因为Rust要求每一个<code>match</code>表达式要能处理所有可能的值，因此最后通常需要一个通配符。即使你非常确信其他的情况不会发生，你也必须至少添加一个fallback分支，这个分支里可以直接panic：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="c1">// 有很多形状，但我们只支持“选择”文本或者一个矩形区域。
</span><span class="c1"></span><span class="w">    </span><span class="c1">// 你不能选择一个椭圆或者梯形。
</span><span class="c1"></span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">document</span><span class="p">.</span><span class="n">selection</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Shape</span>::<span class="n">TextSpan</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">paint_text_selection</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">Shape</span>::<span class="n">Rectangle</span><span class="p">(</span><span class="n">rect</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">paint_rect_selection</span><span class="p">(</span><span class="n">rect</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&#34;unexpected selection type&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="元组和结构体模式">元组和结构体模式</h3>
<p>元组模式匹配元组。当你想在单个<code>match</code>中获得数据的多个部分时它们会很有用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">describe_point</span><span class="p">(</span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">&#39;</span><span class="nb">static</span> <span class="kt">str</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">cmp</span>::<span class="n">Ordering</span>::<span class="o">*</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">y</span><span class="p">.</span><span class="n">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="p">(</span><span class="n">Equal</span><span class="p">,</span><span class="w"> </span><span class="n">Equal</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&#34;at the origin&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">Equal</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&#34;on the x axis&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="p">(</span><span class="n">Equal</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&#34;on the y axis&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="p">(</span><span class="n">Greater</span><span class="p">,</span><span class="w"> </span><span class="n">Greater</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&#34;in the first quadrant&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="p">(</span><span class="n">Less</span><span class="p">,</span><span class="w"> </span><span class="n">Greater</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&#34;in the second quadrant&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&#34;somewhere else&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>结构体模式要使用花括号，就和结构体表达式一样。它们可以包含每个字段的子模式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">balloon</span><span class="p">.</span><span class="n">location</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="nc">height</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;straight up {} meters&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="nc">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="nc">y</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;at ({}m, {}m)&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>在这个例子中，如果第一个分支匹配了，那么<code>balloon.location.y</code>会被存储到新的局部变量<code>height</code>。</p>
<p>假设<code>balloon.location</code>是<code>Point { x: 30, y: 40 }</code>。和之前一样，Rust会按照”图10-6”的顺序检查每一个模式的每一个部分。</p>
<p><figure>
  <picture>

    
      
        
        
        
        
        
        
    <img
      loading="lazy"
      decoding="async"
      alt="结构体模式匹配"
      
        class="image_figure image_internal image_unprocessed"
        src="../img/f10-6.png"
      
      
    />

    </picture>
</figure>
</p>
<p align="center">图10-6 结构体模式匹配</p>
<p>第二个分支可以匹配，因此输出将是<code>at (30m, 40m)</code>。</p>
<p>当匹配结构体时类似<code>Point { x: x, y: y }</code>的模式非常常见，多余的名字也只会扰乱视觉，因此Rust为此支持一种缩写形式<code>Point {x, y}</code>。含义和之前相同，这个模式也会把点的<code>x</code>字段存储在新的局部变量<code>x</code>、把<code>y</code>字段存储在新的局部变量<code>y</code>。</p>
<p>即使有了缩写形式，如果我们要匹配一个很大的结构体但又只关心少数字段时还是会很麻烦：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">get_account</span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">Account</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">language</span><span class="p">,</span><span class="w"> </span><span class="c1">// 我们关心的两个字段
</span><span class="c1"></span><span class="w">                </span><span class="n">id</span>: <span class="nc">_</span><span class="p">,</span><span class="w"> </span><span class="n">status</span>: <span class="nc">_</span><span class="p">,</span><span class="w"> </span><span class="n">address</span>: <span class="nc">_</span><span class="p">,</span><span class="w"> </span><span class="n">birthday</span>: <span class="nc">_</span><span class="p">,</span><span class="w"> </span><span class="n">eye_color</span>: <span class="nc">_</span><span class="p">,</span><span class="w">
</span><span class="w">                </span><span class="n">pet</span>: <span class="nc">_</span><span class="p">,</span><span class="w"> </span><span class="n">security_question</span>: <span class="nc">_</span><span class="p">,</span><span class="w"> </span><span class="n">hashed_innermost_secret</span>: <span class="nc">_</span><span class="p">,</span><span class="w">
</span><span class="w">                </span><span class="n">is_adamantium_preferred_customer</span>: <span class="nc">_</span><span class="p">,</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="o">=&gt;</span><span class="w">
</span><span class="w">            </span><span class="n">language</span><span class="p">.</span><span class="n">show_custom_greeting</span><span class="p">(</span><span class="n">name</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>为了避免这种情况，可以使用<code>..</code>告诉Rust你不关心其他的字段：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="n">Account</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">language</span><span class="p">,</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="o">=&gt;</span><span class="w">
</span><span class="w">        </span><span class="n">language</span><span class="p">.</span><span class="n">show_custom_greeting</span><span class="p">(</span><span class="n">name</span><span class="p">),</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="数字和切片模式">数字和切片模式</h3>
<p>数组模式匹配数组。它们被通常被用来过滤出某些特殊值，当数组的不同位置的含义不同时它们也会变得很有用。</p>
<p>例如，当把色相、饱和度、亮度(HSL)颜色值转换为红绿蓝(RGB)颜色值时，亮度为0的颜色就是黑、而亮度为满的颜色就是白。我们可以使用<code>match</code>表达式来简单地处理这些情况：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">hsl_to_rgb</span><span class="p">(</span><span class="n">hsl</span>: <span class="p">[</span><span class="kt">u8</span><span class="p">;</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="p">[</span><span class="kt">u8</span><span class="p">;</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">hsl</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="p">[</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">],</span><span class="w">
</span><span class="w">            </span><span class="p">[</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="mi">255</span><span class="p">]</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">255</span><span class="p">,</span><span class="w"> </span><span class="mi">255</span><span class="p">,</span><span class="w"> </span><span class="mi">255</span><span class="p">],</span><span class="w">
</span><span class="w">            </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>切片模式与此类似，但和数组不同的是，切片的长度可以变化。因此切片模式并不只匹配值，还要匹配长度。切片模式中的<code>..</code>匹配任意数量的元素：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">greet_people</span><span class="p">(</span><span class="n">names</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="o">&amp;</span><span class="kt">str</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">names</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="p">[]</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;Hello, nobody.&#34;</span><span class="p">)</span><span class="w"> </span><span class="p">},</span><span class="w">
</span><span class="w">            </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;Hello, {}.&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">},</span><span class="w">
</span><span class="w">            </span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">]</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;Hello, {} and {}.&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">},</span><span class="w">
</span><span class="w">            </span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">..</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">]</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;Hello, everyone from {} to {}.&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="引用模式">引用模式</h3>
<p>Rust模式支持两种和引用有关的特性。<code>ref</code>模式会借用被匹配的值，<code>&amp;</code>模式匹配引用。我们将首先介绍<code>ref</code>模式。</p>
<p>匹配一个非拷贝类型的值会移动这个值。继续上面的例子，下面的代码是无效的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">account</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Account</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">language</span><span class="p">,</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">ui</span><span class="p">.</span><span class="n">greet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">language</span><span class="p">);</span><span class="w">
</span><span class="w">            </span><span class="n">ui</span><span class="p">.</span><span class="n">show_settings</span><span class="p">(</span><span class="o">&amp;</span><span class="n">account</span><span class="p">);</span><span class="w"> </span><span class="c1">// error: borrow of moved value: `account`
</span><span class="c1"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这里，字段<code>account.name</code>和<code>account.language</code>被移动进局部变量<code>name</code>和<code>language</code>中。<code>account</code>的其他部分被丢弃。这就是为什么我们不能再借用它的引用。</p>
<p>如果<code>name</code>和<code>language</code>都是可拷贝的值，Rust将会拷贝字段而不是移动它们，代码将没有问题。但假设它们就是<code>String</code>，那我们该怎么办？</p>
<p>我们需要一种模式 <em>借用</em> 被匹配的值而不是移动它们。<code>ref</code>关键字就是为此而生：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">account</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Account</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="n">language</span><span class="p">,</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">ui</span><span class="p">.</span><span class="n">greet</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">language</span><span class="p">);</span><span class="w">
</span><span class="w">            </span><span class="n">ui</span><span class="p">.</span><span class="n">show_settings</span><span class="p">(</span><span class="o">&amp;</span><span class="n">account</span><span class="p">);</span><span class="w"> </span><span class="c1">// ok
</span><span class="c1"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>现在局部变量<code>name</code>和<code>language</code>都是<code>account</code>中相应字段的引用。因此<code>account</code>只是被借用，并没有被消耗，所以继续用它调用方法也是OK的。</p>
<p>你可以使用<code>ref mut</code>来借用<code>mut</code>引用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">line_result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">log_error</span><span class="p">(</span><span class="n">err</span><span class="p">),</span><span class="w"> </span><span class="c1">// `err`是&amp;Error(shared ref)
</span><span class="c1"></span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">line</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">           </span><span class="c1">// `line`是&amp;mut String(mut ref)
</span><span class="c1"></span><span class="w">            </span><span class="n">trim_comments</span><span class="p">(</span><span class="n">line</span><span class="p">);</span><span class="w">        </span><span class="c1">// 修改String
</span><span class="c1"></span><span class="w">            </span><span class="n">handle</span><span class="p">(</span><span class="n">line</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>模式<code>Ok(ref mut line)</code>匹配任何成功值，并借用存储在里面的成功值的<code>mut</code>引用。</p>
<p>另一种相反的引用模式是<code>&amp;</code>模式。一个以<code>&amp;</code>开始的模式只能匹配引用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">sphere</span><span class="p">.</span><span class="n">center</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="n">Point3d</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>在这个例子中，假设<code>sphere.center()</code>返回一个<code>sphere</code>的私有字段的引用，这在Rust中是很常见的。返回的值是一个<code>Point3d</code>的引用。如果中心在原点的话，<code>sphere.center()</code>会返回<code>&amp;Point3d { x: 0.0, y: 0.0, z: 0.0 }</code>。</p>
<p>模式匹配按照”图10-7”进行。</p>
<p><figure>
  <picture>

    
      
        
        
        
        
        
        
    <img
      loading="lazy"
      decoding="async"
      alt="引用的模式匹配"
      
        class="image_figure image_internal image_unprocessed"
        src="../img/f10-7.png"
      
      
    />

    </picture>
</figure>
</p>
<p align="center">图10-7 引用的模式匹配</p>
<p>这里有一点诡异，因为Rust在这里解除了引用，也就是<code>*</code>运算符的功能。要记住模式和表达式天然是相反的。表达式<code>(x, y)</code>把两个值放入一个新的元组中，而模式<code>(x, y)</code>恰好相反：它匹配一个元组然后取出两个值。<code>&amp;</code>也是一样，在表达式里，<code>&amp;</code>创建一个引用；在模式里，<code>&amp;</code>匹配一个引用。</p>
<p>匹配一个引用遵循我们期望的所有规则：生命周期是强制的、你不能通过共享引用获取<code>mut</code>访问权限、你不能将值移动出引用，即使是<code>mut</code>引用。当我们匹配<code>&amp;Point3d { x, y, z }</code>时，变量<code>x, y, z</code>都是坐标的拷贝，原本的<code>Point3d</code>值还是完整的。只有当这些字段都是拷贝类型才可以正常工作。如果我们想对结构体中一个不可拷贝的字段这么做，我们会遇到错误：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">friend</span><span class="p">.</span><span class="n">borrow_car</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Car</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="c1">// error: can&#39;t move out of borrow
</span><span class="c1"></span><span class="w">            </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">        </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>把一辆借来的车报废是不好的，Rust也不会允许这么做。你可以使用<code>ref</code>模式来借用一个引用，这样就不用拥有它：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Car</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="c1">// ok, engine is a reference
</span></code></pre></td></tr></table>
</div>
</div><p>再来看另一个<code>&amp;</code>模式的例子。假设我们有一个迭代器<code>chars</code>迭代一个字符串里的所有字符，并且它有一个方法<code>chars.peek()</code>返回一个<code>Option&lt;&amp;char&gt;</code>：一个指向下一个字符的引用，如果有的话。（这类迭代器确实返回一个<code>Option&lt;&amp;ItemType&gt;</code>，我们将在”第15章”中见到。）</p>
<p>一个程序可以使用<code>&amp;</code>来获得指向的字符：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">chars</span><span class="p">.</span><span class="n">peek</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;coming up: {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;end of chars&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="匹配守卫">匹配守卫</h3>
<p>有时一个匹配分支还有附加的条件必须要满足。假设我们在实现一个六边形空间内的棋子游戏，玩家只需要点击即可移动棋子。为了确认点击是有效的，我们可能要尝试类似这样的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">check_move</span><span class="p">(</span><span class="n">current_hex</span>: <span class="nc">Hex</span><span class="p">,</span><span class="w"> </span><span class="n">click</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">game</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="n">Hex</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">point_to_hex</span><span class="p">(</span><span class="n">click</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w">
</span><span class="w">                </span><span class="nb">Err</span><span class="p">(</span><span class="s">&#34;That&#39;s not a game space.&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="n">current_hex</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="c1">// 尝试匹配用户是不是点击了当前位置
</span><span class="c1"></span><span class="w">                                 </span><span class="c1">// (这样是错误的：原因如下)
</span><span class="c1"></span><span class="w">                </span><span class="nb">Err</span><span class="p">(</span><span class="s">&#34;You are already there! You must click somewhere else.&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="n">other_hex</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w">
</span><span class="w">                </span><span class="nb">Ok</span><span class="p">(</span><span class="n">other_hex</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这样是错误的，因为模式里的标识符会引入 <em>新的</em> 变量。模式<code>Some(current_hex)</code>会创建一个新的叫<code>current_hex</code>的局部变量，然后遮蔽参数<code>current_hex</code>。Rust会为这段代码报出好几个警告——尤其是，最后一个<code>match</code>分支不可达。一种修复这个问题的方法是简单地在分支中使用一个<code>if</code>表达式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">point_to_hex</span><span class="p">(</span><span class="n">click</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="s">&#34;That&#39;s not a game space.&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">hex</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">hex</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">current_hex</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="nb">Err</span><span class="p">(</span><span class="s">&#34;You are already there! You must click somewhere else&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="nb">Ok</span><span class="p">(</span><span class="n">hex</span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>不过Rust还提供了 <em>匹配守卫(match guard)</em> ：模式和分支的<code>=&gt;</code>词元中间的<code>if CONDITION</code>条件必须满足才能匹配：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">point_to_hex</span><span class="p">(</span><span class="n">click</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="s">&#34;That&#39;s not a game space.&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">hex</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">hex</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">current_hex</span><span class="w"> </span><span class="o">=&gt;</span><span class="w">
</span><span class="w">            </span><span class="nb">Err</span><span class="p">(</span><span class="s">&#34;You are already there! You must click somewhere else&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">hex</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">hex</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>如果模式匹配，但条件不满足，那么将会继续匹配下一个分支。</p>
<h3 id="匹配多种可能">匹配多种可能</h3>
<p>竖线(<code>|</code>)可以用于在一个<code>match</code>分支中组合多个模式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">at_end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">chars</span><span class="p">.</span><span class="n">peek</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="sc">&#39;\r&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="sc">&#39;\n&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>在一个表达式中，<code>|</code>是位或运算符，但这里它的功能就像是普通表达式中的<code>||</code>。如果<code>chars.peek()</code>能匹配三个模式中的任意一个，<code>at_end</code>就会被设为<code>true</code>。</p>
<p>使用<code>..=</code>来匹配范围内的值。范围模式包括起点和终点值，因此<code>'0' ..= '9'</code>匹配所有的ASCII数字：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">next_char</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="sc">&#39;0&#39;</span><span class="o">..=</span><span class="sc">&#39;9&#39;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">read_number</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="sc">&#39;a&#39;</span><span class="o">..=</span><span class="sc">&#39;z&#39;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="sc">&#39;A&#39;</span><span class="o">..=</span><span class="sc">&#39;Z&#39;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">read_word</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="sc">&#39; &#39;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="sc">&#39;\t&#39;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">skip_whitespace</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">handle_punctuation</span><span class="p">(),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>Rust（目前）不允许在模式中使用尾开区间例如<code>0..100</code>。</p>
<h3 id="绑定和模式">绑定和<code>@</code>模式</h3>
<p>最后，<code>x @ pattern</code>用给定的<code>pattern</code>来匹配，但匹配成功时它会创建单个变量<code>x</code>并把整个值移动或拷贝进去，而不是为匹配值的每一部分创建一个变量。例如，假设你有下面的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">get_selection</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Shape</span>::<span class="n">Rect</span><span class="p">(</span><span class="n">top_left</span><span class="p">,</span><span class="w"> </span><span class="n">bottom_right</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">optimized_paint</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Shape</span>::<span class="n">Rect</span><span class="p">(</span><span class="n">top_left</span><span class="p">,</span><span class="w"> </span><span class="n">bottom_right</span><span class="p">))</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="n">other_shape</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">paint_outline</span><span class="p">(</span><span class="n">other_shape</span><span class="p">.</span><span class="n">get_outline</span><span class="p">())</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">    
</span></code></pre></td></tr></table>
</div>
</div><p>注意第一种情况会解包一个<code>Shape::Rect</code>值，然后在下一行中重新构建了一个新的<code>Shape::Rect</code>值。这可以被重写为<code>@</code>模式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="n">rect</span><span class="w"> </span><span class="o">@</span><span class="w"> </span><span class="n">Shape</span>::<span class="n">Rect</span><span class="p">(</span><span class="o">..</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">optimized_paint</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rect</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>@</code>模式和范围一起使用时也很有用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">chars</span><span class="p">.</span><span class="n">next</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">digit</span><span class="w"> </span><span class="o">@</span><span class="w"> </span><span class="sc">&#39;0&#39;</span><span class="o">..=</span><span class="sc">&#39;9&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">read_number</span><span class="p">(</span><span class="n">digit</span><span class="p">,</span><span class="w"> </span><span class="n">chars</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="p">},</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="模式可以用在哪里">模式可以用在哪里</h3>
<p>尽管模式最常用在<code>match</code>表达式中，但它们也能出现在一些其他地方，例如出现在标识符的位置。含义总是相同的：Rust使用模式匹配来分别取出值中的每一部分，而不是存储在单个变量中。</p>
<p>这意味着模式可以用于……</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="c1">// ...把一个结构体解包为3个局部变量
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">Track</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">album</span><span class="p">,</span><span class="w"> </span><span class="n">track_number</span><span class="p">,</span><span class="w"> </span><span class="n">title</span><span class="p">,</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">song</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// ...解包一个元组类型的函数参数
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">distance_to</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>: <span class="p">(</span><span class="kt">f64</span><span class="p">,</span><span class="w"> </span><span class="kt">f64</span><span class="p">))</span><span class="w"> </span>-&gt; <span class="kt">f64</span> <span class="p">{</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// ...迭代一个HashMap的键和值
</span><span class="c1"></span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">document</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cache_map</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;Document #{}: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">document</span><span class="p">.</span><span class="n">title</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// ...自动解引用闭包的参数，
</span><span class="c1"></span><span class="w">    </span><span class="c1">// 当你想要一份拷贝时，其他代码可能会传给你一个引用，
</span><span class="c1"></span><span class="w">    </span><span class="c1">// 这时这种写法很方便。
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">numbers</span><span class="p">.</span><span class="n">fold</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">num</span><span class="o">|</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">num</span><span class="p">)</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这些写法都节省了两到三行重复的样本代码。其它语言中也有相同的概念：JavaScript中它被称为 <em>解构(destructuring)</em> ，而在Python中它被称为 <em>解包(unpacking)</em> 。</p>
<p>注意这四个例子中，我们都使用了一定能匹配的模式。模式<code>Point3d { x, y, z }</code>匹配<code>Point3d</code>类型的任意值，<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup><code>(x, y)</code>匹配任意的<code>(f64, f64)</code>类型的值，等等。在Rust中总是能匹配的模式是很特殊的，它们被称为 <em>不可反驳的模式(irrefutable pattern)</em> ，它们也是唯一能出现在这里展示的四种位置的模式（在<code>let</code>之后、在函数参数中、在<code>for</code>之后、在闭包的参数中）。</p>
<p>一个 <em>可反驳的模式(refutable pattern)</em> 是那些可能不能匹配的模式，例如<code>Ok(x)</code>，它不能匹配一个错误的Result，或者<code>'0' ..= '9'</code>，它不能匹配字符<code>'Q'</code>。可反驳的模式可以用在<code>match</code>分支中，因为<code>match</code>就是为它们设计的：在<code>match</code>中如果匹配失败，那么接下来要怎么做很明显。而上面的四个例子中的位置，Rust不允许匹配失败。</p>
<p>可反驳的模式还可以用在<code>if let</code>和<code>while let</code>表达式中，它们可以用于……</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="c1">// ...只有当是特定类型的枚举variant时才进行处理
</span><span class="c1"></span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="n">RoughTime</span>::<span class="n">InTheFuture</span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">user</span><span class="p">.</span><span class="n">data_of_birth</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">user</span><span class="p">.</span><span class="n">set_time_traveler</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// ...只有当查找成功时才运行代码
</span><span class="c1"></span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">document</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cache_map</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">send_cached_response</span><span class="p">(</span><span class="n">document</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// ...重复尝试执行操作直到它成功
</span><span class="c1"></span><span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">present_cheesy_anti_robot_task</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">log_robot_attempt</span><span class="p">(</span><span class="n">err</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="c1">// 让用户重试
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// ...手动迭代器循环
</span><span class="c1"></span><span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lines</span><span class="p">.</span><span class="n">peek</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">read_paragraph</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">lines</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>有关这些表达式的细节，见“<code>if let</code>”和“循环”。</p>
<h3 id="填充二叉树">填充二叉树</h3>
<p>之前我们说过要展示如何实现一个<code>BinaryTree::add()</code>方法，它把一个节点添加到<code>BinaryTree</code>中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="c1">// 一个类型`T`的顺序集合
</span><span class="c1"></span><span class="w">    </span><span class="k">enum</span> <span class="nc">BinaryTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Empty</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">NonEmpty</span><span class="p">(</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// 二叉树的一个节点
</span><span class="c1"></span><span class="w">    </span><span class="k">struct</span> <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">element</span>: <span class="nc">T</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">left</span>: <span class="nc">BinaryTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">right</span>: <span class="nc">BinaryTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>现在你已经知道了编写这个方法所需的关于模式的知识。对二叉搜索树的解释已经超过了这本书的范围，但对于那些已经对这个话题很熟悉的读者，值得看一下在Rust中如何实现它。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Ord</span><span class="o">&gt;</span><span class="w"> </span><span class="n">BinaryTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">value</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">match</span><span class="w"> </span><span class="o">*</span><span class="bp">self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="n">BinaryTree</span>::<span class="n">Empty</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                    </span><span class="o">*</span><span class="bp">self</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BinaryTree</span>::<span class="n">NonEmpty</span><span class="p">(</span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">TreeNode</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                        </span><span class="n">element</span>: <span class="nc">value</span><span class="p">,</span><span class="w">
</span><span class="w">                        </span><span class="n">left</span>: <span class="nc">BinaryTree</span>::<span class="n">Empty</span><span class="p">,</span><span class="w">
</span><span class="w">                        </span><span class="n">right</span>: <span class="nc">BinaryTree</span>::<span class="n">Empty</span><span class="p">,</span><span class="w">
</span><span class="w">                    </span><span class="p">}))</span><span class="w">
</span><span class="w">                </span><span class="p">}</span><span class="w">
</span><span class="w">                </span><span class="n">BinaryTree</span>::<span class="n">NonEmpty</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">node</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">node</span><span class="p">.</span><span class="n">element</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                        </span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">value</span><span class="p">);</span><span class="w">
</span><span class="w">                    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                        </span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">value</span><span class="p">);</span><span class="w">
</span><span class="w">                    </span><span class="p">}</span><span class="w">
</span><span class="w">                </span><span class="p">}</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">    
</span></code></pre></td></tr></table>
</div>
</div><p>第1行告诉了Rust我们正在为有序类型的<code>BinaryTree</code>定义一个方法。这和我们之前为泛型结构体定义方法的语法完全相同，语法的解释见“使用<code>impl</code>定义方法”一节。</p>
<p>如果现有的树<code>*self</code>是空的，那么就很简单。第5-9行把<code>Empty</code>树变成了一个<code>NonEmpty</code>的树。<code>Box::new()</code>的调用在堆上分配一个新的<code>TreeNode</code>。当运行完之后，树就有了一个元素，这个元素的左子树和右子树都是<code>Empty</code>。</p>
<p>如果<code>*self</code>不是空，第11行的模式就会匹配：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="n">BinaryTree</span>::<span class="n">NonEmpty</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">node</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这个模式会借用一个<code>Box&lt;TreeNode&lt;T&gt;&gt;</code>的可变引用，因此我们可以访问并修改这个树节点中的数据。引用叫做<code>node</code>，它的作用域是12到16行。因为这个节点中已经有一个元素了，所以需要递归调用<code>.add()</code>来给左子树或右子树的节点添加新元素。</p>
<p>新的方法可以像这样使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">tree</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BinaryTree</span>::<span class="n">Empty</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">tree</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="s">&#34;Mercury&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">tree</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="s">&#34;Venus&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="o">..</span><span class="p">.</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h2 id="宏观视图">宏观视图</h2>
<p>Rust的枚举对系统编程来说也许很新，但它们并不是一个新的概念。它有过很多学术性的名称，例如 <em>代数数据类型(algebraic data types)</em> ，它们在函数式编程语言中已经被使用了40多年。不知道为什么遵循C传统的语言中只有很少的语言有这种特性。可能只是因为对于一个编程语言的设计者来说，将variant、引用、可变性和内存安全融合在一起非常有挑战性。函数式语言不需要考虑可变性。C的<code>union</code>相反，有variant、指针和可变性——但它们是如此的不安全以至于即使在C中，它们也是最少用到的特性。Rust的借用检查器是使得在不妥协的情况下把这四者融合在一起变为可能的魔法。</p>
<p>程序就是数据处理的过程。一个小巧、快速、优雅的程序与一个充满缓慢、巨大的类型嵌套和虚拟方法调用的程序之间的区别可能就是是否把数据以正确的方式存储。</p>
<p>这正是枚举专注于解决的问题。它们是一种把数据以正确方式存储的设计工具。对于值可能是这样、也可能是那样、设置可能为空的情况，枚举在每一个维度上都比类层次结构要好：更快、更安全、更少的代码、更容易编写文档。</p>
<p>唯一的限制是灵活性。枚举的最终用户不能添加新的variant来扩展它。Variant只能通过修改枚举的定义来添加，而这么做的话，又会打破现有的代码。每一个单独匹配枚举的每个variant的<code>match</code>表达式都需要修改——需要添加一个新的分支来处理新的variant。在某些情况下，牺牲灵活性换取简洁性是明智之举。毕竟，像JSON这样的结构体预计不会改变。而在某些情况下，当枚举改变时修改所有使用的地方正是我们所期望的。例如，当一个编译器使用<code>enum</code>来表示语言中的不同运算符时，添加一个新的运算符 <em>应该</em> 涉及到所有处理操作符的代码。</p>
<p>但有些时候也需要更多的灵活性。对于这些情况，Rust有trait，也就是我们下一章要讨论的话题。</p>
<div class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn:1" role="doc-endnote">
<p>译者注：此处应是作者写错了，应该是<code>Track</code>对应的例子。&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

    </div>
<div class="post_comments">
  
  
  
</div>




    <hr>

<div id="gitalk-container"></div>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js" crossorigin="anonymous"></script>
    <script type="text/javascript">
      var gitalk = new Gitalk({
        id: '0001-01-01 00:00:00 \u002b0000 UTC',
        title: '',
        clientID: '72786bf87c19beec6abe',
        clientSecret: '93ce647699b49ea6434332d36b0122a4ad8281ad',
        repo: 'buf1024.github.io',
        owner: 'buf1024',
        admin: ['buf1024'],
        body: decodeURI(location.href)
      });
      gitalk.render('gitalk-container');
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/gitalk/gitalk">comments powered by gitalk.</a></noscript>

  </article>
<aside class="sidebar">
  <section class="sidebar_inner">
    <br>
    


    
    
    <h2 class="mt-4">最新文章</h2>
    <ul class="flex-column">
      <li>
        <a href="https://luoguochun.cn/post/2024-01-13-rust-sqlx-sqlbuilder/" class="nav-link" title="Rust sqlx SQLBuilder">Rust sqlx SQLBuilder</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2024-01-08-vite-engineering-config/" class="nav-link" title="前端工程化配置保姆级教程">前端工程化配置保姆级教程</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-12-26-rust-proc-macro/" class="nav-link" title="rust 过程宏">rust 过程宏</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-09-21-rust-panic/" class="nav-link" title="一行代码让 rustc panic">一行代码让 rustc panic</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-07-19-flutter-muti-window/" class="nav-link" title="Flutter 桌面端多窗口支持">Flutter 桌面端多窗口支持</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-07-04-hiqradio/" class="nav-link" title="hiqradio 一个简单的收音机软件">hiqradio 一个简单的收音机软件</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-03-21-android-https/" class="nav-link" title="android https 抓包">android https 抓包</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-03-16-love-for-insterest/" class="nav-link" title="为爱发电终是不能长久的……">为爱发电终是不能长久的……</a>
      </li>
    </ul>
    <div>
      <h2 class="mt-4 taxonomy" id="categories-section">分类</h2>
      <nav class="tags_nav">
        <a href='https://luoguochun.cn/categories/misc/' class="post_tag button button_translucent" title="misc">
          MISC
          <span class="button_tally">11</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/linux/' class="post_tag button button_translucent" title="linux">
          LINUX
          <span class="button_tally">8</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/tcp/' class="post_tag button button_translucent" title="tcp">
          TCP
          <span class="button_tally">8</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/c/' class="post_tag button button_translucent" title="c">
          C
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/flutter/' class="post_tag button button_translucent" title="flutter">
          FLUTTER
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/rust/' class="post_tag button button_translucent" title="rust">
          RUST
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/python/' class="post_tag button button_translucent" title="python">
          PYTHON
          <span class="button_tally">6</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/c&#43;&#43;/' class="post_tag button button_translucent" title="c&#43;&#43;">
          C&#43;&#43;
          <span class="button_tally">4</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/web/' class="post_tag button button_translucent" title="web">
          WEB
          <span class="button_tally">4</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/gcc/' class="post_tag button button_translucent" title="gcc">
          GCC
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/git/' class="post_tag button button_translucent" title="git">
          GIT
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/reactjs/' class="post_tag button button_translucent" title="reactjs">
          REACTJS
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/unittest/' class="post_tag button button_translucent" title="unittest">
          UNITTEST
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/vim/' class="post_tag button button_translucent" title="vim">
          VIM
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/%E6%9E%84%E6%9E%B6/' class="post_tag button button_translucent" title="构架">
          构架
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/asm/' class="post_tag button button_translucent" title="asm">
          ASM
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/docker/' class="post_tag button button_translucent" title="docker">
          DOCKER
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/go/' class="post_tag button button_translucent" title="go">
          GO
          <span class="button_tally">1</span>
        </a>
        
        
      </nav>
    </div>
    <div>
      <h2 class="mt-4 taxonomy" id="tags-section">标签</h2>
      <nav class="tags_nav">
        <a href='https://luoguochun.cn/tags/c/' class="post_tag button button_translucent" title="c">
          C
          <span class="button_tally">21</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/linux/' class="post_tag button button_translucent" title="linux">
          LINUX
          <span class="button_tally">16</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/c&#43;&#43;/' class="post_tag button button_translucent" title="c&#43;&#43;">
          C&#43;&#43;
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/python/' class="post_tag button button_translucent" title="python">
          PYTHON
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/tcp/' class="post_tag button button_translucent" title="tcp">
          TCP
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/dart/' class="post_tag button button_translucent" title="dart">
          DART
          <span class="button_tally">6</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/flutter/' class="post_tag button button_translucent" title="flutter">
          FLUTTER
          <span class="button_tally">6</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/rust/' class="post_tag button button_translucent" title="rust">
          RUST
          <span class="button_tally">4</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/tdd/' class="post_tag button button_translucent" title="tdd">
          TDD
          <span class="button_tally">4</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/android/' class="post_tag button button_translucent" title="android">
          ANDROID
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/git/' class="post_tag button button_translucent" title="git">
          GIT
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/gtest/' class="post_tag button button_translucent" title="gtest">
          GTEST
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/js/' class="post_tag button button_translucent" title="js">
          JS
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/rust-lib/' class="post_tag button button_translucent" title="rust-lib">
          RUST-LIB
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/vcs/' class="post_tag button button_translucent" title="vcs">
          VCS
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/vim/' class="post_tag button button_translucent" title="vim">
          VIM
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/asm/' class="post_tag button button_translucent" title="asm">
          ASM
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/css/' class="post_tag button button_translucent" title="css">
          CSS
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/gas/' class="post_tag button button_translucent" title="gas">
          GAS
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/gcc/' class="post_tag button button_translucent" title="gcc">
          GCC
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/http/' class="post_tag button button_translucent" title="http">
          HTTP
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/libevent/' class="post_tag button button_translucent" title="libevent">
          LIBEVENT
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/macos/' class="post_tag button button_translucent" title="macos">
          MACOS
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/react-native/' class="post_tag button button_translucent" title="react-native">
          REACT-NATIVE
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/redis/' class="post_tag button button_translucent" title="redis">
          REDIS
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/%E6%9E%84%E6%9E%B6/' class="post_tag button button_translucent" title="构架">
          构架
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/api/' class="post_tag button button_translucent" title="api">
          API
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/bt/' class="post_tag button button_translucent" title="bt">
          BT
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/c&#43;/' class="post_tag button button_translucent" title="c&#43;">
          C&#43;
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/coroutine/' class="post_tag button button_translucent" title="coroutine">
          COROUTINE
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/database/' class="post_tag button button_translucent" title="database">
          DATABASE
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/docker/' class="post_tag button button_translucent" title="docker">
          DOCKER
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/endian/' class="post_tag button button_translucent" title="endian">
          ENDIAN
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/frontend/' class="post_tag button button_translucent" title="frontend">
          FRONTEND
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/gdb/' class="post_tag button button_translucent" title="gdb">
          GDB
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/go/' class="post_tag button button_translucent" title="go">
          GO
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/html/' class="post_tag button button_translucent" title="html">
          HTML
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/https/' class="post_tag button button_translucent" title="https">
          HTTPS
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/jquery/' class="post_tag button button_translucent" title="jquery">
          JQUERY
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/ld/' class="post_tag button button_translucent" title="ld">
          LD
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/logger/' class="post_tag button button_translucent" title="logger">
          LOGGER
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/makefile/' class="post_tag button button_translucent" title="makefile">
          MAKEFILE
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/misc/' class="post_tag button button_translucent" title="misc">
          MISC
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/orm/' class="post_tag button button_translucent" title="orm">
          ORM
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/os/' class="post_tag button button_translucent" title="os">
          OS
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/process/' class="post_tag button button_translucent" title="process">
          PROCESS
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/react/' class="post_tag button button_translucent" title="react">
          REACT
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/rpm/' class="post_tag button button_translucent" title="rpm">
          RPM
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/rsa/' class="post_tag button button_translucent" title="rsa">
          RSA
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/server/' class="post_tag button button_translucent" title="server">
          SERVER
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/sqlalchemy/' class="post_tag button button_translucent" title="sqlalchemy">
          SQLALCHEMY
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/ssh/' class="post_tag button button_translucent" title="ssh">
          SSH
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/ssl/tls/' class="post_tag button button_translucent" title="ssl/tls">
          SSL/TLS
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/vc/' class="post_tag button button_translucent" title="vc">
          VC
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/vite/' class="post_tag button button_translucent" title="vite">
          VITE
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/vue/' class="post_tag button button_translucent" title="vue">
          VUE
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/webui/' class="post_tag button button_translucent" title="webui">
          WEBUI
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/wechat/' class="post_tag button button_translucent" title="wechat">
          WECHAT
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/win32/' class="post_tag button button_translucent" title="win32">
          WIN32
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/windows/' class="post_tag button button_translucent" title="windows">
          WINDOWS
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/wireshark/' class="post_tag button button_translucent" title="wireshark">
          WIRESHARK
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/' class="post_tag button button_translucent" title="微服务">
          微服务
          <span class="button_tally">1</span>
        </a>
        
        
      </nav>
    </div>
  </section>
</aside>

  
</div>
  </main><svg width="0" height="0" class="hidden">
  <symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="facebook">
    <path d="M437 0H75C33.648 0 0 33.648 0 75v362c0 41.352 33.648 75 75 75h151V331h-60v-90h60v-61c0-49.629 40.371-90 90-90h91v90h-91v61h91l-15 90h-76v181h121c41.352 0 75-33.648 75-75V75c0-41.352-33.648-75-75-75zm0 0"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18.001 18.001" id="twitter">
    <path d="M15.891 4.013c.808-.496 1.343-1.173 1.605-2.034a8.68 8.68 0 0 1-2.351.861c-.703-.756-1.593-1.14-2.66-1.14-1.043 0-1.924.366-2.643 1.078a3.56 3.56 0 0 0-1.076 2.605c0 .309.039.585.117.819-3.076-.105-5.622-1.381-7.628-3.837-.34.601-.51 1.213-.51 1.846 0 1.301.549 2.332 1.645 3.089-.625-.053-1.176-.211-1.645-.47 0 .929.273 1.705.82 2.388a3.623 3.623 0 0 0 2.115 1.291c-.312.08-.641.118-.979.118-.312 0-.533-.026-.664-.083.23.757.664 1.371 1.291 1.841a3.652 3.652 0 0 0 2.152.743C4.148 14.173 2.625 14.69.902 14.69c-.422 0-.721-.006-.902-.038 1.697 1.102 3.586 1.649 5.676 1.649 2.139 0 4.029-.542 5.674-1.626 1.645-1.078 2.859-2.408 3.639-3.974a10.77 10.77 0 0 0 1.172-4.892v-.468a7.788 7.788 0 0 0 1.84-1.921 8.142 8.142 0 0 1-2.11.593z"
      ></path>
  </symbol>
  <symbol aria-hidden="true" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="mail">
    <path  d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="calendar">
    <path d="M452 40h-24V0h-40v40H124V0H84v40H60C26.916 40 0 66.916 0 100v352c0 33.084 26.916 60 60 60h392c33.084 0 60-26.916 60-60V100c0-33.084-26.916-60-60-60zm20 412c0 11.028-8.972 20-20 20H60c-11.028 0-20-8.972-20-20V188h432v264zm0-304H40v-48c0-11.028 8.972-20 20-20h24v40h40V80h264v40h40V80h24c11.028 0 20 8.972 20 20v48z"></path>
    <path d="M76 230h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zM76 310h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zM76 390h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zm80-80h40v40h-40z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="github">
    <path d="M255.968 5.329C114.624 5.329 0 120.401 0 262.353c0 113.536 73.344 209.856 175.104 243.872 12.8 2.368 17.472-5.568 17.472-12.384 0-6.112-.224-22.272-.352-43.712-71.2 15.52-86.24-34.464-86.24-34.464-11.616-29.696-28.416-37.6-28.416-37.6-23.264-15.936 1.728-15.616 1.728-15.616 25.696 1.824 39.2 26.496 39.2 26.496 22.848 39.264 59.936 27.936 74.528 21.344 2.304-16.608 8.928-27.936 16.256-34.368-56.832-6.496-116.608-28.544-116.608-127.008 0-28.064 9.984-51.008 26.368-68.992-2.656-6.496-11.424-32.64 2.496-68 0 0 21.504-6.912 70.4 26.336 20.416-5.696 42.304-8.544 64.096-8.64 21.728.128 43.648 2.944 64.096 8.672 48.864-33.248 70.336-26.336 70.336-26.336 13.952 35.392 5.184 61.504 2.56 68 16.416 17.984 26.304 40.928 26.304 68.992 0 98.72-59.84 120.448-116.864 126.816 9.184 7.936 17.376 23.616 17.376 47.584 0 34.368-.32 62.08-.32 70.496 0 6.88 4.608 14.88 17.6 12.352C438.72 472.145 512 375.857 512 262.353 512 120.401 397.376 5.329 255.968 5.329z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 212 212" id="gitlab">
    <path d="M12.3 74.7h54L43.3 3c-1-3.6-6.4-3.6-7.6 0L12.3 74.8z" />
    <path d="M12.3 74.7L.5 111c-1 3.2 0 6.8 3 8.8l101.6 74-92.5-119z"/>
    <path d="M105 193.7l-38.6-119h-54l92.7 119z"/>
    <path d="M105 193.7l38.7-119H66.4l38.7 119z"/>
    <path d="M105 193.7l38.7-119H198l-93 119z"/>
    <path d="M198 74.7l11.6 36.2c1 3 0 6.6-3 8.6l-101.5 74 93-119z"/>
    <path d="M198 74.7h-54.3L167 3c1.2-3.6 6.4-3.6 7.6 0L198 74.8z"/>
  </symbol>
  <symbol viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="rss">
    <circle cx="3.429" cy="20.571" r="3.429"></circle>
    <path d="M11.429 24h4.57C15.999 15.179 8.821 8.001 0 8v4.572c6.302.001 11.429 5.126 11.429 11.428z"></path>
    <path d="M24 24C24 10.766 13.234 0 0 0v4.571c10.714 0 19.43 8.714 19.43 19.429z"></path>
  </symbol>
  <symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="linkedin">
    <path d="M437 0H75C33.648 0 0 33.648 0 75v362c0 41.352 33.648 75 75 75h362c41.352 0 75-33.648 75-75V75c0-41.352-33.648-75-75-75zM181 406h-60V196h60zm0-240h-60v-60h60zm210 240h-60V286c0-16.54-13.46-30-30-30s-30 13.46-30 30v120h-60V196h60v11.309C286.719 202.422 296.93 196 316 196c40.691.043 75 36.547 75 79.688zm0 0"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 612 612" id="to-top">
    <path d="M604.501 440.509L325.398 134.956c-5.331-5.357-12.423-7.627-19.386-7.27-6.989-.357-14.056 1.913-19.387 7.27L7.499 440.509c-9.999 10.024-9.999 26.298 0 36.323s26.223 10.024 36.222 0l262.293-287.164L568.28 476.832c9.999 10.024 26.222 10.024 36.221 0 9.999-10.023 9.999-26.298 0-36.323z"></path>
  </symbol>
  <symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="carly">
    <path d="M504.971 239.029L448 182.059V84c0-46.317-37.682-84-84-84h-44c-13.255 0-24 10.745-24 24s10.745 24 24 24h44c19.851 0 36 16.149 36 36v108c0 6.365 2.529 12.47 7.029 16.971L454.059 256l-47.029 47.029A24.002 24.002 0 0 0 400 320v108c0 19.851-16.149 36-36 36h-44c-13.255 0-24 10.745-24 24s10.745 24 24 24h44c46.318 0 84-37.683 84-84v-98.059l56.971-56.971c9.372-9.372 9.372-24.568 0-33.941zM112 192V84c0-19.851 16.149-36 36-36h44c13.255 0 24-10.745 24-24S205.255 0 192 0h-44c-46.318 0-84 37.683-84 84v98.059l-56.971 56.97c-9.373 9.373-9.373 24.568 0 33.941L64 329.941V428c0 46.317 37.682 84 84 84h44c13.255 0 24-10.745 24-24s-10.745-24-24-24h-44c-19.851 0-36-16.149-36-36V320c0-6.365-2.529-12.47-7.029-16.971L57.941 256l47.029-47.029A24.002 24.002 0 0 0 112 192z"></path>
  </symbol>
  <symbol viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="copy">
    <path d="M23 2.75A2.75 2.75 0 0 0 20.25 0H8.75A2.75 2.75 0 0 0 6 2.75v13.5A2.75 2.75 0 0 0 8.75 19h11.5A2.75 2.75 0 0 0 23 16.25zM18.25 14.5h-7.5a.75.75 0 0 1 0-1.5h7.5a.75.75 0 0 1 0 1.5zm0-3h-7.5a.75.75 0 0 1 0-1.5h7.5a.75.75 0 0 1 0 1.5zm0-3h-7.5a.75.75 0 0 1 0-1.5h7.5a.75.75 0 0 1 0 1.5z"></path>
    <path d="M8.75 20.5a4.255 4.255 0 0 1-4.25-4.25V2.75c0-.086.02-.166.025-.25H3.75A2.752 2.752 0 0 0 1 5.25v16A2.752 2.752 0 0 0 3.75 24h12a2.752 2.752 0 0 0 2.75-2.75v-.75z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512.001 512.001" id="closeme">
    <path d="M284.286 256.002L506.143 34.144c7.811-7.811 7.811-20.475 0-28.285-7.811-7.81-20.475-7.811-28.285 0L256 227.717 34.143 5.859c-7.811-7.811-20.475-7.811-28.285 0-7.81 7.811-7.811 20.475 0 28.285l221.857 221.857L5.858 477.859c-7.811 7.811-7.811 20.475 0 28.285a19.938 19.938 0 0 0 14.143 5.857 19.94 19.94 0 0 0 14.143-5.857L256 284.287l221.857 221.857c3.905 3.905 9.024 5.857 14.143 5.857s10.237-1.952 14.143-5.857c7.811-7.811 7.811-20.475 0-28.285L284.286 256.002z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="open-menu">
    <path d="M492 236H20c-11.046 0-20 8.954-20 20s8.954 20 20 20h472c11.046 0 20-8.954 20-20s-8.954-20-20-20zm0-160H20C8.954 76 0 84.954 0 96s8.954 20 20 20h472c11.046 0 20-8.954 20-20s-8.954-20-20-20zm0 320H20c-11.046 0-20 8.954-20 20s8.954 20 20 20h472c11.046 0 20-8.954 20-20s-8.954-20-20-20z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="instagram">
    <path d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948 0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072 3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.163 6.162 6.163 6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zm0 10.162c-2.209 0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796 0-1.441.645-1.441 1.44s.645 1.44 1.441 1.44c.795 0 1.439-.645 1.439-1.44s-.644-1.44-1.439-1.44z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id=youtube>
    <path d="M19.615 3.184c-3.604-.246-11.631-.245-15.23 0-3.897.266-4.356 2.62-4.385 8.816.029 6.185.484 8.549 4.385 8.816 3.6.245 11.626.246 15.23 0 3.897-.266 4.356-2.62 4.385-8.816-.029-6.185-.484-8.549-4.385-8.816zm-10.615 12.816v-8l8 3.993-8 4.007z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="stackoverflow">
    <path d="M21 27v-8h3v11H0V19h3v8h18z"></path><path d="M17.1.2L15 1.8l7.9 10.6 2.1-1.6L17.1.2zm3.7 14.7L10.6 6.4l1.7-2 10.2 8.5-1.7 2zM7.2 12.3l12 5.6 1.1-2.4-12-5.6-1.1 2.4zm-1.8 6.8l13.56 1.96.17-2.38-13.26-2.55-.47 2.97zM19 25H5v-3h14v3z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="xing">
    <path d="M18.188 0c-.517 0-.741.325-.927.66 0 0-7.455 13.224-7.702 13.657.015.024 4.919 9.023 4.919 9.023.17.308.436.66.967.66h3.454c.211 0 .375-.078.463-.22.089-.151.089-.346-.009-.536l-4.879-8.916c-.004-.006-.004-.016 0-.022L22.139.756c.095-.191.097-.387.006-.535C22.056.078 21.894 0 21.686 0h-3.498zM3.648 4.74c-.211 0-.385.074-.473.216-.09.149-.078.339.02.531l2.34 4.05c.004.01.004.016 0 .021L1.86 16.051c-.099.188-.093.381 0 .529.085.142.239.234.45.234h3.461c.518 0 .766-.348.945-.667l3.734-6.609-2.378-4.155c-.172-.315-.434-.659-.962-.659H3.648v.016z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 71 55" id="discord">
    <path d="M60.1045 4.8978C55.5792 2.8214 50.7265 1.2916 45.6527 0.41542C45.5603 0.39851 45.468 0.440769 45.4204 0.525289C44.7963 1.6353 44.105 3.0834 43.6209 4.2216C38.1637 3.4046 32.7345 3.4046 27.3892 4.2216C26.905 3.0581 26.1886 1.6353 25.5617 0.525289C25.5141 0.443589 25.4218 0.40133 25.3294 0.41542C20.2584 1.2888 15.4057 2.8186 10.8776 4.8978C10.8384 4.9147 10.8048 4.9429 10.7825 4.9795C1.57795 18.7309 -0.943561 32.1443 0.293408 45.3914C0.299005 45.4562 0.335386 45.5182 0.385761 45.5576C6.45866 50.0174 12.3413 52.7249 18.1147 54.5195C18.2071 54.5477 18.305 54.5139 18.3638 54.4378C19.7295 52.5728 20.9469 50.6063 21.9907 48.5383C22.0523 48.4172 21.9935 48.2735 21.8676 48.2256C19.9366 47.4931 18.0979 46.6 16.3292 45.5858C16.1893 45.5041 16.1781 45.304 16.3068 45.2082C16.679 44.9293 17.0513 44.6391 17.4067 44.3461C17.471 44.2926 17.5606 44.2813 17.6362 44.3151C29.2558 49.6202 41.8354 49.6202 53.3179 44.3151C53.3935 44.2785 53.4831 44.2898 53.5502 44.3433C53.9057 44.6363 54.2779 44.9293 54.6529 45.2082C54.7816 45.304 54.7732 45.5041 54.6333 45.5858C52.8646 46.6197 51.0259 47.4931 49.0921 48.2228C48.9662 48.2707 48.9102 48.4172 48.9718 48.5383C50.038 50.6034 51.2554 52.5699 52.5959 54.435C52.6519 54.5139 52.7526 54.5477 52.845 54.5195C58.6464 52.7249 64.529 50.0174 70.6019 45.5576C70.6551 45.5182 70.6887 45.459 70.6943 45.3942C72.1747 30.0791 68.2147 16.7757 60.1968 4.9823C60.1772 4.9429 60.1437 4.9147 60.1045 4.8978ZM23.7259 37.3253C20.2276 37.3253 17.3451 34.1136 17.3451 30.1693C17.3451 26.225 20.1717 23.0133 23.7259 23.0133C27.308 23.0133 30.1626 26.2532 30.1066 30.1693C30.1066 34.1136 27.28 37.3253 23.7259 37.3253ZM47.3178 37.3253C43.8196 37.3253 40.9371 34.1136 40.9371 30.1693C40.9371 26.225 43.7636 23.0133 47.3178 23.0133C50.9 23.0133 53.7545 26.2532 53.6986 30.1693C53.6986 34.1136 50.9 37.3253 47.3178 37.3253Z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 17 18" id="mastodon">
    <path
    fill="#ffffff"
    d="m 15.054695,9.8859583 c -0.22611,1.1632697 -2.02517,2.4363497 -4.09138,2.6830797 -1.0774504,0.12856 -2.1382704,0.24673 -3.2694704,0.19484 -1.84996,-0.0848 -3.30971,-0.44157 -3.30971,-0.44157 0,0.1801 0.0111,0.35157 0.0333,0.51194 0.24051,1.82571 1.81034,1.93508 3.29737,1.98607 1.50088,0.0514 2.8373104,-0.37004 2.8373104,-0.37004 l 0.0617,1.35686 c 0,0 -1.0498104,0.56374 -2.9199404,0.66742 -1.03124,0.0567 -2.3117,-0.0259 -3.80308,-0.42069 -3.23454998,-0.85613 -3.79081998,-4.304 -3.87592998,-7.8024197 -0.026,-1.03871 -0.01,-2.01815 -0.01,-2.83732 0,-3.57732 2.34385998,-4.62587996 2.34385998,-4.62587996 1.18184,-0.54277 3.20976,-0.77101 5.318,-0.7882499985409 h 0.0518 C 9.8267646,0.01719834 11.856025,0.24547834 13.037775,0.78824834 c 0,0 2.34377,1.04855996 2.34377,4.62587996 0,0 0.0294,2.63937 -0.32687,4.47183"/>
 <path
    fill="#000000"
    d="m 12.616925,5.6916583 v 4.3315297 h -1.71607 V 5.8189683 c 0,-0.88624 -0.37289,-1.33607 -1.1187604,-1.33607 -0.82467,0 -1.23799,0.53361 -1.23799,1.58875 v 2.30122 h -1.70594 v -2.30122 c 0,-1.05514 -0.4134,-1.58875 -1.23808,-1.58875 -0.74587,0 -1.11876,0.44983 -1.11876,1.33607 v 4.2042197 h -1.71607 V 5.6916583 c 0,-0.88527 0.22541,-1.58876 0.67817,-2.10922 0.46689,-0.52047 1.07833,-0.78727 1.83735,-0.78727 0.87816,0 1.54317,0.33752 1.98288,1.01267 l 0.42744,0.71655 0.42753,-0.71655 c 0.43961,-0.67515 1.10463,-1.01267 1.9828704,-1.01267 0.75893,0 1.37037,0.2668 1.83735,0.78727 0.45268,0.52046 0.67808,1.22395 0.67808,2.10922"/>
  </symbol>
</svg>

<footer class="footer">
  <div class="footer_inner wrap pale">
    <img src='https://luoguochun.cn/icons/apple-touch-icon.png' class="icon icon_2 transparent" alt="BUF1024">
    <p>Copyright&nbsp;2011-&nbsp;<span class="year"></span>&nbsp;BUF1024. All Rights Reserved</p><a class="to_top" href="#documentTop">
  <svg class="icon">
  <title>to-top</title>
  <use xlink:href="#to-top"></use>
</svg>

</a>

  </div>
</footer>

<script type="text/javascript" src="https://luoguochun.cn/zh-cn/js/bundle.884eccc71c2848fb4aeb15945329b5a857717f0313da00cb46b765b5734cfa64b08ce2609627167129c2de17d9b47ed210682f96a2502ebb3aadc73191740211.js" integrity="sha512-iE7MxxwoSPtK6xWUUym1qFdxfwMT2gDLRrdltXNM&#43;mSwjOJglicWcSnC3hfZtH7SEGgvlqJQLrs6rccxkXQCEQ==" crossorigin="anonymous"></script>
</body>

</html>
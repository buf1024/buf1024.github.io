
<!DOCTYPE html>
<html lang="zh-cn" data-figures=""  class="page"   >

<head>
<title>BUF1024</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">





<meta property="og:locale" content="zh-cn" />

<meta property="og:type" content="article">
<meta name="description" content="迭代器 It was the end of a very long day. ——Phil 一个 迭代器(iterator) 可以产生一个值的序列，通常会使用一个循环来进行处理。Rust的标准库提供了" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:creator" content="">
<meta name="twitter:title" content="" />
<meta name="twitter:image" content="https://luoguochun.cn"/>
<meta property="og:url" content="https://luoguochun.cn/prust/ch15/" />
<meta property="og:title" content="" />
<meta property="og:description" content="迭代器 It was the end of a very long day. ——Phil 一个 迭代器(iterator) 可以产生一个值的序列，通常会使用一个循环来进行处理。Rust的标准库提供了" />
<meta property="og:image" content="https://luoguochun.cn" />
  <meta name="keywords" content="blog,computer,luoguochun" />

<link rel="apple-touch-icon" sizes="180x180" href="https://luoguochun.cn/icons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://luoguochun.cn/icons/favicon-32x32.png">
<link rel="manifest" href="https://luoguochun.cn/icons/site.webmanifest">

<link rel="canonical" href="https://luoguochun.cn/prust/ch15/">



<link rel="preload" href="https://luoguochun.cn/css/styles.42e2c5f6d8cf9c52872666f8d8b2678ad0c426978b9d78aff3c33b7a1e7f6f97f54bcdaf0518a25fb0fe26367d04f8b07c683b3b38b331cb098daadee06b1f3e.css" integrity = "sha512-QuLF9tjPnFKHJmb42LJnitDEJpeLnXiv88M7eh5/b5f1S82vBRiiX7D&#43;JjZ9BPiwfGg7OzizMcsJjare4GsfPg==" as="style" crossorigin="anonymous">



<link rel="preload" href="https://luoguochun.cn/zh-cn/js/bundle.884eccc71c2848fb4aeb15945329b5a857717f0313da00cb46b765b5734cfa64b08ce2609627167129c2de17d9b47ed210682f96a2502ebb3aadc73191740211.js" as="script" integrity=
"sha512-iE7MxxwoSPtK6xWUUym1qFdxfwMT2gDLRrdltXNM&#43;mSwjOJglicWcSnC3hfZtH7SEGgvlqJQLrs6rccxkXQCEQ==" crossorigin="anonymous">


<link rel="stylesheet" type="text/css" href="https://luoguochun.cn/css/styles.42e2c5f6d8cf9c52872666f8d8b2678ad0c426978b9d78aff3c33b7a1e7f6f97f54bcdaf0518a25fb0fe26367d04f8b07c683b3b38b331cb098daadee06b1f3e.css" integrity="sha512-QuLF9tjPnFKHJmb42LJnitDEJpeLnXiv88M7eh5/b5f1S82vBRiiX7D&#43;JjZ9BPiwfGg7OzizMcsJjare4GsfPg==" crossorigin="anonymous">

</head>

<body data-code="100" data-lines="false" id="documentTop"
  data-lang="zh-cn">

<header class="nav_header" >
  <nav class="nav"><a href='https://luoguochun.cn' class="nav_brand nav_item" title="BUF1024">BUF1024
  <div class="nav_close">
    <div><svg class="icon">
  <title>open-menu</title>
  <use xlink:href="#open-menu"></use>
</svg>
<svg class="icon">
  <title>closeme</title>
  <use xlink:href="#closeme"></use>
</svg>
</div>
  </div>
</a>

    <div class='nav_body nav_body_left'>
      
      
      
        

  <div class="nav_parent">
    <a href="https://luoguochun.cn/" class="nav_item" title="主页">主页 </a>
  </div>
  <div class="nav_parent">
    <a href="https://luoguochun.cn" class="nav_item" title="链接">链接 <img src='https://luoguochun.cn/icons/caret-icon.svg' alt="icon" class="nav_icon"></a>
    <div class="nav_sub">
      <span class="nav_child"></span>
        <a href="https://luoguochun.cn/talib-doc/" class="nav_child nav_item" title="TA 技术分析库">TA 技术分析库</a>
        <a href="https://luoguochun.cn/hiqradio" class="nav_child nav_item" title="hiqadio网络收音机">hiqadio网络收音机</a>
    </div>
  </div>
  <div class="nav_parent">
    <a href="https://luoguochun.cn/about/" class="nav_item" title="关于">关于 </a>
  </div>
      
<div class='follow'>
<div class="color_mode">
  <input type="checkbox" class="color_choice" id="mode">
</div>

</div>

    </div>
  </nav>
</header>

  <main>
  
<div class="grid-inverse wrap content">
  <article class="post_content">
    <h1 class="post_title"></h1>
  <div class="post_meta">
    <span><svg class="icon">
  <title>calendar</title>
  <use xlink:href="#calendar"></use>
</svg>
</span>
    <span class="post_date">
      Jan 1, 0001</span>
    <span class="post_time"> · 53 min read</span>
    <span class="page_only">&nbsp;·
  <div class="post_share">
    分享到:
    <a href="https://twitter.com/intent/tweet?text=&url=https%3a%2f%2fluoguochun.cn%2fprust%2fch15%2f&tw_p=tweetbutton" class="twitter" title="分享到 Twitter" target="_blank" rel="nofollow">
      <svg class="icon">
  <title>twitter</title>
  <use xlink:href="#twitter"></use>
</svg>

    </a>
    <a href="https://www.facebook.com/sharer.php?u=https%3a%2f%2fluoguochun.cn%2fprust%2fch15%2f&t=" class="facebook" title="分享到 Facebook" target="_blank" rel="nofollow">
      <svg class="icon">
  <title>facebook</title>
  <use xlink:href="#facebook"></use>
</svg>

    </a>
    <a href="#linkedinshare" id = "linkedinshare" class="linkedin" title="分享到 LinkedIn" rel="nofollow">
      <svg class="icon">
  <title>linkedin</title>
  <use xlink:href="#linkedin"></use>
</svg>

    </a>
    <a href="https://luoguochun.cn/prust/ch15/" title="Copy Link" class="link link_yank">
      <svg class="icon">
  <title>copy</title>
  <use xlink:href="#copy"></use>
</svg>

    </a>
  </div>
  </span>
  </div>

    <div class="post_body"><h1 id="迭代器">迭代器</h1>
<p><em>It was the end of a very long day.</em></p>
<p align="right">
    ——Phil
</p>
<p>一个 <em>迭代器(iterator)</em> 可以产生一个值的序列，通常会使用一个循环来进行处理。Rust的标准库提供了遍历vector、字符串、哈希表和其他集合的迭代器，以及从一个输入流中产生若干行文本的迭代器、到达网络服务器的连接的迭代器、通过通道从其他线程接收到的值的迭代器，等等。当然，你可以实现自己的迭代器。Rust的<code>for</code>循环提供了一种自然地使用迭代器的语法，但迭代器自身也提供了丰富的方法集合用于映射、过滤、连接、收集等用途。</p>
<p>Rust的迭代器灵活、表达力强、高效。考虑下面的函数，它返回前<code>n</code>个正数的和（通常也被称为 <em>第n个三角数(nth triangle number)</em> ：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">triangle</span><span class="p">(</span><span class="n">n</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..=</span><span class="n">n</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="n">sum</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>表达式<code>1..=n</code>是一个<code>RangeInclusive&lt;i32&gt;</code>值。一个<code>RangeInclusive&lt;i32&gt;</code>是一个产生从起点到终点的所有整数的迭代器（包含起点和终点），因此你可以将它用作<code>for</code>循环的操作数来求<code>1</code>到<code>n</code>的和。</p>
<p>但迭代器也有一个<code>fold</code>方法，你可以使用它实现如下的等价定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">triangle</span><span class="p">(</span><span class="n">n</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="mi">1</span><span class="o">..=</span><span class="n">n</span><span class="p">).</span><span class="n">fold</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">sum</span><span class="p">,</span><span class="w"> </span><span class="n">item</span><span class="o">|</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">item</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>以<code>0</code>作为起始的总和，<code>fold</code>会获取<code>1..=n</code>产生的每个值，然后用总和和产生的值调用闭包<code>|sum, item| sum + item</code>，每一次闭包的返回值就是新的总和。它最后返回的值就是<code>fold</code>自身返回的值——在这个例子中，就是整个序列的总和。如果你习惯使用<code>for</code>和<code>while</code>循环，那么这看起来会有些奇怪，但一旦你习惯了它，<code>fold</code>就是一个可读性强而简洁的替代方案。</p>
<p>这种写法是函数式编程语言的标准写法，这使得表达式有更强的表现力。但Rsut的迭代器是精心设计的，为了保证编译器可以把它们翻译成优秀的机器代码。在release构建模式下构建上面第二个定义时，Rust知道<code>fold</code>的定义，并且把它内联进<code>triangle</code>。然后，闭包<code>|sum, item| sum + item</code>也会被内联。最后，Rust会检查组合之后的代码，然后发现有一种更简单的方法计算从1到<code>n</code>的和：和总是等于<code>n * (n+1) / 2</code>。Rust会把<code>triangle</code>的整个函数体，包括循环、闭包等所有内容，变成一次乘法指令和一些其他的位运算。</p>
<p>这个例子恰巧可以转换成简单的算术，但在更复杂的使用中迭代器也可以表现的很好。它们是Rust提供灵活抽象的同时只有很小甚至没有开销的另一个例子。</p>
<p>在本章中，我们将会解释：</p>
<ul>
<li><code>Iterator</code>和<code>IntoIterator</code> trait，它们是Rust迭代器的基础</li>
<li>经典迭代器流水线的三个阶段：从初始的值创建一个迭代器；通过选择或处理值将一种迭代器变成另一种；消耗迭代器产生的值</li>
<li>如何为自己的类型实现迭代器</li>
</ul>
<p>迭代器有很多方法，所以一旦你了解了大概的思路，就可以跳过那一节。但迭代器在Rust的习惯用法中非常普遍，熟悉这些随附的工具对掌握这门语言至关重要。</p>
<h2 id="iterator与intoiterator-trait"><code>Iterator</code>与<code>IntoIterator trait</code></h2>
<p>一个迭代器是任何实现了<code>std::iter::Iterator</code> trait的类型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">trait</span><span class="w"> </span><span class="nb">Iterator</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">type</span> <span class="nc">Item</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w"> </span><span class="c1">// 很多默认方法
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>Item</code>是迭代器产生的值的类型。<code>next</code>方法可能返回<code>Some(v)</code>，其中<code>v</code>是迭代器的下一个值；或者返回<code>None</code>，表示已经到达序列的终点。这里我们省略了<code>Iterator</code>的很多默认方法；我们将在本章的剩余部分分别介绍它们。</p>
<p>如果某个类型有一种很自然的迭代方法，那么它可以实现<code>std::iter::IntoIterator</code>，它的<code>into_iter</code>方法获取一个值并返回一个迭代它的迭代器：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">trait</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">IntoIter</span>: <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">=</span><span class="bp">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">type</span> <span class="nc">Item</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="k">type</span> <span class="nc">IntoIter</span>: <span class="nb">Iterator</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">into_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">IntoIter</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>IntoIter</code>是迭代器本身的类型，<code>Item</code>是它产生的值的类型。我们称所有实现了<code>IntoIterator</code>的类型为 <em>可迭代对象(iterable)</em> ，因为你可以迭代它。</p>
<p>Rust的<code>for</code>循环将这些部分漂亮地组合在一起。为了迭代一个迭代器的元素，你可以写：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;There&#39;s:&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="s">&#34;antimony&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;arsenic&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;alumium&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;selenium&#34;</span><span class="p">];</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">element</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">element</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>在底层，每一个<code>for</code>循环只是<code>IntoIterator</code>和<code>Iterator</code>的方法调用的缩写：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">iterator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="p">).</span><span class="n">into_iter</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">element</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iterator</span><span class="p">.</span><span class="n">next</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">element</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>for</code>循环使用了<code>IntoIterator::into_iter</code>来把操作数<code>&amp;v</code>转换成一个迭代器，然后重复调用<code>Iterator::next</code>。每一次返回<code>Some(element)</code>时，<code>for</code>循环会执行循环体；如果它返回<code>None</code>，循环会终止。</p>
<p>考虑这个例子，其中有一些迭代器的术语：</p>
<ul>
<li>正如我们所说， <em>迭代器(iterator)</em> 是任何实现了<code>Iterator</code>的类型。</li>
<li><em>可迭代对象(iterable)</em> 是任何实现了<code>IntoIterator</code>的类型：你可以调用它的<code>into_iter</code>方法获得一个迭代它的迭代器。这个例子中vector的引用<code>&amp;v</code>就是可迭代对象。</li>
<li>一个迭代器 <em>产生(produce)</em> 值。</li>
<li>迭代器产生的值是 <em>item</em> 。这里item是<code>&quot;antimony&quot;, &quot;arsenic&quot;</code>，等等。</li>
<li>接受迭代器产生的item的代码是 <em>消费者(consumer)</em> 。这个例子中，<code>for</code>循环就是消费者。</li>
</ul>
<p>尽管<code>for</code>循环总是调用操作数的<code>into_iter</code>，你也可以直接向<code>for</code>循环传递迭代器；例如，当你在<code>Range</code>上循环时就是这种情况。所有的迭代器都会自动实现<code>IntoIterator</code>，它们的<code>into_iter</code>方法简单地返回迭代器自身。</p>
<p>如果在迭代器返回了<code>None</code>之后，你再调用它的<code>next</code>方法，那么<code>Iterator</code> trait并没有指定这种情况下该怎么做。大多数会再次返回<code>None</code>，但不是所有。（如果这导致了问题，“fuse”中介绍的<code>fuse</code>适配器可能会有帮助。）</p>
<h2 id="创建迭代器">创建迭代器</h2>
<p>Rust标准库文档中详细解释了每种类型提供哪些种类的迭代器，但标准库提供了一些通用的约定来帮助你找到需要的迭代器。</p>
<h3 id="iter和iter_mut方法"><code>iter</code>和<code>iter_mut</code>方法</h3>
<p>大多数集合类型提供<code>iter</code>和<code>iter_mut</code>方法，它们返回一个迭代器，迭代器会产生每一个item的共享引用或可变引用。数组切片例如<code>&amp;[T]</code>和<code>&amp;mut [T]</code>也有<code>iter</code>和<code>iter_mut</code>方法。除了使用<code>for</code>循环自动处理之外，这些方法是最常用的获得迭代器的方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">iterator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">iter</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">iterator</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">4</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">iterator</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">20</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">iterator</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">12</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">iterator</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">8</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">iterator</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">6</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">iterator</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这个迭代器的item类型是<code>&amp;i32</code>：每一次调用<code>next</code>都会产生下一个元素的引用，直到到达vector的终点。</p>
<p>每一个类型都可以实现<code>iter</code>和<code>iter_mut</code>，不管它们的实现是否有意义。<code>std::path::Path</code>的<code>iter</code>返回的迭代器一次产生路径的一段：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ffi</span>::<span class="n">OsStr</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">path</span>::<span class="n">Path</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Path</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;C:/Users/JimB/Downloads/Fedora.iso&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">iterator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">path</span><span class="p">.</span><span class="n">iter</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">iterator</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">OsStr</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;C:&#34;</span><span class="p">)));</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">iterator</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">OsStr</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;Users&#34;</span><span class="p">)));</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">iterator</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">OsStr</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;JimB&#34;</span><span class="p">)));</span><span class="w">
</span><span class="w">    </span><span class="o">..</span><span class="p">.</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这个迭代器的item类型是<code>&amp;std::ffi::OsStr</code>，它是操作系统调用接受的一种字符串类型的引用切片。</p>
<p>如果某个类型有不止一种迭代方式，那么这个类型通常为每种遍历方式提供特定的方法，因为这时普通的<code>iter</code>方法将会导致歧义。例如，<code>&amp;str</code>字符串切片类型没有<code>iter</code>方法。作为替代，假设<code>s</code>是<code>&amp;str</code>，那么<code>s.bytes()</code>返回一个产生<code>s</code>的每个字节的迭代器，而<code>s.chars()</code>会以UTF-8编码解析它的内容，然后产生每一个Unicode字符。</p>
<h3 id="intoiterator实现"><code>IntoIterator</code>实现</h3>
<p>当一个类型实现了<code>IntoIterator</code>之后，你可以自己调用它的<code>into_iter</code>方法，正如<code>for</code>循环做的一样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="c1">// 你通常应该使用HashSet，但它的迭代顺序是不确定的，
</span><span class="c1"></span><span class="w">    </span><span class="c1">// 因此这个例子中BTreeSet会工作得更好。
</span><span class="c1"></span><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">collections</span>::<span class="n">BTreeSet</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">favorites</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BTreeSet</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">favorites</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&#34;Lucy in the Sky With Diamonds&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="n">favorites</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&#34;Liebesträume No. 3&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">());</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">favorites</span><span class="p">.</span><span class="n">into_iter</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="s">&#34;Liebesträume No. 3&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">()));</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="s">&#34;Lucy in the Sky With Diamonds&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">()));</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>大多数集合实际上都提供了好几个<code>IntoIterator</code>的实现，分别是为共享引用(<code>&amp;T</code>)、可变引用(<code>&amp;mut T</code>)、移动(<code>T</code>)提供的实现：</p>
<ul>
<li>给定一个集合的 <em>共享引用(shared reference)</em> ，<code>into_iter</code>返回一个产生item的共享引用的迭代器。例如，在上面的代码中，<code>(&amp;favorites).into_iter()</code>将会返回一个<code>Item</code>类型是<code>&amp;String</code>的迭代器。</li>
<li>给定一个集合的 <em>可变引用(mutable reference)</em> ，<code>into_iter</code>返回一个产生item的可变引用的迭代器。例如，如果<code>vector</code>是<code>Vec&lt;String&gt;</code>，那么<code>(&amp;mut vector).into_iter()</code>将返回一个<code>Item</code>类型是<code>&amp;mut String</code>的迭代器。</li>
<li>当集合 <em>以值</em> 传递时，<code>into_iter</code>返回一个获取集合所有权并返回item自身的迭代器；item的所有权从集合移动到消费者，原来的集合在这个过程中被消耗。例如，上面代码中的<code>favorites.into_iter()</code>会返回一个产生每个字符串值的迭代器；消费者会接受每个字符串的所有权。当迭代器被drop时，<code>BTreeSet</code>中剩余的所有元素也都会被drop，并且集合会变为未初始化。</li>
</ul>
<p>因为<code>for</code>循环会对操作数调用<code>IntoIterator::into_iter</code>，这三种实现会导致有下面三种迭代方式：迭代集合的共享引用、迭代集合的可变引用、或者消耗集合并获取它的元素的所有权：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">element</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="n">collection</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">element</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">collection</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">element</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">collection</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这三种写法会调用上面列出的<code>IntoIterator</code>实现之一。</p>
<p>并不是每个类型都提供了全部这三种实现。例如，<code>HashSet</code>、<code>BTreeSet</code>、<code>BinaryHeap</code>没有实现可变引用的<code>IntoIterator</code>，因为修改它们的元素可能会破坏类型的不变量：修改后的值可能会有不同的哈希值、或者和它的邻居的顺序关系会改变，因此修改元素会导致它们被放在错误的地方。其他的类型支持可变性，但只支持部分。例如，<code>HashMap</code>和<code>BTreeMap</code>产生表项的value的可变引用，以及key的共享引用，原因和上面类似。</p>
<p>一般的准则是迭代应该高效和可预测，因此Rust不提供开销很大或者可能展现出令人惊讶的行为的实现（例如，重新哈希被修改的<code>HashSet</code>条目并因此导致之后的迭代中可能再次遇到它们）。</p>
<p>切片实现了三种<code>IntoIterator</code>变体中的两个；因为它们并不拥有自己引用的元素，因此没有“以值”的实现。作为代替，<code>&amp;[T]</code>和<code>&amp;mut [T]</code>的<code>into_iter</code>返回一个产生共享引用和可变引用的迭代器。如果你把底层切片类型<code>[T]</code>想象成一种集合，那么它就落入了之前的模式。</p>
<p>你可能已经注意到前两种<code>IntoIterator</code>的变体产生共享和可变的引用，这和调用<code>iter</code>或者<code>iter_mut</code>是等价的。为什么Rust同时提供两者？</p>
<p><code>IntoIterator</code>使<code>for</code>循环能正常工作，因此它显然是必要的。但当你不使用<code>for</code>循环时，使用<code>favorites.iter()</code>比<code>(&amp;favorites).into_iter()</code>更加清晰。你可能会频繁需要以共享引用迭代，因此<code>iter</code>和<code>iter_mut</code>也很有用。</p>
<p><code>IntoIterator</code>在泛型代码中也很有用：你可以使用一个约束例如<code>T: IntoIterator</code>来限制类型参数<code>T</code>必须是可以迭代的类型。或者，你可以写<code>T: IntoIterator&lt;Item=U&gt;</code>来进一步要求迭代会产生<code>U</code>类型的值。例如，这个函数打印出任何item可以用<code>&quot;{:?}&quot;</code>格式打印的可迭代对象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span>::<span class="n">Debug</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">dump</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="k">where</span><span class="w"> </span><span class="n">T</span>: <span class="nb">IntoIterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">=</span><span class="n">U</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">              </span><span class="n">U</span>: <span class="nc">Debug</span><span class="w">
</span><span class="w">    </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">u</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>你不能在这个泛型函数中使用<code>iter</code>或者<code>iter_mut</code>，因为它们不是任何trait的方法，大多数可迭代类型只是恰好有这两个方法。</p>
<h3 id="from_fn和successors"><code>from_fn</code>和<code>successors</code></h3>
<p>一个简单而通用的产生一个值序列的方式是提供一个返回它们的闭包。</p>
<p>给定一个返回<code>Option&lt;T&gt;</code>的函数，<code>std::iter::from_fn</code>返回一个迭代器，它简单地调用那个函数来产生item。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">rand</span>::<span class="n">random</span><span class="p">;</span><span class="w">   </span><span class="c1">// 在Cargo.toml中添加依赖：rand = &#34;0.7&#34;
</span><span class="c1"></span><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">iter</span>::<span class="n">from_fn</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="c1">// 产生1000个随机数，在[0, 1]之间均匀分布。
</span><span class="c1"></span><span class="w">    </span><span class="c1">// （这并不是你想在`rand_distr` crate中找到的分布，
</span><span class="c1"></span><span class="w">    </span><span class="c1">// 但你可以很容易地自己实现它）
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">lengths</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">f64</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w">
</span><span class="w">        </span><span class="n">from_fn</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="nb">Some</span><span class="p">((</span><span class="n">random</span>::<span class="o">&lt;</span><span class="kt">f64</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">random</span>::<span class="o">&lt;</span><span class="kt">f64</span><span class="o">&gt;</span><span class="p">()).</span><span class="n">abs</span><span class="p">()))</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">take</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这里调用了<code>from_fn</code>来制作一个产生随机数的迭代器。因为这个迭代器总是返回<code>Some</code>，因此这个序列永远不会终止，但我们调用了<code>take(1000)</code>来限制只要前1000个元素。然后<code>collect</code>从最后的迭代器构建一个vector。这是一种高效地构建初始化的vector的方式。我们将在本章稍后的“构建集合:<code>collect</code>和<code>FromIterator</code>”中介绍为什么。</p>
<p>如果每一个item都依赖上一个，那么<code>std::iter::successors</code>函数可以漂亮地工作。你需要提供一个初始item和一个函数，这个函数要获取上一个item并返回下一个item的<code>Option</code>。如果返回<code>None</code>，那么迭代终止。例如，这里有另一种编写”第2章”中的曼德勃罗集绘制器的<code>escape_time</code>函数的方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">num</span>::<span class="n">Complex</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">iter</span>::<span class="n">successors</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">escape_time</span><span class="p">(</span><span class="n">c</span>: <span class="nc">Complex</span><span class="o">&lt;</span><span class="kt">f64</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">limit</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">zero</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Complex</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">re</span>: <span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="n">im</span>: <span class="mf">0.0</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">        </span><span class="n">successors</span><span class="p">(</span><span class="nb">Some</span><span class="p">(</span><span class="n">zero</span><span class="p">),</span><span class="w"> </span><span class="o">|&amp;</span><span class="n">z</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">z</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">})</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">take</span><span class="p">(</span><span class="n">limit</span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">enumerate</span><span class="p">()</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="o">|</span><span class="p">(</span><span class="n">_i</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="n">z</span><span class="p">.</span><span class="n">norm_sqr</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">4.0</span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">_z</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>从zero开始，<code>successors</code>调用通过重复平方再加上参数<code>c</code>来产生一个复平面上点的序列。当绘制曼德勃罗集时，我们希望知道这个序列会一直在原点附近还是远离原点。<code>take(limit)</code>调用设置了序列长度的限制，<code>enumerate</code>为每一个点加上一个序号、把每个点<code>z</code>变为元组<code>(i, z)</code>。然后我们使用<code>find</code>来查找第一个离原点足够远可以逃离的点。如果存在这样的点，<code>find</code>方法返回一个<code>Option::Some((i, z))</code>，否则返回<code>None</code>。<code>Option::map</code>的调用会把<code>Some((i, z))</code>变为<code>Some(i)</code>，但不会改变<code>None</code>：这正是我们想要的返回值。</p>
<p><code>from_fn</code>和<code>successors</code>都接受<code>FnMut</code>闭包，因此你的闭包可以捕获并修改作用域中的变量。例如，这个<code>fibonacci</code>函数使用一个<code>move</code>闭包来捕获一个变量并使用它作为运行状态：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">fibonacci</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">=</span><span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="n">std</span>::<span class="n">iter</span>::<span class="n">from_fn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">state</span><span class="p">.</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span><span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">})</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">fibonacci</span><span class="p">().</span><span class="n">take</span><span class="p">(</span><span class="mi">8</span><span class="p">).</span><span class="n">collect</span>::<span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">(),</span><span class="w">
</span><span class="w">               </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="p">,</span><span class="w"> </span><span class="mi">21</span><span class="p">]);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>注意：<code>from_fn</code>和<code>successors</code>方法非常灵活，你可以把对迭代器的任何使用变成对其中一个的单一调用，通过复杂的闭包来获得你需要的行为。但这样做会忽略迭代器提供的表明数据流动和使用标准名称用于通用模式的能力。在你使用这两个函数之前请确保你已经熟悉了本章中的其他迭代器方法，它们通常是更好的完成工作的方式。</p>
<h3 id="drain方法"><code>drain</code>方法</h3>
<p>很多集合类型提供一个<code>drain</code>方法来获取集合的可变引用，并返回一个迭代器把每个元素的所有权传递给消费者。然而，和<code>into_iter()</code>以值获取集合并消耗它不同，<code>drain</code>借用一个集合的可变引用，并且当迭代器被drop时，它会移除集合中剩余的所有元素，让集合变为空。</p>
<p>对于可以用范围索引的类型，例如<code>String</code>、vector、<code>VecDeque</code>，<code>drain</code>方法获取一个要移除的元素的范围，而不是消耗整个序列：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">iter</span>::<span class="n">FromIterator</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">outer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;Earth&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">inner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from_iter</span><span class="p">(</span><span class="n">outer</span><span class="p">.</span><span class="n">dran</span><span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">4</span><span class="p">));</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">outer</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Eh&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">inner</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;art&#34;</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>如果你确实要消耗整个序列，使用整个范围<code>..</code>作为参数。</p>
<h3 id="其他迭代器源">其他迭代器源</h3>
<p>上面的几节基本都是关于像vector和<code>HashMap</code>这样的集合类型的，但标准库中还有很多其他类型支持迭代。”表15-1”总结了一些有趣的类型，但还有更多没有列出。我们将在专门介绍特定类型的章节（即”第16章”、”第17章”、”第18章”）中详细介绍其中的一些方法。</p>
<table>
<thead>
<tr>
<th><strong>类型或trait</strong></th>
<th><strong>表达式</strong></th>
<th><strong>注意</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>std::ops::Range</code></td>
<td><code>1..10</code></td>
<td>端点必须是整数才能迭代。包括起点但不包括终点。</td>
</tr>
<tr>
<td><code>std::ops::Range</code></td>
<td><code>(1..10).step_by(2)</code></td>
<td>产生1，3，5，7，9。</td>
</tr>
<tr>
<td><code>std::ops::RangeFrom</code></td>
<td><code>1..</code></td>
<td>无限迭代。起点必须是整数。当值到达了这种类型的极限时可能会panic或者溢出。</td>
</tr>
<tr>
<td><code>std::ops::RangeInclusive</code></td>
<td><code>1..=10</code></td>
<td>类似<code>Range</code>，但包括终点值。</td>
</tr>
<tr>
<td><code>Option&lt;T&gt;</code></td>
<td><code>Some(10).iter()</code></td>
<td>类似于一个长度为0(<code>None</code>)或1的vector(<code>Some(v)</code>)。</td>
</tr>
<tr>
<td><code>Result&lt;T, E&gt;</code></td>
<td><code>Ok(&quot;blah&quot;).iter()</code></td>
<td>类似于<code>Option</code>，产生<code>Ok</code>值。</td>
</tr>
<tr>
<td><code>Vec&lt;T&gt;, &amp;[T]</code></td>
<td><code>v.windows(16)</code></td>
<td>从左到右产生重叠的、连续的给定长度的切片。</td>
</tr>
<tr>
<td><code>Vec&lt;T&gt;, &amp;[T]</code></td>
<td><code>v.chunks(16)</code></td>
<td>从左到右产生非重叠的、连续的给定长度的切片。</td>
</tr>
<tr>
<td><code>Vec&lt;T&gt;, &amp;[T]</code></td>
<td><code>v.chunks_mut(1024)</code></td>
<td>类似<code>chunks</code>，不过切片是可变的。</td>
</tr>
<tr>
<td><code>Vec&lt;T&gt;, &amp;[T]</code></td>
<td><code>v.split(|byte| byte &amp; 1 != 0)</code></td>
<td>产生被满足条件的元素分隔的切片。</td>
</tr>
<tr>
<td><code>Vec&lt;T&gt;, &amp;[T]</code></td>
<td><code>v.split_mut(...)</code></td>
<td>同上，但产生可变切片。</td>
</tr>
<tr>
<td><code>Vec&lt;T&gt;, &amp;[T]</code></td>
<td><code>v.rsplit(...)</code></td>
<td>类似<code>split</code>，但从右向左产生切片。</td>
</tr>
<tr>
<td><code>Vec&lt;T&gt;, &amp;[T]</code></td>
<td><code>v.splitn(n, ...)</code></td>
<td>类似<code>split</code>，但最多产生<code>n</code>个切片。</td>
</tr>
<tr>
<td><code>String, &amp;str</code></td>
<td><code>s.bytes()</code></td>
<td>产生UTF-8字符串的字节。</td>
</tr>
<tr>
<td><code>String, &amp;str</code></td>
<td><code>s.chars()</code></td>
<td>产生UTF-8字符串的<code>char</code>。</td>
</tr>
<tr>
<td><code>String, &amp;str</code></td>
<td><code>s.split_whitespace()</code></td>
<td>以空格分隔字符串，产生非空字符们的切片。</td>
</tr>
<tr>
<td><code>String, &amp;str</code></td>
<td><code>s.lines()</code></td>
<td>产生字符串的每一行的切片。</td>
</tr>
<tr>
<td><code>String, &amp;str</code></td>
<td><code>s.split('/')</code></td>
<td>用给定的模式分隔字符串，产生每两个匹配之间的内容的切片。模式可以是字符、字符串或者闭包。</td>
</tr>
<tr>
<td><code>std::collections::HashMap, std::collections::BTreeMap</code></td>
<td><code>s.matches(char:: is_numeric)</code></td>
<td>产生匹配给定模式的切片。</td>
</tr>
<tr>
<td><code>std::collections::HashMap, std::collections::BTreeMap</code></td>
<td><code>map.keys(), map.values()</code></td>
<td>产生map的key或value的共享引用。</td>
</tr>
<tr>
<td><code>std::collections::HashMap, std::collections::BTreeMap</code></td>
<td><code>map.values_mut()</code></td>
<td>产生条目的value的可变引用。</td>
</tr>
<tr>
<td><code>std::collections::HashSet, std::collections::BTreeSet</code></td>
<td><code>set1.union(set2)</code></td>
<td>产生<code>set1</code>和<code>set2</code>的并集的元素的共享引用。</td>
</tr>
<tr>
<td><code>std::collections::HashSet, std::collections::BTreeSet</code></td>
<td><code>set1.intersection(set2)</code></td>
<td>产生<code>set1</code>和<code>set2</code>的交集的元素的共享引用。</td>
</tr>
<tr>
<td><code>std::sync::mpsc::Receiver</code></td>
<td><code>rev.iter()</code></td>
<td>产生另一个线程通过相应的<code>Sender</code>发送的值。</td>
</tr>
<tr>
<td><code>std::io::Read</code></td>
<td><code>stream.bytes()</code></td>
<td>产生来自I/O流的字节。</td>
</tr>
<tr>
<td><code>std::io::Read</code></td>
<td><code>stream.chars()</code></td>
<td>以UTF-8解析流，产生<code>char</code>。</td>
</tr>
<tr>
<td><code>std::io::BufRead</code></td>
<td><code>bufstream.lines()</code></td>
<td>以UTF-8解析流，产生<code>String</code>。</td>
</tr>
<tr>
<td><code>std::io::BufRead</code></td>
<td><code>bufstream.split(0)</code></td>
<td>用给定的字节切分流，产生<code>Vec&lt;u8&gt;</code>缓冲区。</td>
</tr>
<tr>
<td><code>std::fs::ReadDir</code></td>
<td><code>std::fs::read_dir(path)</code></td>
<td>产生目录项。</td>
</tr>
<tr>
<td><code>std::net::TcpListener</code></td>
<td><code>listener.incoming()</code></td>
<td>产生到来的网络连接。</td>
</tr>
<tr>
<td>自由函数</td>
<td><code>std::iter::empty()</code></td>
<td>立即返回<code>None</code>。</td>
</tr>
<tr>
<td>自由函数</td>
<td><code>std::iter::once(5)</code></td>
<td>产生给定值然后结束。</td>
</tr>
<tr>
<td>自由函数</td>
<td><code>std::iter::repeat(&quot;#9&quot;)</code></td>
<td>永远产生给定值。</td>
</tr>
</tbody>
</table>
<h2 id="迭代器适配器">迭代器适配器</h2>
<p>一旦你得到了一个迭代器，<code>Iterator</code> trait还提供了广泛的 <em>适配器方法(adapter method)</em> ，或者简称为 <em>适配器(adapter)</em> ，它们消耗一个迭代器然后构建一个新的迭代器。为了展示适配器如何工作，我们将从两个最流行的适配器<code>map</code>和<code>filter</code>开始。然后我们会介绍其他的适配器，它们包括几乎所有你能想到的把一个序列的值变成另一个序列的方法：截断、跳过、组合、反向、连接、重复，等等。</p>
<h3 id="map和filter"><code>map</code>和<code>filter</code></h3>
<p><code>Iterator</code> trait的<code>map</code>适配器让你通过对每一个item应用一个闭包来产生新迭代器。<code>filter</code>迭代器让你通过一个闭包决定保留哪些item丢弃哪些item，以此过滤迭代器中的某些item。</p>
<p>例如，假设你在迭代文本的每一行，并且想省略每一行的前导和尾部的空格。标准库的<code>str::trim</code>方法排除一个<code>&amp;str</code>中的前导和尾部空格，返回一个新的借用<code>&amp;str</code>。你可以使用<code>map</code>适配器来对迭代器返回的每一行应用<code>str::trim</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">text</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;  ponies \n   giraffes\niguanas  \nsquid&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">v</span>: <span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="kt">str</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">text</span><span class="p">.</span><span class="n">lines</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="kt">str</span>::<span class="n">trim</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="s">&#34;ponies&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;giraffes&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;iguanas&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;squid&#34;</span><span class="p">]);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>text.lines()</code>调用返回一个产生每一行的迭代器。对迭代器调用<code>map</code>返回第二个迭代器，它会对每一行调用<code>str::trim</code>，然后将结果作为产生的item。最后，<code>collect</code>把所有item聚集成一个vector。</p>
<p>当然，<code>map</code>返回的迭代器，本身也可以继续适配。如果你想从结果中排除“iguanas”，你可以像下面这样写：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">text</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;  ponies \n   giraffes\niguanas  \nsquid&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">v</span>: <span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="kt">str</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">text</span><span class="p">.</span><span class="n">lines</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="kt">str</span>::<span class="n">trim</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">|</span><span class="n">s</span><span class="o">|</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="s">&#34;iguanas&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="s">&#34;ponies&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;giraffes&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;squid&#34;</span><span class="p">]);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这里<code>filter</code>返回第三个迭代器，只有当<code>map</code>返回的迭代器产生的item调用闭包<code>|s| *s != &quot;iguanas&quot;</code>后返回<code>true</code>时，第三个迭代器才会产生这个item。一个这样的迭代器适配器链就像Unix shell中的管道：每一个适配器都有单个功能，很容易就能看清楚值的序列是如何从左到右转换的。</p>
<p>这两个适配器的签名如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">map</span><span class="o">&lt;</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">=</span><span class="n">B</span><span class="o">&gt;</span><span class="w">
</span><span class="w">        </span><span class="k">where</span><span class="w"> </span><span class="bp">Self</span>: <span class="nb">Sized</span><span class="p">,</span><span class="w"> </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="bp">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">B</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">filter</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">predicate</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">=</span><span class="bp">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w">
</span><span class="w">        </span><span class="k">where</span><span class="w"> </span><span class="bp">Self</span>: <span class="nb">Sized</span><span class="p">,</span><span class="w"> </span><span class="n">P</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>在标准库中，<code>map</code>和<code>filter</code>实际上返回特定的不透明<code>struct</code>类型，分别是<code>std::iter::Map</code>和<code>std::iter::Filter</code>。然而它们的名字提供的信息量很少，所以在本书中我们将用<code>-&gt; impl Iterator&lt;Item=...&gt;</code>来代替，因为它们能告诉我们我们实际想要知道的信息：这个方法返回一个产生给定类型的item的<code>Iterator</code>。</p>
<p>因为大多数适配器以值获取<code>self</code>，所以它们需要<code>Self</code>是<code>Sized</code>（大多数迭代器都是）。</p>
<p><code>map</code>迭代器会依次把所有item以值传递给闭包，然后把结果返回给消费者。<code>filter</code>迭代器以共享引用把所有的item传递给闭包，保留选中的item的所有权，然后把它们传递给消费者。这就是为什么上面的例子要先解引用<code>s</code>再和<code>&quot;iguanas&quot;</code>比较：<code>filter</code>迭代器的item类型是<code>&amp;str</code>，所以闭包参数的类型是<code>&amp;&amp;str</code>。</p>
<p>有关迭代器适配器有两个重要的点。</p>
<p>首先，在一个迭代器上调用适配器并不会消耗任何item，它只会返回一个新的迭代器，这个迭代器按需处理第一个迭代器产生的item来产生自己的item。在一个适配器链中，唯一会消耗item的方式就是对最后的迭代器调用<code>next</code>。</p>
<p>因此在我们之前的例子中，<code>text.lines()</code>方法调用本身并不从字符串解析行，它只是返回一个迭代器，只有当需要的时候这个迭代器 <em>才会</em> 解析行。类似的，<code>map</code>和<code>filter</code>只是返回需要时 <em>才会</em> 映射或过滤的新迭代器。在最后一个<code>collect</code>开始对<code>filter</code>迭代器调用<code>next</code>之前，将不会有任何计算发生。</p>
<p>当你的适配器有副作用时这一点尤其重要。例如，下面的代码什么也不打印：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="p">[</span><span class="s">&#34;earth&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;water&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;air&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;fire&#34;</span><span class="p">]</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">elt</span><span class="o">|</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">elt</span><span class="p">));</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>iter</code>调用返回一个迭代数组元素的迭代器，<code>map</code>调用返回第二个迭代器，第二个迭代器对第一个迭代器产生的每个值调用闭包。但如果整个链中没有要求产生值的操作，那么将不会有<code>next</code>方法被调用。事实上，Rust会警告你这种情况：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">    warning: unused `std::iter::Map` that must be used
      |
    7 | /     [&#34;earth&#34;, &#34;water&#34;, &#34;air&#34;, &#34;fire&#34;]
    8 | |          .iter().map(|elt| println!(&#34;{}&#34;, elt));
      | |________________________________________________^
      |
      = note: iterators are lazy and do nothing unless consumed
</code></pre></td></tr></table>
</div>
</div><p>错误消息中的术语“lazy”并不是贬义词；它只是对任何直到需要时才进行计算的机制的一种称呼。迭代器应该做最少的必要的工作来满足<code>next</code>调用是Rust的习惯；在这个例子中，并没有<code>next</code>调用，因此不会有任何计算发生。</p>
<p>第二个重要的点是迭代器适配器是0成本抽象。因为<code>map</code>、<code>filter</code>以及它们的同伴都是泛型的，将它们用于迭代器会生成特定迭代器类型的代码。这意味着Rust有足够的信息把每一个迭代器<code>next</code>方法内联到消费者中，然后把整个操作作为一个单元翻译为机器码。因此我们上面展示的<code>lines/map/filter</code>迭代器链和你手写的代码一样高效：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">text</span><span class="p">.</span><span class="n">lines</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">line</span><span class="p">.</span><span class="n">trim</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="s">&#34;iguanas&#34;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">v</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">line</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这一节剩余的部分将介绍<code>Iterator</code> trait可用的适配器。</p>
<h3 id="filter_map和flat_map"><code>filter_map</code>和<code>flat_map</code></h3>
<p><code>map</code>适配器适用于一个输入item产生一个输出item的情况。但如果你想删除迭代中的某些item而不是处理它们，或者想将一个item替换成0个或更多的item时该怎么做呢？<code>filter_map</code>和<code>flat_map</code>适配器赋予了你这种灵活性。</p>
<p><code>filter_map</code>适配器类似于<code>map</code>，除了它的闭包要么将一个item转换成一个新的item（和<code>map</code>一样），要么从迭代中丢弃这个item。因此，它有些像<code>filter</code>和<code>map</code>的结合。它的签名如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">filter_map</span><span class="o">&lt;</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">=</span><span class="n">B</span><span class="o">&gt;</span><span class="w">
</span><span class="w">        </span><span class="k">where</span><span class="w"> </span><span class="bp">Self</span>: <span class="nb">Sized</span><span class="p">,</span><span class="w"> </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="bp">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>除了闭包返回<code>Option&lt;B&gt;</code>之外，而不是<code>B</code>之外，它和<code>map</code>的签名是一样的。当闭包返回<code>None</code>时，这个item会从迭代器中丢弃；当它返回<code>Some(b)</code>时，<code>b</code>就是<code>filter_map</code>迭代器产生的下一个item。</p>
<p>例如，假设你想扫描一个字符串中空格分隔的单词，找到其中可以被解析为数字的并处理它，然后丢弃其他单词。那你可以写：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="kt">str</span>::<span class="n">FromStr</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">text</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;1\nfrond .25 289\n3.1415 estuary\n&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">text</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">split_whitespace</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">filter_map</span><span class="p">(</span><span class="o">|</span><span class="n">w</span><span class="o">|</span><span class="w"> </span><span class="kt">f64</span>::<span class="n">from_str</span><span class="p">(</span><span class="n">w</span><span class="p">).</span><span class="n">ok</span><span class="p">())</span><span class="w">
</span><span class="w">    </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{:4.2}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">number</span><span class="p">.</span><span class="n">sqrt</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>打印结果如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">    1.00
    0.50
    17.00
    1.77
</code></pre></td></tr></table>
</div>
</div><p>传给<code>filter_map</code>的闭包尝试对每一个空格分隔的切片调用<code>f64::from_str</code>。这会返回一个<code>Result&lt;f64, ParseFloatError&gt;</code>，它的<code>.ok()</code>返回一个<code>Option&lt;f64&gt;</code>：解析错误时是<code>None</code>，解析成功时是<code>Some(v)</code>。<code>filter_map</code>迭代器丢弃所有的<code>None</code>值，然后对每一个<code>Some(v)</code>产生值<code>v</code>。</p>
<p>但为什么要将<code>map</code>和<code>filter</code>融合成这样的单个操作，而不是直接使用两个适配器？<code>filter_map</code>适配器适用于刚刚展示过的这种情况，即只有实际尝试处理过item才知道应不应该包含这个item的情况。你可以只用<code>filter</code>和<code>map</code>做到同样的事情，但这样会很笨拙：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="n">text</span><span class="p">.</span><span class="n">split_whitespace</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">w</span><span class="o">|</span><span class="w"> </span><span class="kt">f64</span>::<span class="n">from_str</span><span class="p">(</span><span class="n">w</span><span class="p">))</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">|</span><span class="n">r</span><span class="o">|</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">is_ok</span><span class="p">())</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">r</span><span class="o">|</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">unwrap</span><span class="p">())</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>你可以认为<code>flat_map</code>适配器和<code>map</code>、<code>filter_map</code>是同一类的，区别在于现在闭包不是只能返回一个item(<code>map</code>)或者0或1个item(<code>filter_map</code>)，而是可以返回任意数量的item。<code>flat_map</code>迭代器产生闭包返回的序列的串联。</p>
<p><code>flat_map</code>的签名如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">flat_map</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">=</span><span class="n">U</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w">
</span><span class="w">        </span><span class="k">where</span><span class="w"> </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="bp">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">U</span><span class="p">,</span><span class="w"> </span><span class="n">U</span>: <span class="nb">IntoIterator</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>传给<code>flat_map</code>的闭包必须返回一个可迭代对象，但任何类型的可迭代对象都可以。<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
<p>例如，假设我们有一个把国家映射到主要城市的表。给定一个国家的列表，那我们怎么遍历它们的主要城市？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">collections</span>::<span class="n">HashMap</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">major_cities</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">HashMap</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">major_cities</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&#34;Japan&#34;</span><span class="p">,</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="s">&#34;Tokyo&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Kyoto&#34;</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">major_cities</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&#34;The United States&#34;</span><span class="p">,</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="s">&#34;Portland&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Nashville&#34;</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">major_cities</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&#34;Brazil&#34;</span><span class="p">,</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="s">&#34;São Paulo&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Brasilia&#34;</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">major_cities</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&#34;Kenya&#34;</span><span class="p">,</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="s">&#34;Nairobi&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Mombasa&#34;</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">major_cities</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&#34;The Netherlands&#34;</span><span class="p">,</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="s">&#34;Amsterdam&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Utrecht&#34;</span><span class="p">]);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">countries</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s">&#34;Japan&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Brazil&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Kenya&#34;</span><span class="p">];</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="n">city</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">countries</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">flat_map</span><span class="p">(</span><span class="o">|</span><span class="n">country</span><span class="o">|</span><span class="w"> </span><span class="o">&amp;</span><span class="n">major_cities</span><span class="p">[</span><span class="n">country</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">city</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这会打印出下列内容：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">    Tokyo
    Kyoto
    São Paulo
    Brasilia
    Nairobi
    Mombasa
</code></pre></td></tr></table>
</div>
</div><p>这段代码的意思是，对于每一个国家，我们都获取它的城市的vector，然后将所有vector连接成单个序列，然后打印出来。</p>
<p>但记住迭代是惰性的：只有当<code>for</code>循环调用了<code>flat_map</code>迭代器的<code>next</code>方法时才会开始计算。完全连接的序列从来不会在内存中构造。实际上，这里只有一个小的状态机，对于每一个城市迭代器，一次打印一个item，直到耗尽，然后为下一个国家产生一个新的城市迭代器。效果就类似于嵌套的循环，但被打包用作迭代器。</p>
<h3 id="flatten"><code>flatten</code></h3>
<p><code>flatten</code>适配器把迭代器的item连接起来，假设每一个item都是可迭代对象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">collections</span>::<span class="n">BTreeMap</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// 把城市映射到公园的表：每一个value都是一个vector。
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">parks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BTreeMap</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">parks</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&#34;Portland&#34;</span><span class="p">,</span><span class="w">  </span><span class="fm">vec!</span><span class="p">[</span><span class="s">&#34;Mt. Tabor Park&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Forest Park&#34;</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">parks</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&#34;Kyoto&#34;</span><span class="p">,</span><span class="w">     </span><span class="fm">vec!</span><span class="p">[</span><span class="s">&#34;Tadasu-no-Mori Forest&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Maruyama Koen&#34;</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">parks</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&#34;Nashville&#34;</span><span class="p">,</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="s">&#34;Percy Warner Park&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Dargon Park&#34;</span><span class="p">]);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// 构建一个所有公园的vector。`values`返回一个产生vector的迭代器，
</span><span class="c1"></span><span class="w">    </span><span class="c1">// 然后`flatten`按顺序产生每一个vector的元素。
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">all_parks</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parks</span><span class="p">.</span><span class="n">values</span><span class="p">().</span><span class="n">flatten</span><span class="p">().</span><span class="n">cloned</span><span class="p">().</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">all_parks</span><span class="p">,</span><span class="w">
</span><span class="w">               </span><span class="fm">vec!</span><span class="p">[</span><span class="s">&#34;Tadasu-no-Mori Forest&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Maruyama Koen&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Percy Warner Park&#34;</span><span class="p">,</span><span class="w"> 
</span><span class="w">                    </span><span class="s">&#34;Dragon Park&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Mt. Tabor Park&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Forest Park&#34;</span><span class="p">]);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>“flatten”这个名字来自于想象把一个两层的结构压扁成一层的结构：<code>BTreeMap</code>和它的<code>Vec</code>的元素被压成一个产生所有元素的迭代器。</p>
<p><code>flatten</code>的签名如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">flatten</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">=</span><span class="bp">Self</span>::<span class="n">Item</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w">
</span><span class="w">        </span><span class="k">where</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">Item</span>: <span class="nb">IntoIterator</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>换句话说，迭代器的item自身必须实现了<code>IntoIterator</code>，这样它才是一个高效的序列的序列。<code>flatten</code>方法返回一个这些序列连接之后的迭代器。当然，这都是惰性完成的，只有当我们迭代完了一个序列才会从<code>self</code>产生一个新的item。</p>
<p><code>flatten</code>方法还有一些令人惊讶的用法。如果你有一个<code>Vec&lt;Option&lt;...&gt;&gt;</code>并且你想只迭代其中的<code>Some</code>值，那么<code>flatten</code>可以漂亮地工作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="fm">vec!</span><span class="p">[</span><span class="nb">None</span><span class="p">,</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="s">&#34;day&#34;</span><span class="p">),</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="s">&#34;one&#34;</span><span class="p">)]</span><span class="w">
</span><span class="w">               </span><span class="p">.</span><span class="n">into_iter</span><span class="p">()</span><span class="w">
</span><span class="w">               </span><span class="p">.</span><span class="n">flatten</span><span class="p">()</span><span class="w">
</span><span class="w">               </span><span class="p">.</span><span class="n">collect</span>::<span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">(),</span><span class="w">
</span><span class="w">               </span><span class="fm">vec!</span><span class="p">[</span><span class="s">&#34;day&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;one&#34;</span><span class="p">]);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这种方式可以工作是因为<code>Option</code>自身实现了<code>IntoIterator</code>，代表一个有0或1个元素的序列。<code>None</code>元素对迭代过程没有贡献，而每一个<code>Some</code>元素贡献一个值。类似的，你可以使用<code>flatten</code>来迭代<code>Option&lt;Vec&lt;...&gt;&gt;</code>：<code>None</code>和空vector的行为一样。</p>
<p><code>Result</code>也实现了<code>IntoIterator</code>，<code>Err</code>时代表一个空的序列，因此对一个产生<code>Result</code>值的迭代器调用<code>flatten</code>可以高效地排除所有<code>Err</code>，产生一个解包之后的成功值的序列。我们不推荐在代码中忽略错误，但当用户知道自己在做什么时这是一个巧妙的技巧。</p>
<p>当你需要<code>flatten</code>时你可能会发现你真正需要的是<code>flat_map</code>。例如，标准库的<code>str::to_uppercase</code>方法把一个字符串转换成大写，工作方式类似于下面的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">to_uppercase</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">chars</span><span class="p">()</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="kt">char</span>::<span class="n">to_uppercase</span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">flatten</span><span class="p">()</span><span class="w"> </span><span class="c1">// 有更好的方式
</span><span class="c1"></span><span class="w">            </span><span class="p">.</span><span class="n">collect</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这里必须使用<code>flatten</code>的原因是<code>char::to_uppercase()</code>并不是返回单个字符，而是返回一个可能产生一个或更多字符的迭代器。map调用会返回一个产生字符迭代器的迭代器，<code>flatten</code>将它们拼接在一起，因此我们最后可以调用<code>collect</code>把它们转换为一个<code>String</code>。</p>
<p>但这种<code>map</code>和<code>flatten</code>的组合使用如此普遍，以至于<code>Iterator</code>提供了<code>flat_map</code>适配器来处理这种情况。（事实上，<code>flat_map</code>比<code>flatten</code>更先加入标准库。）因此上面的代码可以写成：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">to_uppercase</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">chars</span><span class="p">()</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">flat_map</span><span class="p">(</span><span class="kt">char</span>::<span class="n">to_uppercase</span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">collect</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="take和take_while"><code>take</code>和<code>take_while</code></h3>
<p><code>Iterator</code> trait的<code>take</code>和<code>take_while</code>适配器让你可以在迭代了一定的次数或者当一个闭包决定截断时停止迭代。它们的签名如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">take</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">n</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">=</span><span class="bp">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w">
</span><span class="w">        </span><span class="k">where</span><span class="w"> </span><span class="bp">Self</span>: <span class="nb">Sized</span><span class="p">;</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">take_while</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">predicate</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">=</span><span class="bp">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w">
</span><span class="w">        </span><span class="k">where</span><span class="w"> </span><span class="bp">Self</span>: <span class="nb">Sized</span><span class="p">,</span><span class="w"> </span><span class="n">P</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这两个方法都获取一个迭代器的所有权，返回一个新的迭代器，新的迭代器从第一个item开始迭代，可能会提前终止序列。在产生最多<code>n</code>个item之后<code>take</code>迭代器会返回<code>None</code>。<code>take_while</code>迭代器对每个item引用<code>predicate</code>，当有一个item使<code>predicate</code>返回<code>false</code>时返回<code>None</code>，之后对<code>next</code>的调用也都会返回<code>None</code>。</p>
<p>例如，给定一个电子邮件的消息，其中消息头和消息主体用一个空行分隔，那么你就可以使用<code>take_while</code>来只迭代器消息头：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">message</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">&#34;</span><span class="n">To</span>: <span class="nc">jimb</span><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="w">
</span><span class="w">                   </span><span class="nb">From</span>: <span class="nc">superego</span><span class="w"> </span><span class="o">&lt;</span><span class="n">editor</span><span class="o">@</span><span class="n">oreilly</span><span class="p">.</span><span class="n">com</span><span class="o">&gt;</span><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="w">
</span><span class="w">                   </span><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="w">
</span><span class="w">                   </span><span class="n">Did</span><span class="w"> </span><span class="n">you</span><span class="w"> </span><span class="n">get</span><span class="w"> </span><span class="n">any</span><span class="w"> </span><span class="n">writing</span><span class="w"> </span><span class="n">done</span><span class="w"> </span><span class="n">today</span><span class="o">?</span><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="w">
</span><span class="w">                   </span><span class="n">When</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="n">you</span><span class="w"> </span><span class="n">stop</span><span class="w"> </span><span class="n">wasting</span><span class="w"> </span><span class="n">time</span><span class="w"> </span><span class="n">plotting</span><span class="w"> </span><span class="n">fractals</span><span class="o">?</span><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">n</span><span class="s">&#34;;
</span><span class="s">    for header in message.lines().take_while(|l| !l.is_empty()) {
</span><span class="s">        println!(&#34;</span><span class="p">{}</span><span class="err">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">header</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>回顾“字符串字面量”，当字符串行以反斜杠结尾时，Rust并不会把下一行的缩进包含进字符串里，因此这个字符串中的任何一行都没有前导空格。这意味着<code>message</code>的第三行是空行。<code>take_while</code>适配器第一次看到空行时就会停止迭代，因此这段代码只会打印出两行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">    To: jimb
    From: superego &lt;editor@oreilly.com&gt;
</code></pre></td></tr></table>
</div>
</div><h3 id="skip和skip_while"><code>skip</code>和<code>skip_while</code></h3>
<p><code>Iterator</code> trait的<code>skip</code>和<code>skip_while</code>方法是<code>take</code>和<code>take_while</code>的补充：它们丢弃迭代起始的一定数量的item，或者直到一个闭包找到一个可接受的item时，按原样传递这个和剩余的item。它们的签名如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">skip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">n</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">=</span><span class="bp">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w">
</span><span class="w">        </span><span class="k">where</span><span class="w"> </span><span class="bp">Self</span>: <span class="nb">Sized</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">skip_while</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">predicate</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">=</span><span class="bp">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w">
</span><span class="w">        </span><span class="k">where</span><span class="w"> </span><span class="bp">Self</span>: <span class="nb">Sized</span><span class="p">,</span><span class="w"> </span><span class="n">P</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>skip</code>适配器的一个常见用法是在迭代命令行参数时跳过命令的名字。在”第2章”中，我们的最大公约数计算器就用了下面的代码来迭代它的命令行参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">arg</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">std</span>::<span class="n">env</span>::<span class="n">args</span><span class="p">().</span><span class="n">skip</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>std::env::args</code>函数返回一个迭代器，以<code>String</code>类型产生程序的参数，其中第一个item就是程序自身的名字。我们并不想在这个循环中处理它。对这个迭代器调用<code>skip(1)</code>返回一个新的迭代器，新的迭代器会丢弃程序名，然后产生剩余的参数。</p>
<p><code>skip_while</code>适配器使用闭包来决定丢弃序列开头的多少item。你可以像这样迭代上一节的消息的主体行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">message</span><span class="p">.</span><span class="n">lines</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">skip_while</span><span class="p">(</span><span class="o">|</span><span class="n">l</span><span class="o">|</span><span class="w"> </span><span class="o">!</span><span class="n">l</span><span class="p">.</span><span class="n">is_empty</span><span class="p">())</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">skip</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">body</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这里使用了<code>skip_while</code>来跳过非空的行，但这个迭代器会产生那个空行——也就是使闭包返回<code>false</code>的那个item。因此我们使用了<code>skip</code>方法来丢弃那个空行，这样最后的迭代器的第一个item就是消息主体的第一行。结合上一节中的<code>message</code>，这段代码会打印出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">    Did you get any writing done today?
    When will you stop wasting time plotting fractals?
</code></pre></td></tr></table>
</div>
</div><h3 id="peekable"><code>peekable</code></h3>
<p>peekable迭代器让你可以窥视下一个将被产生的item，而不实际消耗它。你可以通过调用<code>Iterator</code> trait的<code>peekable</code>方法把一个迭代器转换成一个peekable迭代器：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">peekable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">std</span>::<span class="n">iter</span>::<span class="n">Peekable</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;</span><span class="w">
</span><span class="w">        </span><span class="k">where</span><span class="w"> </span><span class="bp">Self</span>: <span class="nb">Sized</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这里，<code>Peekable&lt;Self&gt;</code>是一个实现了<code>Iterator&lt;Item=Self::Item&gt;</code>的<code>struct</code>，其中<code>Self</code>是底层迭代器的类型。</p>
<p><code>Peekable</code>迭代器有一个额外的<code>peek</code>方法返回一个<code>Option&lt;&amp;Item&gt;</code>：如果底层迭代器已经迭代完就返回<code>None</code>，否则返回<code>Some(r)</code>，其中<code>r</code>是下一个item的共享引用。（注意如果底层迭代器的item的类型已经是一个引用，那么最后返回的将是一个引用的引用。）</p>
<p>调用<code>peek</code>会尝试获取底层迭代器的下一个item，如果确实还有item，就缓存它直到下一次调用<code>next</code>。<code>Peekable</code>的其他<code>Iterator</code>的方法都知道这个缓存：例如，一个peekable迭代器<code>iter</code>的调用<code>iter.last()</code>知道在耗尽了底层的迭代器之后检查缓存。</p>
<p>当你必须要遍历之后才知道到底要消耗多少item时，peekable迭代器就很重要了。例如，如果你正在一个字符流解析数字，只有当你看到了数字之后的第一个非数字字符时你才能知道数字在哪里结束：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">iter</span>::<span class="n">Peekable</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">parse_number</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tokens</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Peekable</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span>
        <span class="nc">where</span><span class="w"> </span><span class="n">I</span>: <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">=</span><span class="kt">char</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">match</span><span class="w"> </span><span class="n">tokens</span><span class="p">.</span><span class="n">peek</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="nb">Some</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">is_digit</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                    </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">to_digit</span><span class="p">(</span><span class="mi">10</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">                </span><span class="p">}</span><span class="w">
</span><span class="w">                </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">            </span><span class="n">tokens</span><span class="p">.</span><span class="n">next</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">chars</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;226153980,1766319049&#34;</span><span class="p">.</span><span class="n">chars</span><span class="p">().</span><span class="n">peekable</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">parse_number</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">chars</span><span class="p">),</span><span class="w"> </span><span class="mi">226153980</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="c1">// `parse_number`不会消耗逗号！因此下面不会出错。
</span><span class="c1"></span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">chars</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="sc">&#39;,&#39;</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">parse_number</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">chars</span><span class="p">),</span><span class="w"> </span><span class="mi">1766319049</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">chars</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>parse_number</code>函数使用<code>peek</code>方法来检查下一个字符，并且只有当它是数字时才消耗它。如果它不是数字或者迭代器被耗尽（也就是，如果<code>peek</code>返回<code>None</code>），我们将会返回已经解析的数字，将下一个字符留在迭代器里，之后再消耗。</p>
<h3 id="fuse"><code>fuse</code></h3>
<p>一旦一个<code>Iterator</code>返回<code>None</code>，trait并没有指定如果你继续调用<code>next</code>方法时它的行为。大多数迭代器都是再次返回<code>None</code>，但并不是所有。如果你的代码依赖这种行为，那你有时可能会遇到奇怪的行为。</p>
<p><code>fuse</code>适配器接受任何迭代器，并产生一个保证第一次返回<code>None</code>之后一直返回<code>None</code>的迭代器：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">struct</span> <span class="nc">Flaky</span><span class="p">(</span><span class="kt">bool</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="nb">Iterator</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Flaky</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">type</span> <span class="nc">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;&#39;</span><span class="nb">static</span><span class="w"> </span><span class="kt">str</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w">
</span><span class="w">                </span><span class="nb">Some</span><span class="p">(</span><span class="s">&#34;totally the last item&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">  </span><span class="c1">// D&#39;oh!
</span><span class="c1"></span><span class="w">                </span><span class="nb">None</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">flaky</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Flaky</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">flaky</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="s">&#34;totally the last item&#34;</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">flaky</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">flaky</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="s">&#34;totally the last item&#34;</span><span class="p">));</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">not_flaky</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Flaky</span><span class="p">(</span><span class="kc">true</span><span class="p">).</span><span class="n">fuse</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">not_flaky</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="s">&#34;totally the last item&#34;</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">not_flaky</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">not_flaky</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>fuse</code>适配器最有用的场景可能是需要使用不确定来源的迭代器的泛型代码。与其希望每一个要处理的迭代器都是良定义的，不如使用<code>fuse</code>来确保这种行为。</p>
<h3 id="可逆迭代器和rev">可逆迭代器和<code>rev</code></h3>
<p>一些迭代器可以从序列的任意一端产生item。你可以通过使用<code>rev</code>适配器来反转这样的迭代器。例如，一个vector的迭代器可以简单的从尾部到头部产生item。这样的迭代器可以实现<code>std::iter::DoubleEndedIterator</code> trait，它是<code>Iterator</code>的扩展：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">trait</span><span class="w"> </span><span class="nb">DoubleEndedIterator</span>: <span class="nb">Iterator</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">next_back</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>你可以将这样的双端迭代器看做有两个标记分别指向正向和反向迭代的位置。每次从其中一个产生item，都会让它向另一个的方向移动；当它们交汇的时候，迭代就结束了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">bee_parts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s">&#34;head&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;thorax&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;abdomen&#34;</span><span class="p">];</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bee_parts</span><span class="p">.</span><span class="n">iter</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w">      </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="s">&#34;head&#34;</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">next_back</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="s">&#34;abdomen&#34;</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w">      </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="s">&#34;thorax&#34;</span><span class="p">));</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">next_back</span><span class="p">(),</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">next_back</span><span class="p">(),</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>切片的迭代器可以很容易的实现这种行为：它利用两个指针分别指向还未产生的元素范围的起点和终点；<code>next</code>和<code>next_back</code>简单地从其中一个产生一个item。有序集合的迭代器例如<code>BTreeSet</code>和<code>BTreeMap</code>也是双端迭代器：它们的<code>next_back</code>方法以最大元素或条目优先的顺序返回item。一般来说，标准库在可行时都会提供双端迭代器。</p>
<p>但并不是所有的迭代器都可以简单地做到这一点：一个产生其他线程发给通道的<code>Receiver</code>的值的迭代器没有办法预测最后一个到达的值会是什么。一般来说，你应该检查标准库的文档来看看哪些迭代器实现了<code>DoubleEndedIterator</code>，哪些没有。</p>
<p>如果一个迭代器是双端的，你可以使用<code>rev</code>适配器来反转它：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">rev</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">=</span><span class="bp">Self</span><span class="o">&gt;</span><span class="w">
</span><span class="w">        </span><span class="k">where</span><span class="w"> </span><span class="bp">Self</span>: <span class="nb">Sized</span> <span class="o">+</span><span class="w"> </span><span class="nb">DoubleEndedIterator</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>返回的迭代器也是一个双端迭代器：它的<code>next</code>和<code>next_back</code>方法被简单地交换了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">meals</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s">&#34;breakfast&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;lunch&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;dinner&#34;</span><span class="p">];</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">meals</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">rev</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="s">&#34;dinner&#34;</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="s">&#34;lunch&#34;</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="s">&#34;breakfast&#34;</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>大多数迭代器适配器如果被用于可逆迭代器，会返回另一个可逆迭代器。例如，<code>map</code>和<code>filter</code>会保留可逆性。</p>
<h3 id="inspect"><code>inspect</code></h3>
<p><code>inspect</code>适配器在调试迭代器适配器的流水线时很有用，但通常不用在生产代码中。它简单地对每一个item的共享引用应用一个闭包然后传递它们。闭包不能影响到item，但可以做一些类似于打印或进行断言的操作。</p>
<p>这个例子展示了一个将字符串转换为大写会改变长度的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">upper_case</span>: <span class="nb">String</span> <span class="o">=</span><span class="w"> </span><span class="s">&#34;große&#34;</span><span class="p">.</span><span class="n">chars</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">inspect</span><span class="p">(</span><span class="o">|</span><span class="n">c</span><span class="o">|</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;before: {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">))</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">flat_map</span><span class="p">(</span><span class="o">|</span><span class="n">c</span><span class="o">|</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">to_uppercase</span><span class="p">())</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">inspect</span><span class="p">(</span><span class="o">|</span><span class="n">c</span><span class="o">|</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34; after:     {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">))</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">upper_case</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;GROSSE&#34;</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>小写德语字母“ß”的大写形式是“SS”，这就是为什么<code>char::to_uppercase</code>会返回一个产生字符的迭代器，而不是单个字符。上面的代码中使用<code>flat_map</code>来把所有<code>to_uppercase</code>序列连接成单个<code>String</code>，它会打印出下列内容：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">    before: &#39;g&#39;
     after:     &#39;G&#39;
    before: &#39;r&#39;
     after:     &#39;R&#39;
    before: &#39;o&#39;
     after:     &#39;O&#39;
    before: &#39;ß&#39;
     after:     &#39;S&#39;
     after:     &#39;S&#39;
    before: &#39;e&#39;
     after:     &#39;E&#39;
</code></pre></td></tr></table>
</div>
</div><h3 id="chain"><code>chain</code></h3>
<p><code>chain</code>迭代器适配器将一个迭代器附加到另一个之后。更确切地说，<code>i1.chain(i2)</code>返回的迭代器会首先产生<code>i1</code>的item，当<code>i1</code>耗尽后，再继续产生<code>i2</code>的item。</p>
<p><code>chain</code>适配器的签名如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">chain</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">U</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">=</span><span class="bp">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w">
</span><span class="w">        </span><span class="k">where</span><span class="w"> </span><span class="bp">Self</span>: <span class="nb">Sized</span><span class="p">,</span><span class="w"> </span><span class="n">U</span>: <span class="nb">IntoIterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">=</span><span class="bp">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>换句话说，你可以将任何产生相同类型item的迭代器连接起来。
例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">v</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">4</span><span class="p">).</span><span class="n">chain</span><span class="p">(</span><span class="fm">vec!</span><span class="p">[</span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mi">30</span><span class="p">,</span><span class="w"> </span><span class="mi">40</span><span class="p">]).</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mi">30</span><span class="p">,</span><span class="w"> </span><span class="mi">40</span><span class="p">]);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>如果两个底层迭代器都是可逆的，那么<code>chain</code>迭代器也是可逆的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">v</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">4</span><span class="p">).</span><span class="n">chain</span><span class="p">(</span><span class="fm">vec!</span><span class="p">[</span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mi">30</span><span class="p">,</span><span class="w"> </span><span class="mi">40</span><span class="p">]).</span><span class="n">rev</span><span class="p">().</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">40</span><span class="p">,</span><span class="w"> </span><span class="mi">30</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">]);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>一个<code>chain</code>迭代器会追踪是否两个底层迭代器返回过<code>None</code>，并正确地调用<code>next</code>或者<code>next_back</code>。</p>
<h3 id="enumerate"><code>enumerate</code></h3>
<p><code>Iterator</code> trait的<code>enumerate</code>适配器把一个索引附加到序列中，它以一个产生<code>A, B, C, ...</code>的迭代器为参数，返回一个产生<code>(0, A), (1, B), (2, C), ...</code>的迭代器。第一眼可能会觉得它用处不大，但实际上它非常常用。</p>
<p>消费者可以使用索引来区分不同的item并建立起处理每个item的上下文。例如，”第2章”中的曼德勃罗集绘制器将图像分割成了8个水平的条带，并把每个条带分到不同的线程中进行处理。那段代码使用了<code>enumerate</code>来告诉每个线程它的条带是图像中的哪一部分。</p>
<p>它以一个矩形像素的缓冲区开始：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">pixels</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">columns</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">rows</span><span class="p">];</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>然后，它使用了<code>chunks_mut</code>把图像分割成水平的条带，每个线程一个条带：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">band_rows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rows</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">bands</span>: <span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pixels</span><span class="p">.</span><span class="n">chunks_mut</span><span class="p">(</span><span class="n">band_rows</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">columns</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>然后它迭代条带，为每个条带开启一个新线程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">band</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">bands</span><span class="p">.</span><span class="n">into_iter</span><span class="p">().</span><span class="n">enumerate</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">top</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">band_rows</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="c1">// 启动一个线程渲染`top..top + band_rows&#34;范围内的行
</span><span class="c1"></span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>每一次迭代会得到一个<code>(i, band)</code>，其中<code>band</code>是这个线程应该绘制的像素缓冲区的<code>&amp;mut [u8]</code>切片，<code>i</code>是条带在整个图片中的索引，由<code>enumerate</code>适配器产生。给定图像的长宽和条带的大小，一个线程就获取了足够的信息来判断它要处理的是图像的哪一部分，并且因此能正确绘制<code>band</code>。</p>
<p>你可以将<code>enumerate</code>产生的<code>(index, item)</code>类比迭代<code>HashMap</code>或其他关联集合时得到的<code>(key, value)</code>对。如果你在迭代一个切片或者vector，那么<code>index</code>就是<code>item</code>出现的“key”。</p>
<h3 id="zip"><code>zip</code></h3>
<p><code>zip</code>适配器将两个迭代器组合成单个迭代器，它一次产生一个pair，pair里分别是两个迭代器产生的item，就像是一条拉链一样把两边汇聚成单条缝隙。当两个底层迭代器中有任何一个结束时，zip迭代器也会结束。</p>
<p>例如，你可以通过把无限范围<code>0..</code>和另一迭代器zip在一起来达到<code>enumerate</code>适配的效果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">v</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="p">).</span><span class="n">zip</span><span class="p">(</span><span class="s">&#34;ABCD&#34;</span><span class="p">.</span><span class="n">chars</span><span class="p">()).</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;A&#39;</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;B&#39;</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;C&#39;</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;D&#39;</span><span class="p">)]);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>从这个意义上讲，你可以将<code>zip</code>看做<code>enumerate</code>的泛化版：<code>enumerate</code>把索引附加序列中，<code>zip</code>把任意另一个迭代器的item附加到序列中。我们之前建议过<code>enumerate</code>可以帮助提供处理item的上下文；<code>zip</code>是一种更灵活的实现同样功能的方式。</p>
<p><code>zip</code>的参数不需要是一个和调用者自己同类型的迭代器；它可以是任意的可迭代对象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">iter</span>::<span class="n">repeat</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">endings</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="s">&#34;once&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;twice&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;chicken soup with rice&#34;</span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">rhyme</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">repeat</span><span class="p">(</span><span class="s">&#34;going&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">zip</span><span class="p">(</span><span class="n">endings</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">rhyme</span><span class="p">,</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[(</span><span class="s">&#34;going&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;once&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">                           </span><span class="p">(</span><span class="s">&#34;going&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;twice&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">                           </span><span class="p">(</span><span class="s">&#34;going&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;chicken soup with rice&#34;</span><span class="p">)]);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="by_ref"><code>by_ref</code></h3>
<p>在本节中，我们已经见过很多次把适配器附加到迭代器上。但一旦这么做了之后，还可以把适配器去除掉吗？通常是不行的：适配器会获取底层迭代器的所有权，而且不提供方法返回底层迭代器。</p>
<p>迭代器的<code>by_ref</code>方法借用一个迭代器的可变引用，然后你可以对这个引用应用适配器。当你消耗完这些适配器的item之后，你会drop它们，然后借用结束，你可以重新访问原本的迭代器。</p>
<p>例如，本章前面我们展示过怎么使用<code>take_while</code>和<code>skip_while</code>来处理邮件消息的消息头或者主体。但如果你想用同一个底层迭代器同时处理两者呢？使用<code>by_ref</code>，我们可以使用<code>take_while</code>来处理消息头，然后等它结束之后重新获得底层迭代器的访问权，而<code>take_while</code>结束之后底层迭代器恰好留在消息主体的位置上：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">message</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">&#34;</span><span class="n">To</span>: <span class="nc">jimb</span><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="w">
</span><span class="w">                  </span><span class="nb">From</span>: <span class="nc">id</span><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="w">
</span><span class="w">                  </span><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">n</span><span class="err">\</span><span class="w">
</span><span class="w">                  </span><span class="n">Oooooh</span><span class="p">,</span><span class="w"> </span><span class="n">donuts</span><span class="o">!!</span><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">n</span><span class="s">&#34;;
</span><span class="s">
</span><span class="s">    let mut lines = message.lines();
</span><span class="s">
</span><span class="s">    println!(&#34;</span><span class="n">Headers</span>:<span class="s">&#34;);
</span><span class="s">    for header in liens.by_ref().take_while(|l| !l.is_empty()) {
</span><span class="s">        println!(&#34;</span><span class="p">{}</span><span class="s">&#34;, header);
</span><span class="s">    }
</span><span class="s">
</span><span class="s">    println!(&#34;</span><span class="err">\</span><span class="n">nBody</span>:<span class="s">&#34;);
</span><span class="s">    for body in lines {
</span><span class="s">        println!(&#34;</span><span class="p">{}</span><span class="err">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">body</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>line.by_ref()</code>调用借用了迭代器的可变引用，然后<code>take_while</code>获取的是这个可变引用的所有权。当第一个<code>for</code>循环结束时，这个引用就离开了作用域，这意味着借用结束了，因此你可以在第二个<code>for</code>循环中再次使用<code>lines</code>。这会打印出下面的内容：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">    Headers:
    To: jimb
    From: id

    Body:
    Oooooh, donuts!
</code></pre></td></tr></table>
</div>
</div><p><code>by_ref</code>适配器的定义很简单，它返回一个迭代器的可变引用。然后，标准库包含这个奇怪的实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">impl</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">I</span>: <span class="nb">Iterator</span> <span class="o">+</span><span class="w"> </span><span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Iterator</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">type</span> <span class="nc">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I</span>::<span class="n">Item</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">I</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="p">).</span><span class="n">next</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">size_hint</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">(</span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="p">).</span><span class="n">size_hint</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>换句话说，如果<code>I</code>是迭代器，那么<code>&amp;mut I</code>也是一个迭代器，它的<code>next</code>和<code>size_hint</code>方法指向它引用的对象的相应方法。当你在一个迭代器的可变引用上调用适配器时，适配器会获取 <em>引用</em> 的所有权，而不是迭代器本身的所有权。它只是一个当适配器离开作用域时就会结束的借用。</p>
<h3 id="cloned和copied"><code>cloned</code>和<code>copied</code></h3>
<p><code>cloned</code>适配器获取一个产生引用的迭代器，然后返回一个产生这些引用的拷贝操作返回的值的迭代器。就类似于<code>iter.map(|item| item.clone())</code>。自然地，被引用的类型必须实现<code>Clone</code>。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="sc">&#39;1&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;2&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;3&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;=&#39;</span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">next</span><span class="p">(),</span><span class="w">          </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="sc">&#39;a&#39;</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">cloned</span><span class="p">().</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="sc">&#39;1&#39;</span><span class="p">));</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>copied</code>适配器也是相同的思路，但更加严格：被引用的类型必须实现<code>Copy</code>。<code>iter.copied()</code>调用类似于<code>iter.map(|r| *r)</code>。因为每个实现了<code>Copy</code>的类型都实现了<code>Clone</code>，所以<code>cloned</code>通常更一般化，但根据item的类型不同，<code>clone</code>调用可以做任意次的分配和拷贝操作。如果你假设你的item的类型足够简单所以永远不会发生这种情况，那么最好的方法还是使用<code>copied</code>来让类型检查器检查你的假设。</p>
<h3 id="cycle"><code>cycle</code></h3>
<p><code>cycle</code>适配器返回一个无限重复底层迭代器产生的序列的迭代器。底层迭代器必须实现了<code>std::clone::Clone</code>，这样<code>cycle</code>才可以保存它的初始状态，然后在每一次循环开始时重用它。</p>
<p>例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">dirs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s">&#34;North&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;East&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;South&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;West&#34;</span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">spin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dirs</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">cycle</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">spin</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="s">&#34;North&#34;</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">spin</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="s">&#34;East&#34;</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">spin</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="s">&#34;South&#34;</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">spin</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="s">&#34;West&#34;</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">spin</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="s">&#34;North&#34;</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">spin</span><span class="p">.</span><span class="n">next</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="s">&#34;East&#34;</span><span class="p">));</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>或者，完全没有任何开销地使用它：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">iter</span>::<span class="p">{</span><span class="n">once</span><span class="p">,</span><span class="w"> </span><span class="n">repeat</span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">fizzes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">repeat</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">).</span><span class="n">take</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="n">chain</span><span class="p">(</span><span class="n">once</span><span class="p">(</span><span class="s">&#34;fize&#34;</span><span class="p">)).</span><span class="n">cycle</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">buzzes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">repeat</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">).</span><span class="n">take</span><span class="p">(</span><span class="mi">4</span><span class="p">).</span><span class="n">chain</span><span class="p">(</span><span class="n">once</span><span class="p">(</span><span class="s">&#34;buzz&#34;</span><span class="p">)).</span><span class="n">cycle</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">fizzes_buzzes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fizzes</span><span class="p">.</span><span class="n">zip</span><span class="p">(</span><span class="n">buzzes</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">fizz_buzz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">).</span><span class="n">zip</span><span class="p">(</span><span class="n">fizzes_buzzes</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">tuple</span><span class="o">|</span><span class="w">
</span><span class="w">             </span><span class="k">match</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                 </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;&#34;</span><span class="p">))</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">i</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w">
</span><span class="w">                 </span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">fizz</span><span class="p">,</span><span class="w"> </span><span class="n">buzz</span><span class="p">))</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">format!</span><span class="p">(</span><span class="s">&#34;{}{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">fizz</span><span class="p">,</span><span class="w"> </span><span class="n">buzz</span><span class="p">)</span><span class="w">
</span><span class="w">             </span><span class="p">});</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">fizz_buzz</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这样就完成了一个小孩子的单词游戏，现在有时也会被用作程序员的面试题目。在这个游戏中，玩家要轮流计数，把任何能被3整除的数替换成单词<code>fizz</code>，任何能被5整除的数替换成<code>fizzbuzz</code>。能被3和5同时整除的数替换为<code>fizzbuzz</code>。</p>
<h2 id="消耗迭代器">消耗迭代器</h2>
<p>到目前为止，我们已经介绍了创建迭代器和用适配器将它们包装成新的迭代器；接下来我们将展示如何消耗它们来结束这个过程。</p>
<p>当然，你可以使用<code>for</code>循环来消耗一个迭代器，或者显式地调用<code>next</code>，但有很多常见的任务没必要一次又一次地写出来。<code>Iterator</code> trait提供了许多的方法来处理很多常用的情况。</p>
<h3 id="简单的累计count-sum-product">简单的累计：<code>count, sum, product</code></h3>
<p><code>count</code>方法不断从一个迭代器获取item直到它返回<code>None</code>，然后告诉你它到底获得了多少个item。这里有一个简短的程序来统计标准输入的行数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">predule</span>::<span class="o">*</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">stdin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">stdin</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">stdin</span><span class="p">.</span><span class="n">lock</span><span class="p">().</span><span class="n">lines</span><span class="p">().</span><span class="n">count</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>sum</code>和<code>product</code>方法计算迭代器的item的和或者积，item必须是整数或者浮点数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">triangle</span><span class="p">(</span><span class="n">n</span>: <span class="kt">u64</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u64</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="mi">1</span><span class="o">..=</span><span class="n">n</span><span class="p">).</span><span class="n">sum</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">triangle</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span><span class="w"> </span><span class="mi">210</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">factorial</span><span class="p">(</span><span class="n">n</span>: <span class="kt">u64</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u64</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="mi">1</span><span class="o">..=</span><span class="n">n</span><span class="p">).</span><span class="n">product</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">factorial</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span><span class="w"> </span><span class="mi">2432902008176640000</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>（你可以通过实现<code>std::iter::Sum</code>和<code>std::iter::Product</code> trait来扩展<code>sum</code>和<code>product</code>以支持其他类型，但本书中不会介绍。）</p>
<h3 id="max-min"><code>max, min</code></h3>
<p><code>Iterator</code>的<code>min</code>和<code>max</code>方法分别返回迭代器产生的item中最小的和最大的。item的类型必须实现了<code>std::cmp::Ord</code>，这样才可以互相比较。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">5</span><span class="p">].</span><span class="n">iter</span><span class="p">().</span><span class="n">max</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="w"> </span><span class="p">,</span><span class="o">-</span><span class="mi">5</span><span class="p">].</span><span class="n">iter</span><span class="p">().</span><span class="n">min</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;-</span><span class="mi">5</span><span class="p">));</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这些方法返回<code>Option&lt;Self::Item&gt;</code>，这样如果迭代器没产生值的时候可以返回<code>None</code>。</p>
<p>正如“相等性比较”中解释的一样，Rust的浮点数类型<code>f32</code>和<code>f64</code>只实现了<code>std::cmp::PartialOrd</code>，没有实现<code>std::cmp::Ord</code>，因此你不能使用<code>min</code>和<code>max</code>方法来计算浮点数序列中的最小值或最大值。这不是Rust设计中的优势，但它是故意的：因为不清楚这样的函数如果遇到了IEEE NaN值时该怎么处理。简单地忽略它们可能会导致代码中更严重的问题。</p>
<p>如果你知道如何处理NaN值，你可以使用<code>max_by</code>和<code>min_by</code>迭代器方法作为代替，它允许你提供自己的比较函数。</p>
<h3 id="max_by-min_by"><code>max_by, min_by</code></h3>
<p><code>max_by</code>和<code>min_by</code>方法分别返回迭代器产生的最大值和最小值，通过一个你提供的比较函数来判断大小：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">cmp</span>::<span class="n">Ordering</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// 比较两个f64值，如果有NaN就panic
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">cmp</span><span class="p">(</span><span class="n">lhs</span>: <span class="kp">&amp;</span><span class="kt">f64</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="kp">&amp;</span><span class="kt">f64</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Ordering</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">lhs</span><span class="p">.</span><span class="n">partial_cmp</span><span class="p">(</span><span class="n">rhs</span><span class="p">).</span><span class="n">unwrap</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">numbers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">4.0</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">copied</span><span class="p">().</span><span class="n">max_by</span><span class="p">(</span><span class="n">cmp</span><span class="p">),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mf">4.0</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">copied</span><span class="p">().</span><span class="n">min_by</span><span class="p">(</span><span class="n">cmp</span><span class="p">),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mf">1.0</span><span class="p">));</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">numbers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">4.0</span><span class="p">,</span><span class="w"> </span><span class="n">std</span>::<span class="kt">f64</span>::<span class="n">NAN</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">copied</span><span class="p">().</span><span class="n">max_by</span><span class="p">(</span><span class="n">cmp</span><span class="p">),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mf">4.0</span><span class="p">));</span><span class="w"> </span><span class="c1">// panic
</span></code></pre></td></tr></table>
</div>
</div><p><code>max_by</code>和<code>min_by</code>方法以引用的方式把item传递给比较函数，这样不管迭代器产生什么类型的值它们都可以高效工作。因此这里<code>cmp</code>要以引用获取参数，即使我们已经使用<code>copied</code>获取过一个产生<code>f64</code> item的迭代器。</p>
<h3 id="max_by_key-min_by_key"><code>max_by_key, min_by_key</code></h3>
<p><code>Iterator</code>的<code>max_by_key</code>和<code>min_by_key</code>方法通过比较对item调用闭包返回的值来分别返回最大值和最小值。闭包可以选择item的某些字段或者对item进行计算。因为你通常对最大和最小值相关联的数据感兴趣，而不是对极值本身感兴趣，因此这些方法通常比<code>max</code>和<code>min</code>更有用。它们的签名如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">min_by_key</span><span class="o">&lt;</span><span class="n">B</span>: <span class="nb">Ord</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w">
</span><span class="w">        </span><span class="k">where</span><span class="w"> </span><span class="bp">Self</span>: <span class="nb">Sized</span><span class="p">,</span><span class="w"> </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">B</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">max_by_key</span><span class="o">&lt;</span><span class="n">B</span>: <span class="nb">Ord</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w">
</span><span class="w">        </span><span class="k">where</span><span class="w"> </span><span class="bp">Self</span>: <span class="nb">Sized</span><span class="p">,</span><span class="w"> </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">B</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这两个方法接受一个闭包<code>f</code>作为参数，<code>f</code>需要接受一个item并返回一个有序的类型<code>B</code>。然后这两个方法对每个item都调用<code>f</code>，根据返回的<code>B</code>类型的值来比较大小，最后分别返回最大和最小的item，或者如果没有item产生时返回<code>None</code>。</p>
<p>例如，如果你需要扫描一个城市的哈希表来查找人口最多和最少的城市，你可以写：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">collections</span>::<span class="n">HashMap</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">populations</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">HashMap</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">populations</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&#34;Portland&#34;</span><span class="p">,</span><span class="w">  </span><span class="mi">583_776</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">populations</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&#34;Fossil&#34;</span><span class="p">,</span><span class="w">        </span><span class="mi">449</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">populations</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&#34;Greenhorn&#34;</span><span class="p">,</span><span class="w">       </span><span class="mi">2</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">populations</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&#34;Boring&#34;</span><span class="p">,</span><span class="w">      </span><span class="mi">7_762</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">populations</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&#34;The Dalles&#34;</span><span class="p">,</span><span class="w"> </span><span class="mi">15_340</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">populations</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">max_by_key</span><span class="p">(</span><span class="o">|&amp;</span><span class="p">(</span><span class="n">_name</span><span class="p">,</span><span class="w"> </span><span class="n">pop</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="n">pop</span><span class="p">),</span><span class="w">
</span><span class="w">               </span><span class="nb">Some</span><span class="p">((</span><span class="o">&amp;</span><span class="s">&#34;Portland&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="mi">583_776</span><span class="p">)));</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">populations</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">min_by_key</span><span class="p">(</span><span class="o">|&amp;</span><span class="p">(</span><span class="n">_name</span><span class="p">,</span><span class="w"> </span><span class="n">pop</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="n">pop</span><span class="p">),</span><span class="w">
</span><span class="w">               </span><span class="nb">Some</span><span class="p">((</span><span class="o">&amp;</span><span class="s">&#34;Greenhorn&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="mi">2</span><span class="p">)));</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>闭包<code>|&amp;(_name, pop)| pop</code>会应用到迭代器产生的每个item，然后返回用于比较的值——在这个例子中，就是城市的人口。最后返回的值是整个item，而不仅仅是闭包返回的值。（当然，如果你经常进行这样的查询，你可能会需要一种更高效的存储方式来查找，而不是在这样的表上进行线性查找。）</p>
<h3 id="比较item序列">比较item序列</h3>
<p>你可以使用<code>&lt;</code>和<code>==</code>运算符来比较字符串、vector、切片，假设它们的元素可以被比较。尽管迭代器不支持Rust的比较运算符，但它们确实提供了方法例如<code>eq</code>和<code>lt</code>来做相同的工作，这些方法每次从两个迭代器各取一个item进行比较，直到可以比较出结果。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">packed</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="s">&#34;Helen of Troy&#34;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">spaced</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="s">&#34;Helen   of    Troy&#34;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">obscure</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;Helen of Sandusky&#34;</span><span class="p">;</span><span class="w">  </span><span class="c1">// 好人，只是没名气
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="fm">assert!</span><span class="p">(</span><span class="n">packed</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">spaced</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="fm">assert!</span><span class="p">(</span><span class="n">packed</span><span class="p">.</span><span class="n">split_whitespace</span><span class="p">().</span><span class="n">eq</span><span class="p">(</span><span class="n">spaced</span><span class="p">.</span><span class="n">split_whitespace</span><span class="p">()));</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// 比较为真，因为&#39; &#39; &lt; &#39;o&#39;
</span><span class="c1"></span><span class="w">    </span><span class="fm">assert!</span><span class="p">(</span><span class="n">spaced</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">obscure</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// 比较为真，因为&#39;Troy&#39; &gt; &#39;Sandusky&#39;
</span><span class="c1"></span><span class="w">    </span><span class="fm">assert!</span><span class="p">(</span><span class="n">spaced</span><span class="p">.</span><span class="n">split_whitespace</span><span class="p">().</span><span class="n">gt</span><span class="p">(</span><span class="n">obscure</span><span class="p">.</span><span class="n">split_whitespace</span><span class="p">()));</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>split_whitespace</code>的调用返回一个迭代字符串中空格分隔的单词的迭代器。对这些迭代器使用<code>eq</code>和<code>gt</code>方法会进行逐单词的比较，而不是逐字符比较。这些比较都是可行的，因为<code>&amp;str</code>实现了<code>PartialOrd</code>和<code>PartialEq</code>。</p>
<p>迭代器提供<code>eq</code>和<code>ne</code>方法进行相等性比较，以及<code>lt, le, gt, ge</code>方法用于顺序性比较。<code>cmp</code>和<code>partial_cmp</code>方法的行为类似于<code>Ord</code>和<code>PartialOrd</code> trait的相应方法。</p>
<h3 id="any和all"><code>any</code>和<code>all</code></h3>
<p><code>any</code>和<code>all</code>方法对迭代器产生的每一个item都应用一个闭包，分别当任意item使闭包返回<code>true</code>和所有item都使闭包返回<code>true</code>时返回<code>true</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;Iterator&#34;</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="fm">assert!</span><span class="p">(</span><span class="w"> </span><span class="n">id</span><span class="p">.</span><span class="n">chars</span><span class="p">().</span><span class="n">any</span><span class="p">(</span><span class="kt">char</span>::<span class="n">is_uppercase</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="fm">assert!</span><span class="p">(</span><span class="o">!</span><span class="n">id</span><span class="p">.</span><span class="n">chars</span><span class="p">().</span><span class="n">all</span><span class="p">(</span><span class="kt">char</span>::<span class="n">is_uppercase</span><span class="p">));</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>只有当需要的时候这两个方法才会继续消耗item。例如，如果已经有一个item让闭包返回<code>true</code>，那么<code>any</code>会立刻返回<code>true</code>，不会再继续消耗剩余的item。</p>
<h3 id="position-rposition-exactsizeiterator"><code>position, rposition, ExactSizeIterator</code></h3>
<p><code>position</code>方法应用到迭代器的每一个item上，返回第一个使闭包返回<code>true</code>的item的索引。更确切地说，它返回一个索引的<code>Option</code>：如果没有item使闭包返回<code>true</code>，<code>position</code>会返回<code>None</code>。只要闭包有一次返回<code>true</code>它就会立刻停止。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">text</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;Xerxes&#34;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">text</span><span class="p">.</span><span class="n">chars</span><span class="p">().</span><span class="n">position</span><span class="p">(</span><span class="o">|</span><span class="n">c</span><span class="o">|</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;e&#39;</span><span class="p">),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">text</span><span class="p">.</span><span class="n">chars</span><span class="p">().</span><span class="n">position</span><span class="p">(</span><span class="o">|</span><span class="n">c</span><span class="o">|</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;z&#39;</span><span class="p">),</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>rposition</code>方法功能相同，不过它是从最后一个元素往前开始搜索。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">bytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">b&#34;Xerxes&#34;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">bytes</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">rposition</span><span class="p">(</span><span class="o">|&amp;</span><span class="n">c</span><span class="o">|</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">b&#39;e&#39;</span><span class="p">),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">bytes</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">rposition</span><span class="p">(</span><span class="o">|&amp;</span><span class="n">c</span><span class="o">|</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">b&#39;X&#39;</span><span class="p">),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>rposition</code>方法要求一个可逆迭代器这样它才可以从最后往前遍历。它还要求一个exact-size迭代器这样它才可以返回一个和<code>position</code>一样的索引，即从前往后数情况下的索引。exact-size迭代器是一个实现了<code>std::iter::ExactSizeIterator</code> trait的迭代器：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">trait</span><span class="w"> </span><span class="nb">ExactSizeIterator</span>: <span class="nb">Iterator</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span> <span class="p">{</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">is_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>len</code>方法返回剩余item的数量，当迭代结束时<code>is_empty</code>方法返回<code>true</code>。</p>
<p>当然，不是每一个迭代器都知道它还会产生多少个item。例如，之前使用的<code>str::chars</code>迭代器就做不到（因为UTF-8是可变宽度的编码），因此你不能对字符串使用<code>rposition</code>。但一个迭代字节数组的迭代器当然知道数组的长度，因此它可以实现<code>ExactSizeIterator</code>。</p>
<h3 id="fold和rfold"><code>fold</code>和<code>rfold</code></h3>
<p>在进行某种需要累计所有item的计算时<code>fold</code>方法是非常通用的工具。给定一个初始值（我们称之为 <em>累加器(accumulator)</em> ）和一个闭包，<code>fold</code>会重复对当前的累加器和下一个item应用这个闭包。闭包返回的值被用作新的累加器，然后和下一个item一起传递给闭包。最终累加器的值就是<code>fold</code>自身的返回值。如果序列为空，<code>fold</code>直接返回初始的累加器。</p>
<p>很多其他消耗迭代器的方法都可以用<code>fold</code>来实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">];</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">fold</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span><span class="w">        </span><span class="c1">// count
</span><span class="c1"></span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">fold</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="o">|</span><span class="w"> </span><span class="n">n</span><span class="o">+</span><span class="n">i</span><span class="p">),</span><span class="w"> </span><span class="mi">45</span><span class="p">);</span><span class="w">       </span><span class="c1">// sum
</span><span class="c1"></span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">fold</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="o">|</span><span class="w"> </span><span class="n">n</span><span class="o">*</span><span class="n">i</span><span class="p">),</span><span class="w"> </span><span class="mi">151200</span><span class="p">);</span><span class="w">   </span><span class="c1">// product
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="c1">// max
</span><span class="c1"></span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">cloned</span><span class="p">().</span><span class="n">fold</span><span class="p">(</span><span class="kt">i32</span>::<span class="n">min_value</span><span class="p">(),</span><span class="w"> </span><span class="n">std</span>::<span class="n">cmp</span>::<span class="n">max</span><span class="p">),</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>fold</code>方法的签名如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">fold</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">init</span>: <span class="nc">A</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">A</span><span class="w">
</span><span class="w">        </span><span class="k">where</span><span class="w"> </span><span class="bp">Self</span>: <span class="nb">Sized</span><span class="p">,</span><span class="w"> </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">A</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>其中，<code>A</code>是累加器的类型。<code>init</code>参数就是一个<code>A</code>类型的值，<code>A</code>也是闭包的第一个参数和返回值的类型，也是<code>fold</code>本身的返回值的类型。</p>
<p>注意累加器值被移动进和移出闭包，因此你可以用非<code>Copy</code>的累加器类型调用<code>fold</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s">&#34;Pack&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;my&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;box&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;with&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">             </span><span class="s">&#34;five&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;dozen&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;liquor&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;jugs&#34;</span><span class="p">];</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="c1">// See also：切片的`join`方法，最后不会有多余的空格。
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">pangram</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">fold</span><span class="p">(</span><span class="nb">String</span>::<span class="n">new</span><span class="p">(),</span><span class="w"> </span><span class="o">|</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="o">|</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34; &#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pangram</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Pack my box with five dozen liquor jugs&#34;</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>rfold</code>方法和<code>fold</code>方法相同，除了它需要双端迭代器，并且从最后开始往前处理item：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">weird_pangram</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">rfold</span><span class="p">(</span><span class="nb">String</span>::<span class="n">new</span><span class="p">(),</span><span class="w"> </span><span class="o">|</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="o">|</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34; &#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">weird_pangram</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;jugs liquor dozen five with box my Pack &#34;</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="try_fold和try_rfold"><code>try_fold</code>和<code>try_rfold</code></h3>
<p><code>try_fold</code>方法和<code>fold</code>基本一样，除了它的迭代过程可以提前退出，不需要消耗迭代器里的所有值。传递给<code>try_fold</code>的闭包需要返回一个<code>Result</code>：如果它是<code>Err(e)</code>，<code>try_fold</code>会立刻返回<code>Err(e)</code>作为返回值。否则，它会继续处理成功的值。闭包也可以返回一个<code>Option</code>：返回<code>None</code>会提前退出，最后的返回值是个<code>Option</code>。</p>
<p>这里有一个求来自标准输入的数字之和的程序：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">error</span>::<span class="n">Error</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">predule</span>::<span class="o">*</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="kt">str</span>::<span class="n">FromStr</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">stdin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">stdin</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stdin</span><span class="p">.</span><span class="n">lock</span><span class="p">()</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">lines</span><span class="p">()</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">try_fold</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">sum</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="o">|</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">u64</span><span class="p">,</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="nb">Ok</span><span class="p">(</span><span class="n">sum</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kt">u64</span>::<span class="n">from_str</span><span class="p">(</span><span class="o">&amp;</span><span class="n">line</span><span class="o">?</span><span class="p">.</span><span class="n">trim</span><span class="p">())</span><span class="o">?</span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">})</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">sum</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>输入流的<code>lines</code>迭代器产生<code>Result&lt;String, std::io::Error&gt;</code>类型的item，把<code>String</code>解析为整数也可能会失败。这里使用<code>try_fold</code>需要闭包返回<code>Result&lt;u64, ...&gt;</code>，所以我们可以使用<code>?</code>运算符来把闭包里的错误传播到<code>main</code>函数中。</p>
<p>因为<code>try_fold</code>如此灵活，它常被用于实现<code>Iterator</code>的很多其他消耗方法。例如，这里有一个<code>all</code>的实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">all</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">predicate</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
        <span class="nc">where</span><span class="w"> </span><span class="n">P</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="bp">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">,</span><span class="w">
</span><span class="w">              </span><span class="bp">Self</span>: <span class="nb">Sized</span>
    <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">try_fold</span><span class="p">((),</span><span class="w"> </span><span class="o">|</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">item</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">predicate</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">Some</span><span class="p">(())</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">None</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}).</span><span class="n">is_some</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>注意这个实现不能使用普通的<code>fold</code>：<code>all</code>保证只要有一个item使<code>predicate</code>返回false就会停止消耗item，但<code>fold</code>总是消耗整个迭代器。</p>
<p>如果你正在实现自己的迭代器类型，那么思考一下你的迭代器是否能比<code>Iterator</code> trait的默认实现更高效地实现<code>try_fold</code>方法是值得的。如果你可以加速<code>try_fold</code>，所有其他基于它的方法都会获益。</p>
<p><code>try_rfold</code>方法，就如它的名字所示，和<code>try_fold</code>一样，除了它从最后开始往前处理item，并因此需要一个双端迭代器。</p>
<h3 id="nth-nth_back"><code>nth, nth_back</code></h3>
<p><code>nth</code>方法接受一个索引<code>n</code>，跳过迭代器中接下来<code>n</code>个item，然后返回下一个item，或者如果迭代器已经在这个过程中到达终点就返回<code>None</code>。调用<code>.nth(0)</code>等价于调用<code>.next()</code>。</p>
<p>它不会像很多适配器一样获取迭代器的所有权，所以你可以调用它很多次：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">squares</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">10</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">i</span><span class="o">|</span><span class="w"> </span><span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">squares</span><span class="p">.</span><span class="n">nth</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">16</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">squares</span><span class="p">.</span><span class="n">nth</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">25</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">squares</span><span class="p">.</span><span class="n">nth</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>它的签名如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">nth</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">n</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w">
</span><span class="w">        </span><span class="k">where</span><span class="w"> </span><span class="bp">Self</span>: <span class="nb">Sized</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>nth_back</code>方法类似，除了它是从双端迭代器的尾部往前移动。调用<code>.nth_back(0)</code>等价于调用<code>.next_back()</code>：它返回最后一个item，或者如果迭代器已经为空时返回<code>None</code>。</p>
<h3 id="last"><code>last</code></h3>
<p><code>last</code>方法返回迭代器产生的最后一个item，或者如果迭代器为空时返回<code>None</code>。它的签名如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">last</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">squares</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">10</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">i</span><span class="o">|</span><span class="w"> </span><span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">squares</span><span class="p">.</span><span class="n">last</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">81</span><span class="p">));</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>它会消耗迭代器的所有item，即使迭代器可逆。如果你有一个可逆迭代器并且不想让它消耗所有item，那你应该调用<code>iter.next_back()</code>。</p>
<h3 id="find-rfind-find_map"><code>find, rfind, find_map</code></h3>
<p><code>find</code>方法从迭代器查找item，返回第一个使给定闭包返回<code>true</code>的item，或者如果没有任何item满足条件就返回<code>None</code>。它的签名是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">find</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">predicate</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w">
</span><span class="w">        </span><span class="k">where</span><span class="w"> </span><span class="bp">Self</span>: <span class="nb">Sized</span><span class="p">,</span><span class="w">
</span><span class="w">              </span><span class="n">P</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>rfind</code>方法类似，不过它需要双端迭代器并且从最后往前搜索，返回 <em>最后一个</em> 使闭包返回<code>true</code>的item。</p>
<p>例如，使用“<code>max_by, min_by</code>”中的城市和人口的表，你可以写：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">populations</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">find</span><span class="p">(</span><span class="o">|&amp;</span><span class="p">(</span><span class="n">_name</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pop</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="n">pop</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1_000_000</span><span class="p">),</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">populations</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">find</span><span class="p">(</span><span class="o">|&amp;</span><span class="p">(</span><span class="n">_name</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pop</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="n">pop</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">500_000</span><span class="p">),</span><span class="w"> </span><span class="nb">Some</span><span class="p">((</span><span class="o">&amp;</span><span class="s">&#34;Portland&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="mi">583_776</span><span class="p">)));</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>表中没有人口超过一百万的城市，但有超过50万的城市。</p>
<p>有时你的闭包并不是一个简单的对item进行布尔判断的判别式：它可能会更加复杂，并且返回一个它自己产生的有趣的值。在这种情况下，<code>find_map</code>正是你需要的。它的签名是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">find_map</span><span class="o">&lt;</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="bp">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这类似于<code>find</code>，区别在于它接受的闭包不是返回<code>bool</code>，而是返回一个<code>Option</code>。<code>find_map</code>返回第一个是<code>Some</code>的<code>Option</code>。</p>
<p>例如，如果我们有一个每个城市的公园的数据库，我们可能想看看其中是否有火山，并且如果有的话返回公园的名字：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">big_city_with_volcano_park</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">populations</span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">find_map</span><span class="p">(</span><span class="o">|</span><span class="p">(</span><span class="o">&amp;</span><span class="n">city</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">park</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find_volcano_park</span><span class="p">(</span><span class="n">city</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">parks</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="c1">// find_map返回这个值，
</span><span class="c1"></span><span class="w">                </span><span class="c1">// 因此我们的调用者会知道我们找到了 *哪个* 公园
</span><span class="c1"></span><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nb">Some</span><span class="p">((</span><span class="n">city</span><span class="p">,</span><span class="w"> </span><span class="n">park</span><span class="p">.</span><span class="n">name</span><span class="p">));</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">            </span><span class="c1">// 继续搜索
</span><span class="c1"></span><span class="w">            </span><span class="nb">None</span><span class="w">
</span><span class="w">        </span><span class="p">});</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">big_city_with_volcano_park</span><span class="p">,</span><span class="w">
</span><span class="w">               </span><span class="nb">Some</span><span class="p">((</span><span class="s">&#34;Portland&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Mt. Tabor Park&#34;</span><span class="p">)));</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="构建集合collect和fromiterator">构建集合：<code>collect</code>和<code>FromIterator</code></h3>
<p>在这本书中，我们曾多次看见使用<code>collect</code>方法来构建vector。例如，在”第2章”中，我们调用了<code>std::env::args()</code>来获取一个程序命令行参数的迭代器，然后调用了迭代器的<code>collect</code>方法来把它们收集到一个vector中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">args</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">env</span>::<span class="n">args</span><span class="p">().</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>但<code>collect</code>并不是只能用于vector：事实上，它可以用于构建Rust标准库中的任意集合，只要迭代器产生合适的item类型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">collections</span>::<span class="p">{</span><span class="n">HashSet</span><span class="p">,</span><span class="w"> </span><span class="n">BTreeSet</span><span class="p">,</span><span class="w"> </span><span class="n">LinkedList</span><span class="p">,</span><span class="w"> </span><span class="n">HashMap</span><span class="p">,</span><span class="w"> </span><span class="n">BTreeMap</span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">args</span>: <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">env</span>::<span class="n">args</span><span class="p">().</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">args</span>: <span class="nc">BTreeSet</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">env</span>::<span class="n">args</span><span class="p">().</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">args</span>: <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">env</span>::<span class="n">args</span><span class="p">().</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// 收集map需要(key, value)对，因此在这个例子中，
</span><span class="c1"></span><span class="w">    </span><span class="c1">// 使用zip将字符串序列和整数序列绑定。
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">args</span>: <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">env</span>::<span class="n">args</span><span class="p">().</span><span class="n">zip</span><span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">args</span>: <span class="nc">BTreeMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">env</span>::<span class="n">args</span><span class="p">().</span><span class="n">zip</span><span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// 等等
</span></code></pre></td></tr></table>
</div>
</div><p>当然，<code>collect</code>方法本身并不知道如何构建这些类型。当一些集合类型例如<code>Vec</code>或者<code>HashMap</code>知道如何从一个迭代器构建自身时，它会实现<code>std::iter::FromIterator</code> trait，<code>collect</code>只是它的便捷用法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">trait</span><span class="w"> </span><span class="n">FromIterator</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span>: <span class="nb">Sized</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">from_iter</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">IntoIterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">=</span><span class="n">A</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">iter</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>如果一个集合类型实现了<code>FromIterator&lt;A&gt;</code>，那么它的类型关联函数<code>from_iter</code>可以从一个产生<code>A</code>类型值的迭代器构建一个自身类型的集合。</p>
<p>在最简单的情况下，这个trait的实现可以只简单地构建一个空集合，然后把迭代器产生的item一个个添加进去。例如，<code>std::collections::LinkedList</code>的<code>FromIterator</code>实现就是按这种方式工作。</p>
<p>然而，一些方式可以有更好的实现。例如，从一个迭代器<code>iter</code>构造一个vector可以非常简单地实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">vec</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">item</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="n">vec</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>但这并不是个好主意：随着vector的增长：它可能需要扩展缓冲区，需要调用堆分配器，还要拷贝现有元素。vector确实通过算法措施来保证这个开销很低，但如果有更简单的方式直接在最开始就分配一个正确大小的缓冲区，那么就完全没必要再次调整大小。</p>
<p>这就是迭代器的<code>Iterator</code> trait的<code>size_hint</code>方法出现的原因：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">trait</span><span class="w"> </span><span class="nb">Iterator</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">size_hint</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">(</span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这个方法返回迭代器可以产生的item数量的下界和一个可选的上界。默认的实现返回0作为下界，并拒绝指定上界，实际上就是在说“我不知道”，但很多迭代器可以做得更好。例如<code>Range</code>的迭代器就精确地知道它将产生多少个item，<code>Vec</code>和<code>HashMap</code>的迭代器也一样。这样的迭代器会提供自己的<code>size_hint</code>的特化定义。</p>
<p>这两个界限正是<code>Vec</code>的<code>FromIterator</code>的实现所需要知道的信息，这样它就能从一开始就分配正确大小的缓冲区。插入新元素仍然会检查缓冲区是否足够大，因此即使提示不正确，也只会影响性能，而不会影响安全性。其他类型也可以选择类似的策略：例如，<code>HashSet</code>和<code>HashMap</code>也实现了<code>Iterator::size_hint</code>来为哈希表选择合适的初始大小。</p>
<p>有关于类型推导的一个提示：在本节的开始处，同样的调用<code>std::env::args().collect()</code>根据上下文会产生四种不同类型的集合，这看起来可能有些奇怪。<code>collect</code>的返回值类型是它的类型参数，因此前两个调用等价于下面的调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">env</span>::<span class="n">args</span><span class="p">().</span><span class="n">collect</span>::<span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;&gt;</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">env</span>::<span class="n">args</span><span class="p">().</span><span class="n">collect</span>::<span class="o">&lt;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;&gt;</span><span class="p">();</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>但如果<code>collect</code>的类型参数只有唯一一种可能，那么Rust会自动为你填充它。当你写出<code>args</code>的类型时，就是确保了这种情况。</p>
<h3 id="extend-trait"><code>Extend</code> trait</h3>
<p>如果一个类型实现了<code>std::iter::Extend</code> trait，那么它的<code>extend</code>方法可以把一个可迭代对象的item添加到集合中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">v</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">5</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">i</span><span class="o">|</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">extend</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="mi">31</span><span class="p">,</span><span class="w"> </span><span class="mi">57</span><span class="p">,</span><span class="w"> </span><span class="mi">99</span><span class="p">,</span><span class="w"> </span><span class="mi">163</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">31</span><span class="p">,</span><span class="w"> </span><span class="mi">57</span><span class="p">,</span><span class="w"> </span><span class="mi">99</span><span class="p">,</span><span class="w"> </span><span class="mi">163</span><span class="p">]);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>所有的标准集合都实现了<code>Extend</code>，因此它们都有这个方法，就算是<code>String</code>也有。而数组和切片这种长度固定的集合没有这个方法。</p>
<p>这个trait的定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">trait</span><span class="w"> </span><span class="nb">Extend</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">extend</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">iter</span>: <span class="nc">T</span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="k">where</span><span class="w"> </span><span class="n">T</span>: <span class="nb">IntoIterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">=</span><span class="n">A</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>显然，这和<code>std::iter::FromIterator</code>非常相似：不过后者创建一个新集合，而<code>Extend</code>扩展一个已有集合。事实上，标准库中好几个类型的<code>FromIterator</code>实现都是简单地创建一个新的空集合，然后调用<code>extend</code>来填充它。例如，<code>std::collections::LinkedList</code>的<code>FromIterator</code>就是以这种方式工作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">FromIterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">from_iter</span><span class="o">&lt;</span><span class="n">I</span>: <span class="nc">IntoIter</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">iter</span>: <span class="nc">I</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="n">list</span><span class="p">.</span><span class="n">extend</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span><span class="w">
</span><span class="w">            </span><span class="n">list</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="partition"><code>partition</code></h3>
<p><code>partition</code>方法将一个迭代器的item分成两个集合，使用一个闭包来决定每个item属于哪个集合：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">things</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s">&#34;doorknob&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;mushroom&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;noodle&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;giraffe&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;grapefruit&#34;</span><span class="p">];</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// 一个令人震惊的事实：活物的名字都以奇数字母开头。
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">living</span><span class="p">,</span><span class="w"> </span><span class="n">nonliving</span><span class="p">)</span>: <span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="kt">str</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="kt">str</span><span class="o">&gt;</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">things</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">partition</span><span class="p">(</span><span class="o">|</span><span class="n">name</span><span class="o">|</span><span class="w"> </span><span class="n">name</span><span class="p">.</span><span class="n">as_bytes</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">living</span><span class="p">,</span><span class="w">    </span><span class="fm">vec!</span><span class="p">[</span><span class="s">&#34;mushroom&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;giraffe&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;grapefruit&#34;</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">nonliving</span><span class="p">,</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="s">&#34;doorknob&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;noodle&#34;</span><span class="p">]);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>类似于<code>collect</code>，<code>partition</code>也可以创建任意类型的集合，不过两个集合的类型必须相同。类似于<code>collect</code>，你必须指明返回类型：上面的例子中写出了<code>living</code>和<code>nonliving</code>的类型并让类型推导选择合适的类型参数来调用<code>partition</code>。</p>
<p><code>partition</code>的签名如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">partition</span><span class="o">&lt;</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="k">where</span><span class="w"> </span><span class="bp">Self</span>: <span class="nb">Sized</span><span class="p">,</span><span class="w">
</span><span class="w">              </span><span class="n">B</span>: <span class="nb">Default</span> <span class="o">+</span><span class="w"> </span><span class="nb">Extend</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">              </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>collect</code>要求返回类型实现了<code>FromIterator</code>，而<code>partition</code>要求<code>std::default::Default</code>（所有的Rust集合都实现了它来返回一个空集合）和<code>std::default::Extend</code>。</p>
<p>其他语言提供把一个迭代器分成两个迭代器的<code>partition</code>操作，而不是构建两个集合。但这并不适合Rust：如果要实现分成两个迭代器，那么那些由底层迭代器产生但还未被分类后的迭代器产生的item必须被缓存；无论如何，最终都需要在内部构建某种类型的集合。</p>
<h3 id="for_each和try_for_each"><code>for_each</code>和<code>try_for_each</code></h3>
<p><code>for_each</code>方法简单地对每一个item应用一个闭包：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="p">[</span><span class="s">&#34;doves&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;hens&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;birds&#34;</span><span class="p">].</span><span class="n">iter</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">zip</span><span class="p">([</span><span class="s">&#34;turtle&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;french&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;calling&#34;</span><span class="p">].</span><span class="n">iter</span><span class="p">())</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">zip</span><span class="p">(</span><span class="mi">2</span><span class="o">..</span><span class="mi">5</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">rev</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="p">((</span><span class="n">item</span><span class="p">,</span><span class="w"> </span><span class="n">kind</span><span class="p">),</span><span class="w"> </span><span class="n">quantity</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="fm">format!</span><span class="p">(</span><span class="s">&#34;{} {} {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">quantity</span><span class="p">,</span><span class="w"> </span><span class="n">kind</span><span class="p">,</span><span class="w"> </span><span class="n">item</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">})</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">for_each</span><span class="p">(</span><span class="o">|</span><span class="n">gift</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;You have received: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">gift</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">});</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这会打印出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">    You have received: 4 calling birds
    You have received: 3 french hens
    You have received: 2 turtle doves
</code></pre></td></tr></table>
</div>
</div><p>它非常类似于一个简单的<code>for</code>循环，在循环中你还可以使用<code>break</code>和<code>countinue</code>控制语句。但使用<code>for</code>循环处理这种很长的链式适配器调用会有一点尴尬：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">gift</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">[</span><span class="s">&#34;doves&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;hens&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;birds&#34;</span><span class="p">].</span><span class="n">iter</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">zip</span><span class="p">([</span><span class="s">&#34;turtle&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;french&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;calling&#34;</span><span class="p">].</span><span class="n">iter</span><span class="p">())</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">zip</span><span class="p">(</span><span class="mi">2</span><span class="o">..</span><span class="mi">5</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">rev</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="p">((</span><span class="n">item</span><span class="p">,</span><span class="w"> </span><span class="n">kind</span><span class="p">),</span><span class="w"> </span><span class="n">quantity</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="fm">format!</span><span class="p">(</span><span class="s">&#34;{} {} {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">quantity</span><span class="p">,</span><span class="w"> </span><span class="n">kind</span><span class="p">,</span><span class="w"> </span><span class="n">item</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">})</span><span class="w">
</span><span class="w">    </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;You have received: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">gift</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>用于绑定的模式<code>gift</code>最终可能会距离使用它的循环体非常远。</p>
<p>如果你的闭包需要容错或者提前退出，你可以使用<code>try_for_each</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">try_for_each</span><span class="p">(</span><span class="o">|</span><span class="n">gift</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="fm">writeln!</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">output_file</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;You have received: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">gift</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">})</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h2 id="实现自己的迭代器">实现自己的迭代器</h2>
<p>你可以为自己的类型实现<code>IntoIterator</code>和<code>Iterator</code> trait，这样本章之前展示过的所有适配器和消耗器，还有其他可以和标准库迭代器接口协同工作的库和crate都可以使用。在本节中，我们将展示一个简单的范围类型的迭代器，然后展示一个更复杂的二叉树类型的迭代器。</p>
<p>假设我们有下面的范围类型（标准库的<code>std::ops::Range&lt;T&gt;</code>类型的简化）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">struct</span> <span class="nc">I32Range</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">start</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">end</span>: <span class="kt">i32</span>
    <span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>迭代一个<code>I32Range</code>需要两个状态：当前的值和终点值。<code>I32Range</code>类型本身非常适合存储这两个状态：使用<code>start</code>作为下一个值，<code>end</code>作为终点。因此你可以这么实现<code>Iterator</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="nb">Iterator</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">I32Range</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">type</span> <span class="nc">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i32</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">start</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">end</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">start</span><span class="p">);</span><span class="w">
</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">start</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="n">result</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这个迭代器产生<code>i32</code> item，所以<code>i32</code>就是<code>Item</code>类型。如果迭代已经结束，<code>next</code>应该返回<code>None</code>；否则，它产生下一个值并更新当前的状态准备好下一次调用。</p>
<p>当然，<code>for</code>循环会使用<code>IntoIterator::into_iter</code>来把操作数转换成迭代器。但标准库为每一个实现<code>Iterator</code>的类型自动提供了<code>IntoIterator</code>实现，因此<code>I32Range</code>已经可以使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">pi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">numerator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">(</span><span class="n">I32Range</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">start</span>: <span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">end</span>: <span class="mi">14</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">pi</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">numerator</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">f64</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="n">numerator</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="o">-</span><span class="mf">3.0</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="n">pi</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="kt">f64</span>::<span class="n">sqrt</span><span class="p">(</span><span class="mf">12.0</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// IEEE 754标准指定了精确的结果。
</span><span class="c1"></span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">pi</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">f32</span><span class="p">,</span><span class="w"> </span><span class="n">std</span>::<span class="kt">f32</span>::<span class="n">consts</span>::<span class="n">PI</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>但<code>I32Range</code>是一种特殊情况，它的可迭代对象和迭代器恰好是同一种类型。很多情况并不是这么简单。例如，这里有一个”第10章”的二叉树类型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">enum</span> <span class="nc">BinaryTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Empty</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">NonEmpty</span><span class="p">(</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">struct</span> <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">element</span>: <span class="nc">T</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">left</span>: <span class="nc">BinaryTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">right</span>: <span class="nc">BinaryTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>经典的遍历二叉树的方法是递归，使用函数调用栈来追踪在树中的位置和已经访问过的节点。但当为<code>BinaryTree&lt;T&gt;</code>实现<code>Iterator</code>时，每一次<code>next</code>调用都必须产生一个值并且返回。为了追踪要产生的树节点，迭代器必须保持自己的栈。这里有一个<code>BinaryTree</code>的可能的迭代器类型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="bp">self</span>::<span class="n">BinaryTree</span>::<span class="o">*</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// 中序遍历`BinaryTree`时的状态
</span><span class="c1"></span><span class="w">    </span><span class="k">struct</span> <span class="nc">TreeIter</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// 一个树节点的引用的栈。因为我们要使用`Vec`的
</span><span class="c1"></span><span class="w">        </span><span class="c1">// `push`和`pop`方法，栈的顶部是vector的尾部。
</span><span class="c1"></span><span class="w">        </span><span class="c1">//
</span><span class="c1"></span><span class="w">        </span><span class="c1">// 迭代器下一个要访问的节点在栈顶，
</span><span class="c1"></span><span class="w">        </span><span class="c1">// 那些还没访问的祖先节点在它下面。如果栈为空，
</span><span class="c1"></span><span class="w">        </span><span class="c1">// 就代表迭代结束了。
</span><span class="c1"></span><span class="w">        </span><span class="n">unvisited</span>: <span class="nb">Vec</span><span class="o">&lt;&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>当我们创建一个新的<code>TreeIter</code>时，它的初始状态应该是即将产生树中最左边的节点。根据<code>unvisited</code>栈的规则，它的栈顶应该是那个叶节点，再往下就是它的祖先节点：树中左侧边缘上的节点。我们可以从根节点访问左侧边缘一直到叶节点，把遇到的所有节点都入栈，来初始化<code>unvisited</code>，因此我们为<code>TreeIter</code>定义一个方法来实现这个过程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">impl</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span>: <span class="o">&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="n">TreeIter</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">push_left_edge</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">tree</span>: <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="nc">BinaryTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">while</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="n">NonEmpty</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">node</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">tree</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">unvisited</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="p">);</span><span class="w">
</span><span class="w">                </span><span class="n">tree</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>用<code>mut tree</code>可以让循环在遍历左侧边缘的过程中改变<code>tree</code>指向的节点，但因为<code>tree</code>是一个共享引用，所以它不能改变那些节点本身。</p>
<p>有了这个辅助方法，我们可以给<code>BinaryTree</code>一个<code>iter</code>方法来返回一个迭代树的迭代器：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">BinaryTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">iter</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">TreeIter</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TreeIter</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">unvisited</span>: <span class="nb">Vec</span>::<span class="n">new</span><span class="p">()</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">            </span><span class="n">iter</span><span class="p">.</span><span class="n">push_left_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">);</span><span class="w">
</span><span class="w">            </span><span class="n">iter</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>iter</code>方法先构造了一个<code>unvisited</code>栈为空的<code>TreeIter</code>，然后调用<code>push_left_edge</code>来初始化它。按照<code>unvisited</code>栈的规则，最左侧的节点在栈顶。</p>
<p>遵循标准库的实践，我们可以为二叉树的引用实现<code>IntoIterator</code>，然后在里面调用<code>BinaryTree::iter</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">impl</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span>: <span class="o">&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="n">BinaryTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">type</span> <span class="nc">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="k">type</span> <span class="nc">IntoIter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TreeIter</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">into_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">IntoIter</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>IntoIter</code>定义将<code>TreeIter</code>设置为<code>&amp;BinaryTree</code>的迭代器类型。</p>
<p>最后，在<code>Iterator</code>的实现中，我们需要实际遍历这棵树。类似于<code>BinaryTree</code>的<code>iter</code>方法，迭代器的<code>next</code>方法也需要遵守栈的规则：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">impl</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Iterator</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">TreeIter</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">type</span> <span class="nc">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="c1">// 找到这一次迭代要产生的节点，
</span><span class="c1"></span><span class="w">            </span><span class="c1">// 或者结束迭代。（如果结果是`None`就通过
</span><span class="c1"></span><span class="w">            </span><span class="c1">// `?`运算符立即返回。）
</span><span class="c1"></span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">unvisited</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">            </span><span class="c1">// 在`node`之后，下一个产生的应该是`node`的右子树
</span><span class="c1"></span><span class="w">            </span><span class="c1">// 中的最左侧的节点，因此添加这条线上的节点。我们的辅助函数
</span><span class="c1"></span><span class="w">            </span><span class="c1">// 恰好就是我们需要的。
</span><span class="c1"></span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">push_left_edge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">            </span><span class="c1">// 产生这个节点的值的引用。
</span><span class="c1"></span><span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="p">.</span><span class="n">element</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>如果栈为空，就表明迭代结束了。否则，<code>node</code>是现在要访问的节点的引用，这次调用会返回一个它的<code>element</code>字段的引用。但首先，我们必须把迭代器的状态更新到下一个节点。如果这个节点有一个右子树，那么下一个要访问的就是这棵子树中最左侧的节点，我们可以调用<code>push_left_edge</code>来添加它和它的未访问的祖先节点到栈里。但如果这个节点没有右子树，那么<code>push_left_edge</code>没有效果，这正是我们想要的：这时新的栈顶就是<code>node</code>的第一个未被访问的祖先节点。</p>
<p>有了<code>IntoIterator</code>和<code>Iterator</code>实现，我们最终可以使用一个<code>for</code>循环来迭代<code>BinaryTree</code>的引用。这里用到了“填充二叉树”中<code>BinaryTree</code>的<code>add</code>方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="c1">// 建造一棵小树。
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">tree</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BinaryTree</span>::<span class="n">Empty</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">tree</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="s">&#34;Jaeger&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">tree</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="s">&#34;robot&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">tree</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="s">&#34;droid&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">tree</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="s">&#34;mecha&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// 迭代它。
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">kind</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tree</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">v</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="o">*</span><span class="n">kind</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="s">&#34;droid&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Jaeger&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;mecha&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;robot&#34;</span><span class="p">]);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>”图15-1”展示了当我们遍历这棵树的过程中<code>unvisited</code>栈的行为。在每一次迭代中，下一个要被访问的节点都是栈顶，所有还未访问过的祖先节点都在它之下。</p>
<p><figure>
  <picture>

    
      
        
        
        
        
        
        
    <img
      loading="lazy"
      decoding="async"
      alt="迭代二叉树"
      
        class="image_figure image_internal image_unprocessed"
        src="../img/f15-1.png"
      
      
    />

    </picture>
</figure>
</p>
<p align="center">图15-1 迭代二叉树</p>
<p>所有常用的迭代器适配器和消耗器都已经准备好在我们的树上使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">tree</span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w">
</span><span class="w">               </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">name</span><span class="o">|</span><span class="w"> </span><span class="fm">format!</span><span class="p">(</span><span class="s">&#34;mega-{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">))</span><span class="w">
</span><span class="w">               </span><span class="p">.</span><span class="n">collect</span>::<span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">(),</span><span class="w">
</span><span class="w">               </span><span class="fm">vec!</span><span class="p">[</span><span class="s">&#34;mega-droid&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;mega-jaeger&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">                    </span><span class="s">&#34;mega-mecha&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;mega-robot&#34;</span><span class="p">]);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>迭代器是Rust哲学的体现，即提供强大的、零成本、能提高代码的表现力和可读性的抽象。迭代器并不能完全替代循环，但它们提供了一种功能强大的原语，同时具有内建的惰性求值和高性能的特点。</p>
<div class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn:1" role="doc-endnote">
<p>事实上，因为<code>Option</code>也是一个可迭代对象，行为就像一个有0个或者1个item的序列。所以假设<code>closure</code>返回一个<code>Option&lt;T&gt;</code>，那么<code>iterator.filter_map(closure)</code>等价于<code>iterator.flat_map(closure)</code>。&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

    </div>
<div class="post_comments">
  
  
  
</div>




    <hr>

<div id="gitalk-container"></div>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js" crossorigin="anonymous"></script>
    <script type="text/javascript">
      var gitalk = new Gitalk({
        id: '0001-01-01 00:00:00 \u002b0000 UTC',
        title: '',
        clientID: '72786bf87c19beec6abe',
        clientSecret: '93ce647699b49ea6434332d36b0122a4ad8281ad',
        repo: 'buf1024.github.io',
        owner: 'buf1024',
        admin: ['buf1024'],
        body: decodeURI(location.href)
      });
      gitalk.render('gitalk-container');
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/gitalk/gitalk">comments powered by gitalk.</a></noscript>

  </article>
<aside class="sidebar">
  <section class="sidebar_inner">
    <br>
    


    
    
    <h2 class="mt-4">最新文章</h2>
    <ul class="flex-column">
      <li>
        <a href="https://luoguochun.cn/post/2024-01-13-rust-sqlx-sqlbuilder/" class="nav-link" title="Rust sqlx SQLBuilder">Rust sqlx SQLBuilder</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2024-01-08-vite-engineering-config/" class="nav-link" title="前端工程化配置保姆级教程">前端工程化配置保姆级教程</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-12-26-rust-proc-macro/" class="nav-link" title="rust 过程宏">rust 过程宏</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-09-21-rust-panic/" class="nav-link" title="一行代码让 rustc panic">一行代码让 rustc panic</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-07-19-flutter-muti-window/" class="nav-link" title="Flutter 桌面端多窗口支持">Flutter 桌面端多窗口支持</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-07-04-hiqradio/" class="nav-link" title="hiqradio 一个简单的收音机软件">hiqradio 一个简单的收音机软件</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-03-21-android-https/" class="nav-link" title="android https 抓包">android https 抓包</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-03-16-love-for-insterest/" class="nav-link" title="为爱发电终是不能长久的……">为爱发电终是不能长久的……</a>
      </li>
    </ul>
    <div>
      <h2 class="mt-4 taxonomy" id="categories-section">分类</h2>
      <nav class="tags_nav">
        <a href='https://luoguochun.cn/categories/misc/' class="post_tag button button_translucent" title="misc">
          MISC
          <span class="button_tally">11</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/linux/' class="post_tag button button_translucent" title="linux">
          LINUX
          <span class="button_tally">8</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/tcp/' class="post_tag button button_translucent" title="tcp">
          TCP
          <span class="button_tally">8</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/c/' class="post_tag button button_translucent" title="c">
          C
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/flutter/' class="post_tag button button_translucent" title="flutter">
          FLUTTER
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/rust/' class="post_tag button button_translucent" title="rust">
          RUST
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/python/' class="post_tag button button_translucent" title="python">
          PYTHON
          <span class="button_tally">6</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/c&#43;&#43;/' class="post_tag button button_translucent" title="c&#43;&#43;">
          C&#43;&#43;
          <span class="button_tally">4</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/web/' class="post_tag button button_translucent" title="web">
          WEB
          <span class="button_tally">4</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/gcc/' class="post_tag button button_translucent" title="gcc">
          GCC
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/git/' class="post_tag button button_translucent" title="git">
          GIT
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/reactjs/' class="post_tag button button_translucent" title="reactjs">
          REACTJS
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/unittest/' class="post_tag button button_translucent" title="unittest">
          UNITTEST
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/vim/' class="post_tag button button_translucent" title="vim">
          VIM
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/%E6%9E%84%E6%9E%B6/' class="post_tag button button_translucent" title="构架">
          构架
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/asm/' class="post_tag button button_translucent" title="asm">
          ASM
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/docker/' class="post_tag button button_translucent" title="docker">
          DOCKER
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/go/' class="post_tag button button_translucent" title="go">
          GO
          <span class="button_tally">1</span>
        </a>
        
        
      </nav>
    </div>
    <div>
      <h2 class="mt-4 taxonomy" id="tags-section">标签</h2>
      <nav class="tags_nav">
        <a href='https://luoguochun.cn/tags/c/' class="post_tag button button_translucent" title="c">
          C
          <span class="button_tally">21</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/linux/' class="post_tag button button_translucent" title="linux">
          LINUX
          <span class="button_tally">16</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/c&#43;&#43;/' class="post_tag button button_translucent" title="c&#43;&#43;">
          C&#43;&#43;
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/python/' class="post_tag button button_translucent" title="python">
          PYTHON
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/tcp/' class="post_tag button button_translucent" title="tcp">
          TCP
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/dart/' class="post_tag button button_translucent" title="dart">
          DART
          <span class="button_tally">6</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/flutter/' class="post_tag button button_translucent" title="flutter">
          FLUTTER
          <span class="button_tally">6</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/rust/' class="post_tag button button_translucent" title="rust">
          RUST
          <span class="button_tally">4</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/tdd/' class="post_tag button button_translucent" title="tdd">
          TDD
          <span class="button_tally">4</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/android/' class="post_tag button button_translucent" title="android">
          ANDROID
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/git/' class="post_tag button button_translucent" title="git">
          GIT
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/gtest/' class="post_tag button button_translucent" title="gtest">
          GTEST
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/js/' class="post_tag button button_translucent" title="js">
          JS
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/rust-lib/' class="post_tag button button_translucent" title="rust-lib">
          RUST-LIB
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/vcs/' class="post_tag button button_translucent" title="vcs">
          VCS
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/vim/' class="post_tag button button_translucent" title="vim">
          VIM
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/asm/' class="post_tag button button_translucent" title="asm">
          ASM
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/css/' class="post_tag button button_translucent" title="css">
          CSS
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/gas/' class="post_tag button button_translucent" title="gas">
          GAS
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/gcc/' class="post_tag button button_translucent" title="gcc">
          GCC
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/http/' class="post_tag button button_translucent" title="http">
          HTTP
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/libevent/' class="post_tag button button_translucent" title="libevent">
          LIBEVENT
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/macos/' class="post_tag button button_translucent" title="macos">
          MACOS
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/react-native/' class="post_tag button button_translucent" title="react-native">
          REACT-NATIVE
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/redis/' class="post_tag button button_translucent" title="redis">
          REDIS
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/%E6%9E%84%E6%9E%B6/' class="post_tag button button_translucent" title="构架">
          构架
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/api/' class="post_tag button button_translucent" title="api">
          API
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/bt/' class="post_tag button button_translucent" title="bt">
          BT
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/c&#43;/' class="post_tag button button_translucent" title="c&#43;">
          C&#43;
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/coroutine/' class="post_tag button button_translucent" title="coroutine">
          COROUTINE
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/database/' class="post_tag button button_translucent" title="database">
          DATABASE
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/docker/' class="post_tag button button_translucent" title="docker">
          DOCKER
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/endian/' class="post_tag button button_translucent" title="endian">
          ENDIAN
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/frontend/' class="post_tag button button_translucent" title="frontend">
          FRONTEND
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/gdb/' class="post_tag button button_translucent" title="gdb">
          GDB
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/go/' class="post_tag button button_translucent" title="go">
          GO
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/html/' class="post_tag button button_translucent" title="html">
          HTML
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/https/' class="post_tag button button_translucent" title="https">
          HTTPS
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/jquery/' class="post_tag button button_translucent" title="jquery">
          JQUERY
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/ld/' class="post_tag button button_translucent" title="ld">
          LD
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/logger/' class="post_tag button button_translucent" title="logger">
          LOGGER
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/makefile/' class="post_tag button button_translucent" title="makefile">
          MAKEFILE
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/misc/' class="post_tag button button_translucent" title="misc">
          MISC
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/orm/' class="post_tag button button_translucent" title="orm">
          ORM
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/os/' class="post_tag button button_translucent" title="os">
          OS
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/process/' class="post_tag button button_translucent" title="process">
          PROCESS
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/react/' class="post_tag button button_translucent" title="react">
          REACT
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/rpm/' class="post_tag button button_translucent" title="rpm">
          RPM
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/rsa/' class="post_tag button button_translucent" title="rsa">
          RSA
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/server/' class="post_tag button button_translucent" title="server">
          SERVER
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/sqlalchemy/' class="post_tag button button_translucent" title="sqlalchemy">
          SQLALCHEMY
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/ssh/' class="post_tag button button_translucent" title="ssh">
          SSH
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/ssl/tls/' class="post_tag button button_translucent" title="ssl/tls">
          SSL/TLS
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/vc/' class="post_tag button button_translucent" title="vc">
          VC
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/vite/' class="post_tag button button_translucent" title="vite">
          VITE
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/vue/' class="post_tag button button_translucent" title="vue">
          VUE
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/webui/' class="post_tag button button_translucent" title="webui">
          WEBUI
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/wechat/' class="post_tag button button_translucent" title="wechat">
          WECHAT
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/win32/' class="post_tag button button_translucent" title="win32">
          WIN32
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/windows/' class="post_tag button button_translucent" title="windows">
          WINDOWS
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/wireshark/' class="post_tag button button_translucent" title="wireshark">
          WIRESHARK
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/' class="post_tag button button_translucent" title="微服务">
          微服务
          <span class="button_tally">1</span>
        </a>
        
        
      </nav>
    </div>
  </section>
</aside>

  
</div>
  </main><svg width="0" height="0" class="hidden">
  <symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="facebook">
    <path d="M437 0H75C33.648 0 0 33.648 0 75v362c0 41.352 33.648 75 75 75h151V331h-60v-90h60v-61c0-49.629 40.371-90 90-90h91v90h-91v61h91l-15 90h-76v181h121c41.352 0 75-33.648 75-75V75c0-41.352-33.648-75-75-75zm0 0"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18.001 18.001" id="twitter">
    <path d="M15.891 4.013c.808-.496 1.343-1.173 1.605-2.034a8.68 8.68 0 0 1-2.351.861c-.703-.756-1.593-1.14-2.66-1.14-1.043 0-1.924.366-2.643 1.078a3.56 3.56 0 0 0-1.076 2.605c0 .309.039.585.117.819-3.076-.105-5.622-1.381-7.628-3.837-.34.601-.51 1.213-.51 1.846 0 1.301.549 2.332 1.645 3.089-.625-.053-1.176-.211-1.645-.47 0 .929.273 1.705.82 2.388a3.623 3.623 0 0 0 2.115 1.291c-.312.08-.641.118-.979.118-.312 0-.533-.026-.664-.083.23.757.664 1.371 1.291 1.841a3.652 3.652 0 0 0 2.152.743C4.148 14.173 2.625 14.69.902 14.69c-.422 0-.721-.006-.902-.038 1.697 1.102 3.586 1.649 5.676 1.649 2.139 0 4.029-.542 5.674-1.626 1.645-1.078 2.859-2.408 3.639-3.974a10.77 10.77 0 0 0 1.172-4.892v-.468a7.788 7.788 0 0 0 1.84-1.921 8.142 8.142 0 0 1-2.11.593z"
      ></path>
  </symbol>
  <symbol aria-hidden="true" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="mail">
    <path  d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="calendar">
    <path d="M452 40h-24V0h-40v40H124V0H84v40H60C26.916 40 0 66.916 0 100v352c0 33.084 26.916 60 60 60h392c33.084 0 60-26.916 60-60V100c0-33.084-26.916-60-60-60zm20 412c0 11.028-8.972 20-20 20H60c-11.028 0-20-8.972-20-20V188h432v264zm0-304H40v-48c0-11.028 8.972-20 20-20h24v40h40V80h264v40h40V80h24c11.028 0 20 8.972 20 20v48z"></path>
    <path d="M76 230h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zM76 310h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zM76 390h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zm80-80h40v40h-40z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="github">
    <path d="M255.968 5.329C114.624 5.329 0 120.401 0 262.353c0 113.536 73.344 209.856 175.104 243.872 12.8 2.368 17.472-5.568 17.472-12.384 0-6.112-.224-22.272-.352-43.712-71.2 15.52-86.24-34.464-86.24-34.464-11.616-29.696-28.416-37.6-28.416-37.6-23.264-15.936 1.728-15.616 1.728-15.616 25.696 1.824 39.2 26.496 39.2 26.496 22.848 39.264 59.936 27.936 74.528 21.344 2.304-16.608 8.928-27.936 16.256-34.368-56.832-6.496-116.608-28.544-116.608-127.008 0-28.064 9.984-51.008 26.368-68.992-2.656-6.496-11.424-32.64 2.496-68 0 0 21.504-6.912 70.4 26.336 20.416-5.696 42.304-8.544 64.096-8.64 21.728.128 43.648 2.944 64.096 8.672 48.864-33.248 70.336-26.336 70.336-26.336 13.952 35.392 5.184 61.504 2.56 68 16.416 17.984 26.304 40.928 26.304 68.992 0 98.72-59.84 120.448-116.864 126.816 9.184 7.936 17.376 23.616 17.376 47.584 0 34.368-.32 62.08-.32 70.496 0 6.88 4.608 14.88 17.6 12.352C438.72 472.145 512 375.857 512 262.353 512 120.401 397.376 5.329 255.968 5.329z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 212 212" id="gitlab">
    <path d="M12.3 74.7h54L43.3 3c-1-3.6-6.4-3.6-7.6 0L12.3 74.8z" />
    <path d="M12.3 74.7L.5 111c-1 3.2 0 6.8 3 8.8l101.6 74-92.5-119z"/>
    <path d="M105 193.7l-38.6-119h-54l92.7 119z"/>
    <path d="M105 193.7l38.7-119H66.4l38.7 119z"/>
    <path d="M105 193.7l38.7-119H198l-93 119z"/>
    <path d="M198 74.7l11.6 36.2c1 3 0 6.6-3 8.6l-101.5 74 93-119z"/>
    <path d="M198 74.7h-54.3L167 3c1.2-3.6 6.4-3.6 7.6 0L198 74.8z"/>
  </symbol>
  <symbol viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="rss">
    <circle cx="3.429" cy="20.571" r="3.429"></circle>
    <path d="M11.429 24h4.57C15.999 15.179 8.821 8.001 0 8v4.572c6.302.001 11.429 5.126 11.429 11.428z"></path>
    <path d="M24 24C24 10.766 13.234 0 0 0v4.571c10.714 0 19.43 8.714 19.43 19.429z"></path>
  </symbol>
  <symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="linkedin">
    <path d="M437 0H75C33.648 0 0 33.648 0 75v362c0 41.352 33.648 75 75 75h362c41.352 0 75-33.648 75-75V75c0-41.352-33.648-75-75-75zM181 406h-60V196h60zm0-240h-60v-60h60zm210 240h-60V286c0-16.54-13.46-30-30-30s-30 13.46-30 30v120h-60V196h60v11.309C286.719 202.422 296.93 196 316 196c40.691.043 75 36.547 75 79.688zm0 0"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 612 612" id="to-top">
    <path d="M604.501 440.509L325.398 134.956c-5.331-5.357-12.423-7.627-19.386-7.27-6.989-.357-14.056 1.913-19.387 7.27L7.499 440.509c-9.999 10.024-9.999 26.298 0 36.323s26.223 10.024 36.222 0l262.293-287.164L568.28 476.832c9.999 10.024 26.222 10.024 36.221 0 9.999-10.023 9.999-26.298 0-36.323z"></path>
  </symbol>
  <symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="carly">
    <path d="M504.971 239.029L448 182.059V84c0-46.317-37.682-84-84-84h-44c-13.255 0-24 10.745-24 24s10.745 24 24 24h44c19.851 0 36 16.149 36 36v108c0 6.365 2.529 12.47 7.029 16.971L454.059 256l-47.029 47.029A24.002 24.002 0 0 0 400 320v108c0 19.851-16.149 36-36 36h-44c-13.255 0-24 10.745-24 24s10.745 24 24 24h44c46.318 0 84-37.683 84-84v-98.059l56.971-56.971c9.372-9.372 9.372-24.568 0-33.941zM112 192V84c0-19.851 16.149-36 36-36h44c13.255 0 24-10.745 24-24S205.255 0 192 0h-44c-46.318 0-84 37.683-84 84v98.059l-56.971 56.97c-9.373 9.373-9.373 24.568 0 33.941L64 329.941V428c0 46.317 37.682 84 84 84h44c13.255 0 24-10.745 24-24s-10.745-24-24-24h-44c-19.851 0-36-16.149-36-36V320c0-6.365-2.529-12.47-7.029-16.971L57.941 256l47.029-47.029A24.002 24.002 0 0 0 112 192z"></path>
  </symbol>
  <symbol viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="copy">
    <path d="M23 2.75A2.75 2.75 0 0 0 20.25 0H8.75A2.75 2.75 0 0 0 6 2.75v13.5A2.75 2.75 0 0 0 8.75 19h11.5A2.75 2.75 0 0 0 23 16.25zM18.25 14.5h-7.5a.75.75 0 0 1 0-1.5h7.5a.75.75 0 0 1 0 1.5zm0-3h-7.5a.75.75 0 0 1 0-1.5h7.5a.75.75 0 0 1 0 1.5zm0-3h-7.5a.75.75 0 0 1 0-1.5h7.5a.75.75 0 0 1 0 1.5z"></path>
    <path d="M8.75 20.5a4.255 4.255 0 0 1-4.25-4.25V2.75c0-.086.02-.166.025-.25H3.75A2.752 2.752 0 0 0 1 5.25v16A2.752 2.752 0 0 0 3.75 24h12a2.752 2.752 0 0 0 2.75-2.75v-.75z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512.001 512.001" id="closeme">
    <path d="M284.286 256.002L506.143 34.144c7.811-7.811 7.811-20.475 0-28.285-7.811-7.81-20.475-7.811-28.285 0L256 227.717 34.143 5.859c-7.811-7.811-20.475-7.811-28.285 0-7.81 7.811-7.811 20.475 0 28.285l221.857 221.857L5.858 477.859c-7.811 7.811-7.811 20.475 0 28.285a19.938 19.938 0 0 0 14.143 5.857 19.94 19.94 0 0 0 14.143-5.857L256 284.287l221.857 221.857c3.905 3.905 9.024 5.857 14.143 5.857s10.237-1.952 14.143-5.857c7.811-7.811 7.811-20.475 0-28.285L284.286 256.002z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="open-menu">
    <path d="M492 236H20c-11.046 0-20 8.954-20 20s8.954 20 20 20h472c11.046 0 20-8.954 20-20s-8.954-20-20-20zm0-160H20C8.954 76 0 84.954 0 96s8.954 20 20 20h472c11.046 0 20-8.954 20-20s-8.954-20-20-20zm0 320H20c-11.046 0-20 8.954-20 20s8.954 20 20 20h472c11.046 0 20-8.954 20-20s-8.954-20-20-20z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="instagram">
    <path d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948 0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072 3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.163 6.162 6.163 6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zm0 10.162c-2.209 0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796 0-1.441.645-1.441 1.44s.645 1.44 1.441 1.44c.795 0 1.439-.645 1.439-1.44s-.644-1.44-1.439-1.44z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id=youtube>
    <path d="M19.615 3.184c-3.604-.246-11.631-.245-15.23 0-3.897.266-4.356 2.62-4.385 8.816.029 6.185.484 8.549 4.385 8.816 3.6.245 11.626.246 15.23 0 3.897-.266 4.356-2.62 4.385-8.816-.029-6.185-.484-8.549-4.385-8.816zm-10.615 12.816v-8l8 3.993-8 4.007z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="stackoverflow">
    <path d="M21 27v-8h3v11H0V19h3v8h18z"></path><path d="M17.1.2L15 1.8l7.9 10.6 2.1-1.6L17.1.2zm3.7 14.7L10.6 6.4l1.7-2 10.2 8.5-1.7 2zM7.2 12.3l12 5.6 1.1-2.4-12-5.6-1.1 2.4zm-1.8 6.8l13.56 1.96.17-2.38-13.26-2.55-.47 2.97zM19 25H5v-3h14v3z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="xing">
    <path d="M18.188 0c-.517 0-.741.325-.927.66 0 0-7.455 13.224-7.702 13.657.015.024 4.919 9.023 4.919 9.023.17.308.436.66.967.66h3.454c.211 0 .375-.078.463-.22.089-.151.089-.346-.009-.536l-4.879-8.916c-.004-.006-.004-.016 0-.022L22.139.756c.095-.191.097-.387.006-.535C22.056.078 21.894 0 21.686 0h-3.498zM3.648 4.74c-.211 0-.385.074-.473.216-.09.149-.078.339.02.531l2.34 4.05c.004.01.004.016 0 .021L1.86 16.051c-.099.188-.093.381 0 .529.085.142.239.234.45.234h3.461c.518 0 .766-.348.945-.667l3.734-6.609-2.378-4.155c-.172-.315-.434-.659-.962-.659H3.648v.016z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 71 55" id="discord">
    <path d="M60.1045 4.8978C55.5792 2.8214 50.7265 1.2916 45.6527 0.41542C45.5603 0.39851 45.468 0.440769 45.4204 0.525289C44.7963 1.6353 44.105 3.0834 43.6209 4.2216C38.1637 3.4046 32.7345 3.4046 27.3892 4.2216C26.905 3.0581 26.1886 1.6353 25.5617 0.525289C25.5141 0.443589 25.4218 0.40133 25.3294 0.41542C20.2584 1.2888 15.4057 2.8186 10.8776 4.8978C10.8384 4.9147 10.8048 4.9429 10.7825 4.9795C1.57795 18.7309 -0.943561 32.1443 0.293408 45.3914C0.299005 45.4562 0.335386 45.5182 0.385761 45.5576C6.45866 50.0174 12.3413 52.7249 18.1147 54.5195C18.2071 54.5477 18.305 54.5139 18.3638 54.4378C19.7295 52.5728 20.9469 50.6063 21.9907 48.5383C22.0523 48.4172 21.9935 48.2735 21.8676 48.2256C19.9366 47.4931 18.0979 46.6 16.3292 45.5858C16.1893 45.5041 16.1781 45.304 16.3068 45.2082C16.679 44.9293 17.0513 44.6391 17.4067 44.3461C17.471 44.2926 17.5606 44.2813 17.6362 44.3151C29.2558 49.6202 41.8354 49.6202 53.3179 44.3151C53.3935 44.2785 53.4831 44.2898 53.5502 44.3433C53.9057 44.6363 54.2779 44.9293 54.6529 45.2082C54.7816 45.304 54.7732 45.5041 54.6333 45.5858C52.8646 46.6197 51.0259 47.4931 49.0921 48.2228C48.9662 48.2707 48.9102 48.4172 48.9718 48.5383C50.038 50.6034 51.2554 52.5699 52.5959 54.435C52.6519 54.5139 52.7526 54.5477 52.845 54.5195C58.6464 52.7249 64.529 50.0174 70.6019 45.5576C70.6551 45.5182 70.6887 45.459 70.6943 45.3942C72.1747 30.0791 68.2147 16.7757 60.1968 4.9823C60.1772 4.9429 60.1437 4.9147 60.1045 4.8978ZM23.7259 37.3253C20.2276 37.3253 17.3451 34.1136 17.3451 30.1693C17.3451 26.225 20.1717 23.0133 23.7259 23.0133C27.308 23.0133 30.1626 26.2532 30.1066 30.1693C30.1066 34.1136 27.28 37.3253 23.7259 37.3253ZM47.3178 37.3253C43.8196 37.3253 40.9371 34.1136 40.9371 30.1693C40.9371 26.225 43.7636 23.0133 47.3178 23.0133C50.9 23.0133 53.7545 26.2532 53.6986 30.1693C53.6986 34.1136 50.9 37.3253 47.3178 37.3253Z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 17 18" id="mastodon">
    <path
    fill="#ffffff"
    d="m 15.054695,9.8859583 c -0.22611,1.1632697 -2.02517,2.4363497 -4.09138,2.6830797 -1.0774504,0.12856 -2.1382704,0.24673 -3.2694704,0.19484 -1.84996,-0.0848 -3.30971,-0.44157 -3.30971,-0.44157 0,0.1801 0.0111,0.35157 0.0333,0.51194 0.24051,1.82571 1.81034,1.93508 3.29737,1.98607 1.50088,0.0514 2.8373104,-0.37004 2.8373104,-0.37004 l 0.0617,1.35686 c 0,0 -1.0498104,0.56374 -2.9199404,0.66742 -1.03124,0.0567 -2.3117,-0.0259 -3.80308,-0.42069 -3.23454998,-0.85613 -3.79081998,-4.304 -3.87592998,-7.8024197 -0.026,-1.03871 -0.01,-2.01815 -0.01,-2.83732 0,-3.57732 2.34385998,-4.62587996 2.34385998,-4.62587996 1.18184,-0.54277 3.20976,-0.77101 5.318,-0.7882499985409 h 0.0518 C 9.8267646,0.01719834 11.856025,0.24547834 13.037775,0.78824834 c 0,0 2.34377,1.04855996 2.34377,4.62587996 0,0 0.0294,2.63937 -0.32687,4.47183"/>
 <path
    fill="#000000"
    d="m 12.616925,5.6916583 v 4.3315297 h -1.71607 V 5.8189683 c 0,-0.88624 -0.37289,-1.33607 -1.1187604,-1.33607 -0.82467,0 -1.23799,0.53361 -1.23799,1.58875 v 2.30122 h -1.70594 v -2.30122 c 0,-1.05514 -0.4134,-1.58875 -1.23808,-1.58875 -0.74587,0 -1.11876,0.44983 -1.11876,1.33607 v 4.2042197 h -1.71607 V 5.6916583 c 0,-0.88527 0.22541,-1.58876 0.67817,-2.10922 0.46689,-0.52047 1.07833,-0.78727 1.83735,-0.78727 0.87816,0 1.54317,0.33752 1.98288,1.01267 l 0.42744,0.71655 0.42753,-0.71655 c 0.43961,-0.67515 1.10463,-1.01267 1.9828704,-1.01267 0.75893,0 1.37037,0.2668 1.83735,0.78727 0.45268,0.52046 0.67808,1.22395 0.67808,2.10922"/>
  </symbol>
</svg>

<footer class="footer">
  <div class="footer_inner wrap pale">
    <img src='https://luoguochun.cn/icons/apple-touch-icon.png' class="icon icon_2 transparent" alt="BUF1024">
    <p>Copyright&nbsp;2011-&nbsp;<span class="year"></span>&nbsp;BUF1024. All Rights Reserved</p><a class="to_top" href="#documentTop">
  <svg class="icon">
  <title>to-top</title>
  <use xlink:href="#to-top"></use>
</svg>

</a>

  </div>
</footer>

<script type="text/javascript" src="https://luoguochun.cn/zh-cn/js/bundle.884eccc71c2848fb4aeb15945329b5a857717f0313da00cb46b765b5734cfa64b08ce2609627167129c2de17d9b47ed210682f96a2502ebb3aadc73191740211.js" integrity="sha512-iE7MxxwoSPtK6xWUUym1qFdxfwMT2gDLRrdltXNM&#43;mSwjOJglicWcSnC3hfZtH7SEGgvlqJQLrs6rccxkXQCEQ==" crossorigin="anonymous"></script>
</body>

</html>
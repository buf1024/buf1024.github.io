
<!DOCTYPE html>
<html lang="zh-cn" data-figures=""  class="page"   >

<head>
<title>BUF1024</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">





<meta property="og:locale" content="zh-cn" />

<meta property="og:type" content="article">
<meta name="description" content="表达式 LISP programmers know the value of everything, but the cost of nothing ——Alan Perlis, epigram #55 在本章中，我们将介绍Rust的 表达式 ，它是构成Rust函数体和大部分Rust代码的构建块。本" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:creator" content="">
<meta name="twitter:title" content="" />
<meta name="twitter:image" content="https://luoguochun.cn"/>
<meta property="og:url" content="https://luoguochun.cn/prust/ch06/" />
<meta property="og:title" content="" />
<meta property="og:description" content="表达式 LISP programmers know the value of everything, but the cost of nothing ——Alan Perlis, epigram #55 在本章中，我们将介绍Rust的 表达式 ，它是构成Rust函数体和大部分Rust代码的构建块。本" />
<meta property="og:image" content="https://luoguochun.cn" />
  <meta name="keywords" content="blog,computer,luoguochun" />

<link rel="apple-touch-icon" sizes="180x180" href="https://luoguochun.cn/icons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://luoguochun.cn/icons/favicon-32x32.png">
<link rel="manifest" href="https://luoguochun.cn/icons/site.webmanifest">

<link rel="canonical" href="https://luoguochun.cn/prust/ch06/">



<link rel="preload" href="https://luoguochun.cn/css/styles.42e2c5f6d8cf9c52872666f8d8b2678ad0c426978b9d78aff3c33b7a1e7f6f97f54bcdaf0518a25fb0fe26367d04f8b07c683b3b38b331cb098daadee06b1f3e.css" integrity = "sha512-QuLF9tjPnFKHJmb42LJnitDEJpeLnXiv88M7eh5/b5f1S82vBRiiX7D&#43;JjZ9BPiwfGg7OzizMcsJjare4GsfPg==" as="style" crossorigin="anonymous">



<link rel="preload" href="https://luoguochun.cn/zh-cn/js/bundle.884eccc71c2848fb4aeb15945329b5a857717f0313da00cb46b765b5734cfa64b08ce2609627167129c2de17d9b47ed210682f96a2502ebb3aadc73191740211.js" as="script" integrity=
"sha512-iE7MxxwoSPtK6xWUUym1qFdxfwMT2gDLRrdltXNM&#43;mSwjOJglicWcSnC3hfZtH7SEGgvlqJQLrs6rccxkXQCEQ==" crossorigin="anonymous">


<link rel="stylesheet" type="text/css" href="https://luoguochun.cn/css/styles.42e2c5f6d8cf9c52872666f8d8b2678ad0c426978b9d78aff3c33b7a1e7f6f97f54bcdaf0518a25fb0fe26367d04f8b07c683b3b38b331cb098daadee06b1f3e.css" integrity="sha512-QuLF9tjPnFKHJmb42LJnitDEJpeLnXiv88M7eh5/b5f1S82vBRiiX7D&#43;JjZ9BPiwfGg7OzizMcsJjare4GsfPg==" crossorigin="anonymous">

</head>

<body data-code="100" data-lines="false" id="documentTop"
  data-lang="zh-cn">

<header class="nav_header" >
  <nav class="nav"><a href='https://luoguochun.cn' class="nav_brand nav_item" title="BUF1024">BUF1024
  <div class="nav_close">
    <div><svg class="icon">
  <title>open-menu</title>
  <use xlink:href="#open-menu"></use>
</svg>
<svg class="icon">
  <title>closeme</title>
  <use xlink:href="#closeme"></use>
</svg>
</div>
  </div>
</a>

    <div class='nav_body nav_body_left'>
      
      
      
        

  <div class="nav_parent">
    <a href="https://luoguochun.cn/" class="nav_item" title="主页">主页 </a>
  </div>
  <div class="nav_parent">
    <a href="https://luoguochun.cn" class="nav_item" title="链接">链接 <img src='https://luoguochun.cn/icons/caret-icon.svg' alt="icon" class="nav_icon"></a>
    <div class="nav_sub">
      <span class="nav_child"></span>
        <a href="https://luoguochun.cn/talib-doc/" class="nav_child nav_item" title="TA 技术分析库">TA 技术分析库</a>
        <a href="https://luoguochun.cn/hiqradio" class="nav_child nav_item" title="hiqadio网络收音机">hiqadio网络收音机</a>
    </div>
  </div>
  <div class="nav_parent">
    <a href="https://luoguochun.cn/about/" class="nav_item" title="关于">关于 </a>
  </div>
      
<div class='follow'>
<div class="color_mode">
  <input type="checkbox" class="color_choice" id="mode">
</div>

</div>

    </div>
  </nav>
</header>

  <main>
  
<div class="grid-inverse wrap content">
  <article class="post_content">
    <h1 class="post_title"></h1>
  <div class="post_meta">
    <span><svg class="icon">
  <title>calendar</title>
  <use xlink:href="#calendar"></use>
</svg>
</span>
    <span class="post_date">
      Jan 1, 0001</span>
    <span class="post_time"> · 24 min read</span>
    <span class="page_only">&nbsp;·
  <div class="post_share">
    分享到:
    <a href="https://twitter.com/intent/tweet?text=&url=https%3a%2f%2fluoguochun.cn%2fprust%2fch06%2f&tw_p=tweetbutton" class="twitter" title="分享到 Twitter" target="_blank" rel="nofollow">
      <svg class="icon">
  <title>twitter</title>
  <use xlink:href="#twitter"></use>
</svg>

    </a>
    <a href="https://www.facebook.com/sharer.php?u=https%3a%2f%2fluoguochun.cn%2fprust%2fch06%2f&t=" class="facebook" title="分享到 Facebook" target="_blank" rel="nofollow">
      <svg class="icon">
  <title>facebook</title>
  <use xlink:href="#facebook"></use>
</svg>

    </a>
    <a href="#linkedinshare" id = "linkedinshare" class="linkedin" title="分享到 LinkedIn" rel="nofollow">
      <svg class="icon">
  <title>linkedin</title>
  <use xlink:href="#linkedin"></use>
</svg>

    </a>
    <a href="https://luoguochun.cn/prust/ch06/" title="Copy Link" class="link link_yank">
      <svg class="icon">
  <title>copy</title>
  <use xlink:href="#copy"></use>
</svg>

    </a>
  </div>
  </span>
  </div>

    <div class="post_body"><h1 id="表达式">表达式</h1>
<p><em>LISP programmers know the value of everything, but the cost of nothing</em></p>
<p align="right">
    ——Alan Perlis, epigram #55
</p>
<p>在本章中，我们将介绍Rust的 <em>表达式</em> ，它是构成Rust函数体和大部分Rust代码的构建块。本章将探索表达式的力量以及如何克服它的局限。我们还将介绍控制流，它在Rust中完全是以表达式为基础的，最后还要介绍Rust中的基本运算符如何单独和组合工作。</p>
<p>还有一些从技术角度应该划入这一类的概念，例如闭包和迭代器。但它们太过重要因此我们之后会用单独的章节介绍它们。现在，我们希望能用尽可能少的页数介绍尽可能多的语法。</p>
<h2 id="表达式语言">表达式语言</h2>
<p>Rust表面上看上去像C家族的语言，但这其实是一个误解。在C语言中， <em>表达式</em> 和 <em>语句</em> 之间有很大的不同。表达式是一些像这样的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">    <span class="mi">5</span> <span class="o">*</span> <span class="p">(</span><span class="n">fahr</span><span class="o">-</span><span class="mi">32</span><span class="p">)</span> <span class="o">/</span> <span class="mi">9</span>
</code></pre></td></tr></table>
</div>
</div><p>而语句则是像这样的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">    <span class="k">for</span> <span class="p">(;</span> <span class="n">begin</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">begin</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">begin</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>表达式有值，但语句没有。</p>
<p>Rust是一种 <em>表达式语言</em> 。这意味着它遵循了起源于Lisp的传统，即表达式负责完成所有工作。</p>
<p>在C中，<code>if</code>和<code>switch</code>是语句。它们并不产生值，也不能被用在表达式中间。在Rust中，<code>if</code>和<code>match</code> <em>可以</em> 产生值。我们已经在”第2章”中看到过一个产生数字值的<code>match</code>表达式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="n">pixels</span><span class="p">[</span><span class="n">r</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">bounds</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w">
</span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">escapes</span><span class="p">(</span><span class="n">Complex</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">re</span>: <span class="nc">point</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">im</span>: <span class="nc">point</span><span class="p">.</span><span class="mi">1</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="mi">255</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="n">count</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">255</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u8</span><span class="w">
</span><span class="w">        </span><span class="p">};</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>一个<code>if</code>表达式可以用于初始化一个变量：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">cpu</span><span class="p">.</span><span class="n">temperature</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">MAX_TEMP</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">HttpStatus</span>::<span class="nb">Ok</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">HttpStatus</span>::<span class="n">ServerError</span><span class="w">  </span><span class="c1">// server melted
</span><span class="c1"></span><span class="w">        </span><span class="p">};</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>一个<code>match</code>表达式可以被用作函数或宏的参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;Inside the vat, you see {}.&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">vat</span><span class="p">.</span><span class="n">contents</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="n">brain</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">brain</span><span class="p">.</span><span class="n">desc</span><span class="p">(),</span><span class="w">
</span><span class="w">            </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&#34;nothing of interest&#34;</span><span class="w">
</span><span class="w">        </span><span class="p">});</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这解释了Rust为什么没有C的三元运算符<code>(expr1 ? expr2 : expr3)</code>。在C中，它是一种类似<code>if</code>语句的表达式。但在Rust中这种写法是多余的，因为<code>if</code>表达式可以同时实现这两种功能。</p>
<p>C中的大部分控制流工具都是语句，而Rust中的控制流则全是表达式。</p>
<h2 id="优先级与结合性">优先级与结合性</h2>
<p>”表6-1”总结了Rust的表达式语法。我们将在这一章中介绍所有这些表达式。运算符按照优先级从高到低的顺序列出。（类似于大多数编程语言，Rust使用 <em>运算符优先级</em> 来决定当表达式中含有多个运算符时的运算顺序。例如，在表达式<code>limit &lt; 2 * broom.size + 1</code>中，<code>.</code>运算符优先级最高，因此会先访问字段。）</p>
<table>
<thead>
<tr>
<th><strong>表达式类型</strong></th>
<th><strong>示例</strong></th>
<th><strong>相关trait</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>数组字面量</td>
<td><code>[1, 2, 3]</code></td>
<td></td>
</tr>
<tr>
<td>重复数组字面量</td>
<td><code>[0; 50]</code></td>
<td></td>
</tr>
<tr>
<td>元组</td>
<td><code>(6, &quot;crullers&quot;)</code></td>
<td></td>
</tr>
<tr>
<td>组合</td>
<td><code>(2 + 2)</code></td>
<td></td>
</tr>
<tr>
<td>块</td>
<td><code>{ f(); g() }</code></td>
<td></td>
</tr>
<tr>
<td>控制流表达式</td>
<td><code>if ok { f() }</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>if ok { 1 } else { 0 }</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>if let Some(x) = f() { x } else { 0 }</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>match x { None =&gt; 0, _ =&gt; 1 }</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>for v in e { f(v); }</code></td>
<td><code>“std::iter::IntoIterator”</code></td>
</tr>
<tr>
<td></td>
<td><code>while ok { ok = f(); }</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>while let Some(x) = it.next() { f(x); }</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>loop { next_event(); }</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>break</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>continue</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>return 0</code></td>
<td></td>
</tr>
<tr>
<td>宏调用</td>
<td><code>println!(&quot;ok&quot;)</code></td>
<td></td>
</tr>
<tr>
<td>路径</td>
<td><code>std::f64::consts::PI</code></td>
<td></td>
</tr>
<tr>
<td>结构体字面量</td>
<td><code>Point {x: 0, y: 0}</code></td>
<td></td>
</tr>
<tr>
<td>元组字段访问</td>
<td><code>pair.0</code></td>
<td><code>“Deref”</code>, <code>“DerefMut”</code></td>
</tr>
<tr>
<td>结构体字段访问</td>
<td><code>point.x</code></td>
<td><code>“Deref”</code>, <code>“DerefMut”</code></td>
</tr>
<tr>
<td>方法调用</td>
<td><code>point.translate(50, 50)</code></td>
<td><code>“Deref”</code>, <code>“DerefMut”</code></td>
</tr>
<tr>
<td>函数调用</td>
<td><code>stdin()</code></td>
<td><code>“Fn(Arg0, ...) -&gt; T”</code>, <code>“FnMut(Arg0, ...) -&gt; T”</code>, <code>“FnOnce(Arg0, ...) -&gt; T”</code></td>
</tr>
<tr>
<td>索引</td>
<td><code>arr[0]</code></td>
<td><code>“Index”</code>, <code>“IndexMut”</code>, <code>“Deref”</code>, <code>“DerefMut”</code></td>
</tr>
<tr>
<td>错误检查</td>
<td><code>create_dir(&quot;tmp&quot;)?</code></td>
<td></td>
</tr>
<tr>
<td>逻辑/位 NOT</td>
<td><code>!ok</code></td>
<td><code>“Not”</code></td>
</tr>
<tr>
<td>负</td>
<td><code>-num</code></td>
<td><code>“Neg”</code></td>
</tr>
<tr>
<td>解引用</td>
<td><code>*ptr</code></td>
<td><code>“Deref”</code>, <code>“DerefMut”</code></td>
</tr>
<tr>
<td>借用</td>
<td><code>&amp;val</code></td>
<td></td>
</tr>
<tr>
<td>类型转换</td>
<td><code>x as u32</code></td>
<td></td>
</tr>
<tr>
<td>乘法</td>
<td><code>n * 2</code></td>
<td><code>“Mul”</code></td>
</tr>
<tr>
<td>除法</td>
<td><code>n / 2</code></td>
<td><code>“Div”</code></td>
</tr>
<tr>
<td>余数（取模）</td>
<td><code>n % 2</code></td>
<td><code>“Rem”</code></td>
</tr>
<tr>
<td>加法</td>
<td><code>n + 1</code></td>
<td><code>“Add”</code></td>
</tr>
<tr>
<td>减法</td>
<td><code>n - 1</code></td>
<td><code>“Sub”</code></td>
</tr>
<tr>
<td>左移</td>
<td><code>n &lt;&lt; 1</code></td>
<td><code>“Shl”</code></td>
</tr>
<tr>
<td>右移</td>
<td><code>n &gt;&gt; 1</code></td>
<td><code>“Shr”</code></td>
</tr>
<tr>
<td>位与</td>
<td><code>n &amp; 1</code></td>
<td><code>“BitAnd”</code></td>
</tr>
<tr>
<td>位异或</td>
<td><code>n ^ 1</code></td>
<td><code>“BitXor”</code></td>
</tr>
<tr>
<td>位或</td>
<td><code>n | 1</code></td>
<td><code>“BitOr”</code></td>
</tr>
<tr>
<td>小于</td>
<td><code>n &lt; 1</code></td>
<td><code>“std::cmp::PartialOrd”</code></td>
</tr>
<tr>
<td>小于等于</td>
<td><code>n &lt;= 1</code></td>
<td><code>“std::cmp::PartialOrd”</code></td>
</tr>
<tr>
<td>大于</td>
<td><code>n &gt; 1</code></td>
<td><code>“std::cmp::PartialOrd”</code></td>
</tr>
<tr>
<td>大于等于</td>
<td><code>n &gt;= 1</code></td>
<td><code>“std::cmp::PartialOrd”</code></td>
</tr>
<tr>
<td>等于</td>
<td><code>n == 1</code></td>
<td><code>“std::cmp::PartialEq”</code></td>
</tr>
<tr>
<td>不等于</td>
<td><code>n != 1</code></td>
<td><code>“std::cmp::PartialEq”</code></td>
</tr>
<tr>
<td>逻辑与</td>
<td><code>x.ok &amp;&amp; y.ok</code></td>
<td></td>
</tr>
<tr>
<td>逻辑或</td>
<td><code>x.ok || backup.ok</code></td>
<td></td>
</tr>
<tr>
<td>左闭右开区间</td>
<td><code>start .. stop</code></td>
<td></td>
</tr>
<tr>
<td>左闭右闭区间</td>
<td><code>start ..= stop</code></td>
<td></td>
</tr>
<tr>
<td>赋值</td>
<td><code>x = val</code></td>
<td></td>
</tr>
<tr>
<td>复合赋值</td>
<td><code>x *= 1</code></td>
<td><code>“MulAssign”</code></td>
</tr>
<tr>
<td></td>
<td><code>x /= 1</code></td>
<td><code>“DivAssign”</code></td>
</tr>
<tr>
<td></td>
<td><code>x %= 1</code></td>
<td><code>“RemAssign”</code></td>
</tr>
<tr>
<td></td>
<td><code>x += 1</code></td>
<td><code>“AddAssign”</code></td>
</tr>
<tr>
<td></td>
<td><code>x -= 1</code></td>
<td><code>“SubAssign”</code></td>
</tr>
<tr>
<td></td>
<td><code>x &lt;&lt;= 1</code></td>
<td><code>“ShlAssign”</code></td>
</tr>
<tr>
<td></td>
<td><code>x &gt;&gt;= 1</code></td>
<td><code>“ShrAssign”</code></td>
</tr>
<tr>
<td></td>
<td><code>x &amp;= 1</code></td>
<td><code>“BitAndAssign”</code></td>
</tr>
<tr>
<td></td>
<td><code>x ^= 1</code></td>
<td><code>“BitXorAssign”</code></td>
</tr>
<tr>
<td></td>
<td><code>x |= 1</code></td>
<td><code>“BitOrAssign”</code></td>
</tr>
<tr>
<td>闭包</td>
<td><code>|x, y| x + y</code></td>
<td></td>
</tr>
</tbody>
</table>
<p>所有可以链式使用的运算符都是左结合的。也就是说，一条运算链例如<code>a - b - c</code>被组合为<code>(a - b) - c</code>，而不是<code>a - (b - c)</code>。这些运算符可以被任意组合：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">    * / % + - &lt;&lt; &gt;&gt; &amp; ^ | &amp;&amp; || as
</code></pre></td></tr></table>
</div>
</div><p>比较运算符、赋值运算符、范围运算符<code>..</code>和<code>..=</code>不能被链式使用。</p>
<h2 id="块和分号">块和分号</h2>
<p>块是最通用的表达式。一个块产生一个值，可以被用于任何需要一个值的地方：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">display_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">post</span><span class="p">.</span><span class="n">author</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">author</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">author</span><span class="p">.</span><span class="n">name</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">network_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">post</span><span class="p">.</span><span class="n">get_network_metadata</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">network_info</span><span class="p">.</span><span class="n">client_address</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="n">ip</span><span class="p">.</span><span class="n">to_string</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>Some(author) =&gt;</code>之后的代码是简单的表达式<code>author.name()</code>，<code>None =&gt;</code>之后的代码则是一个块表达式。对Rust来种，两种表达式没有区别。块表达式的值是它的最后一条表达式的值，也就是<code>ip.to_string()</code>。</p>
<p>注意<code>ip.to_string()</code>后面没有分号。Rust中的大部分代码行都以分号或者花括号结尾，类似于C和Java。如果一个块看起来像C代码一样在所有的表达式后边都有分号，那它的行为就和C块一样，它的值将是<code>()</code>。正如我们在”第2章”提到的，当你省略了块中最后一个表达式后边的分号，那么块的值将是最后一个表达式的值，而不是通常的<code>()</code>。</p>
<p>在一些语言中，尤其是Javascript，你可以省略分号，语言会自动为你添加上——这样除了方便一点，并没有任何区别。然而在Rust中，分号通常是有实际意义的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// let语句：总是需要分号
</span><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">dandelion_control</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">puffball</span><span class="p">.</span><span class="n">open</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="c1">// 表达式 + 分号：方法被调用，返回值被丢弃
</span><span class="c1"></span><span class="w">        </span><span class="n">dandelion_control</span><span class="p">.</span><span class="n">release_all_seeds</span><span class="p">(</span><span class="n">launch_codes</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="c1">// 没有分号的表达式：方法被调用，
</span><span class="c1"></span><span class="w">        </span><span class="c1">// 返回值被存储到 `msg`
</span><span class="c1"></span><span class="w">        </span><span class="n">dandelion_control</span><span class="p">.</span><span class="n">get_status</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>语句块可以包含声明最后还能产生一个值的能力是一个很有用的特性，而且可以很快习惯。它的一个缺陷是如果你偶然忘记了分号会导致一条错误信息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">preferences</span><span class="p">.</span><span class="n">changed</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">page</span><span class="p">.</span><span class="n">compute_size</span><span class="p">()</span><span class="w">  </span><span class="c1">// oops, 缺少分号
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>如果你在C或者Java程序中犯了这种错误，编译器会简单地直接指出你少写了一个分号。然而这是Rust的报错：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">    error[E0308]: mismatched types
    22 |         page.compute_size()  // oops, missing semicolon
       |         ^^^^^^^^^^^^^^^^^^^- help: try adding a semicolon `;`
       |         |
       |         expected (), found tuple
       |
       = note: expected unit type `()`
                  found tuple `(u32, u32)`
</code></pre></td></tr></table>
</div>
</div><p>在缺少分号的情况下，块的值将是<code>page.compute_size()</code>返回的值，但一个没有<code>else</code>分支的<code>if</code>语句必须总是返回<code>()</code>。幸运的是，Rust知道这种类型的错误并建议加上分号。</p>
<h2 id="声明">声明</h2>
<p>除了表达式和分号之外，一个块中可能包含任意数量的声明。最常见的情况是<code>let</code>声明，它用来声明局部变量：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">name</span>: <span class="nc">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">expr</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>类型和初始值是可选的，分号是必须的。</p>
<p>一个<code>let</code>声明可以在不初始化的情况下声明一个变量。这有时很有用，因为有时候一个变量需要在控制流的中途初始化：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">name</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">user</span><span class="p">.</span><span class="n">has_nickname</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">user</span><span class="p">.</span><span class="n">nickname</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">generate_unique_name</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">user</span><span class="p">.</span><span class="n">register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">name</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>局部变量<code>name</code>有两种不同的初始化路径，但两条路径上它都只会被初始化一次，所以<code>name</code>不需要声明为<code>mut</code>。</p>
<p>在变量初始化之前使用它会导致错误（这和使用被move的值的错误紧密相关，Rust希望你只在变量的值存在时使用它们！）。</p>
<p>你有时可能会看到代码似乎重新声明一个已经存在的变量，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">file</span><span class="p">.</span><span class="n">lines</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">line</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>let</code>声明创建了一个新的、类型不同的、第二个变量<code>line</code>。第一个<code>line</code>的类型是<code>Result&lt;String, io::Error&gt;</code>，第二个<code>line</code>是一个<code>String</code>。第二个声明在块的剩余部分会取代第一个。这被称为 <em>遮蔽(shadowing)</em> ，在Rust程序中非常常见。上面的代码等价于：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">line_result</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">file</span><span class="p">.</span><span class="n">lines</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">line_result</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>在本书中，我们将坚持在这种场景中使用<code>_result</code>后缀，来保证变量的名字不同。</p>
<p>一个块还可以包含 <em>item declarations</em> 。一个item是一个可以出现在全局或模块中的声明，例如<code>fn</code>、<code>struct</code>、<code>use</code>。</p>
<p>后面的章节将会详细介绍item。现在，<code>fn</code>足够作为一个例子了。任何块都可以包含<code>fn</code>声明：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">cmp</span>::<span class="n">Ordering</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">show_files</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[];</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">        </span><span class="k">fn</span> <span class="nf">cmp_by_timestamp_then_name</span><span class="p">(</span><span class="n">a</span>: <span class="kp">&amp;</span><span class="nc">FileInfo</span><span class="p">,</span><span class="w"> </span><span class="n">b</span>: <span class="kp">&amp;</span><span class="nc">FileInfo</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Ordering</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">a</span><span class="p">.</span><span class="n">timestamp</span><span class="p">.</span><span class="n">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">.</span><span class="n">timestamp</span><span class="p">)</span><span class="w">   </span><span class="c1">// 首先，比较时间戳 
</span><span class="c1"></span><span class="w">                </span><span class="p">.</span><span class="n">reverse</span><span class="p">()</span><span class="w">                  </span><span class="c1">// 最新的文件优先
</span><span class="c1"></span><span class="w">                </span><span class="p">.</span><span class="n">then</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">.</span><span class="n">path</span><span class="p">))</span><span class="w">  </span><span class="c1">// 比较路径
</span><span class="c1"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="n">v</span><span class="p">.</span><span class="n">sort_by</span><span class="p">(</span><span class="n">cmp_by_timestamp_then_name</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>当一个<code>fn</code>在块内声明的时候，它的作用域是整个块，它可以在整个块内 <em>使用</em> 。但是一个嵌套的<code>fn</code>不能访问外围作用域的局部变量和参数。例如，函数<code>cmp_by_timestamp_then_name</code>不能使用<code>v</code>。（Rust还有闭包，闭包可以使用外层作用域的变量，见”第14章”。）</p>
<p>一个块甚至可以包含整个模块。这听起来可能有些多余了：我们真的需要把语言的 <em>每一部分</em> 嵌套在其他部分中的能力吗？——但程序员（尤其是使用宏的程序员）可以找到语言提供的每一个正交碎片的用法。</p>
<h2 id="if与match"><code>if</code>与<code>match</code></h2>
<p><code>if</code>表达式的形式大家都很熟悉：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">condition1</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">block1</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">condition2</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">block2</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">block_n</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>每一个<code>condition</code>都必须是<code>bool</code>类型的表达式，Rust不会隐式地将数字或者指针类型转换为布尔值。</p>
<p>和C不同的是条件表达式不需要括号，事实上如果有不必要的括号的话，<code>rustc</code>会发出警告。不过花括号是必须的。</p>
<p><code>else if</code>块，和最后的<code>else</code>都是可选的。一个没有<code>else</code>块的<code>if</code>表达式类似于一个<code>else</code>块为空的<code>if</code>表达式。</p>
<p><code>match</code>表达式有些类似于C的<code>switch</code>语句，但是更加灵活。一个简单的例子如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">code</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="mi">0</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;OK&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="mi">1</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;Wires Tangled&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="mi">2</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;User Asleep&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;Unrecognized Error {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">code</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这类似于一个<code>switch</code>语句，<code>match</code>表达式的四条分支里只有一条会执行，取决于<code>code</code>的值。通配符模式<code>_</code>可以匹配任何情况，类似于<code>switch</code>语句中的<code>default:</code>标签，不过它会覆盖之后的所有模式，它之后的模式将永远不会匹配到任何东西（出现这种情况时编译器也会警告你）。</p>
<p>编译器可以使用跳转表来优化这种<code>match</code>表达式，类似于C++中的<code>switch</code>语句。当<code>match</code>的每个分支都返回常量值时还会有一个类似的优化，这种情况下，编译器会用那些值构建一个数组，然后<code>match</code>会被编译为一次数组访问，这种情况下除了边界检查之外，编译出的代码将不会有任何条件分支。</p>
<p>每个分支中<code>=&gt;</code>左侧支持多种 <em>模式</em> ，这是<code>match</code>功能强大的根源。上边的例子中，每种模式都只是一个简单的整数。我们还展示过区分<code>Option</code>的两种值的<code>match</code>表达式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">params</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#34;name&#34;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;Hello, {}!&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;Greetings, stranger.&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这只是模式的一个小应用，一个模式可以匹配很多值。它可以解包元组，可以匹配结构体中的每个字段，可以解引用，借用一个值的一部分，等等。Rust的模式是一种专门的mini语言。我们将在”第10章”中介绍它们。</p>
<p><code>match</code>表达式的通用形式是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">pattern</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">expr</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>如果<code>expr</code>是一个块的话，分支最后的逗号可以省略。</p>
<p>Rust会从第一个分支开始，逐个检查<code>value</code>和给定的模式是否匹配。当有一个模式匹配时，相应的<code>expr</code>将会被求值，整个<code>match</code>表达式将完成执行，不会再检查别的模式。必须至少有一个模式可以匹配，Rust会禁止没有覆盖所有可能情况的<code>match</code>表达式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">score</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">card</span><span class="p">.</span><span class="n">rank</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Jack</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">Queen</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">Ace</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">11</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">  </span><span class="c1">// 错误：没有穷尽所有模式
</span></code></pre></td></tr></table>
</div>
</div><p><code>if</code>表达式的所有块必须产生相同类型的值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">suggested_pet</span><span class="w"> </span><span class="o">=</span><span class="w"> 
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">with_wings</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Pet</span>::<span class="n">Buzzard</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Pet</span>::<span class="n">Hyena</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// ok
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">favorite_number</span><span class="w"> </span><span class="o">=</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">user</span><span class="p">.</span><span class="n">is_hobbit</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s">&#34;eleventy-one&#34;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="p">};</span><span class="w">  </span><span class="c1">// error
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">best_sports_team</span><span class="w"> </span><span class="o">=</span><span class="w"> 
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">is_hockey_season</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s">&#34;Predators&#34;</span><span class="w"> </span><span class="p">};</span><span class="w">  </span><span class="c1">// error
</span></code></pre></td></tr></table>
</div>
</div><p>（最后一个例子会导致错误，因为在7月结果将是<code>()</code>。）<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
<p>类似的，<code>match</code>表达式的分支也必须有相同的类型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">suggested_pet</span><span class="w"> </span><span class="o">=</span><span class="w">
</span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">favorite</span><span class="p">.</span><span class="n">element</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Fire</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">Pet</span>::<span class="n">RedPanda</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">Air</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">Pet</span>::<span class="n">Buffalo</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">Water</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">Pet</span>::<span class="n">Orca</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">None</span><span class="w">   </span><span class="c1">// 错误：类型不一致
</span><span class="c1"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h2 id="if-let"><code>if let</code></h2>
<p><code>if</code>表达式还有一种形式：<code>if let</code>表达式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="n">pattern</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">expr</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">block1</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">block2</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>expr</code>如果能匹配<code>pattern</code>，则执行<code>block1</code>，如果不能匹配，则执行<code>block2</code>。有时这是一种获取<code>Option</code>或<code>Result</code>的值的好方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">cookie</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">request</span><span class="p">.</span><span class="n">session_cookie</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">restore_session</span><span class="p">(</span><span class="n">cookie</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">show_cheesy_anti_robot_task</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">log_robot_attempt</span><span class="p">(</span><span class="n">err</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="n">politely_accuse_user_of_being_a_robot</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">session</span><span class="p">.</span><span class="n">mark_as_human</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>没有任何场景 <em>必须</em> 使用<code>if let</code>，因为<code>match</code>可以做到任何<code>if let</code>可以做的事。<code>if let</code>表达式类似于如下只有一个模式的<code>match</code>表达式的缩写：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">expr</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">pattern</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">block1</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">block2</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h2 id="循环">循环</h2>
<p>有四种循环表达式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="n">condition</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">block</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="n">pattern</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">expr</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">block</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">block</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">pattern</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">iterable</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">block</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>在Rust中循环也是表达式，不过<code>while</code>或<code>for</code>循环的值总是<code>()</code>，因此它们的值并没有用。如果你指明的话<code>loop</code>表达式可以产生一个值。</p>
<p><code>while</code>循环的行为和C语言中的基本一样，除了<code>condition</code>必须是精确的<code>bool</code>类型的表达式。</p>
<p><code>while let</code>循环类似于<code>if let</code>。每一次迭代循环开始时，如果<code>expr</code>的值可以匹配<code>pattern</code>，将会运行表达式块，否则循环将结束。</p>
<p>使用<code>loop</code>循环来编写无限循环。它会永远重复执行<code>block</code>（直到遇到<code>break</code>或<code>return</code>或线程panic）。</p>
<p>一个<code>for</code>循环会先求值<code>iterable</code>表达式，然后对表达式返回的迭代器产生的每个值执行一次<code>block</code>。很多类型都可以被迭代，包括所有标准集合例如<code>Vec</code>和<code>HashMap</code>。标准的C语言中的<code>for</code>循环：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d\n&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>用Rust来写的话就是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="mi">20</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>和C语言一样，最后一个打印出的数字是<code>19</code>。</p>
<p><code>..</code>运算符会产生一个 <em>范围</em> ，它是一个只有两个字段<code>start</code>和<code>end</code>的简单结构体。<code>0..20</code>等价于<code>std::ops::Range { start: 0, end: 20 }</code>。范围可以用于<code>for</code>循环，因为<code>Range</code>是可以迭代的类型，它实现了<code>std::iter::IntoIterator</code> trait，我们将在”第15章”中讨论这些。标准集合都是可迭代的，数组和切片也是。</p>
<p>为了保持Rust中的移动语义，<code>for</code>循环会消耗掉值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">strings</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">error_messages</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">strings</span><span class="w"> </span><span class="p">{</span><span class="w">          </span><span class="c1">// 每一个String被移动进s
</span><span class="c1"></span><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">                           </span><span class="c1">// 并在这里drop
</span><span class="c1"></span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{} error(s)&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">strings</span><span class="p">.</span><span class="n">len</span><span class="p">());</span><span class="w"> </span><span class="c1">// 错误：使用了被move的值
</span></code></pre></td></tr></table>
</div>
</div><p>这样可能会很不方便，一个简单的方法是让循环获取集合的引用。然后循环变量将会变成集合中每一个元素的引用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">rs</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="n">strings</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;String {:?} is at address {:P}.&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">rs</span><span class="p">,</span><span class="w"> </span><span class="n">rs</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这里<code>&amp;strings</code>的类型是<code>&amp;Vec&lt;String&gt;</code>，<code>rs</code>的类型是<code>&amp;String</code>。</p>
<p>迭代一个<code>mut</code>引用会产生每个元素的<code>mut</code>引用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">rs</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">strings</span><span class="w"> </span><span class="p">{</span><span class="w">    </span><span class="c1">// rs的类型是&amp;mut String
</span><span class="c1"></span><span class="w">        </span><span class="n">rs</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">);</span><span class="w">  </span><span class="c1">// 每个字符串添加一个换行符
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>”第15章”会更详细的介绍<code>for</code>循环并展示其他使用迭代器的方式。</p>
<h2 id="循环中的控制流">循环中的控制流</h2>
<p><code>break</code>表达式用来跳出循环（Rust中<code>break</code>只能在循环中使用。<code>match</code>表达式中不需要它，这一点和<code>switch</code>语句不同）。</p>
<p>在一个<code>loop</code>循环体内，你可以给<code>break</code>一个表达式，
表达式的值就是整个循环的值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="c1">// 每一次对`next_line`的调用返回`Some(line)`，其中`line`
</span><span class="c1"></span><span class="w">    </span><span class="c1">// 是输入的一行；或者返回`None`，表示已经到达输入结尾。
</span><span class="c1"></span><span class="w">    </span><span class="c1">// 返回第一个以&#34;answer: &#34;开头的行。
</span><span class="c1"></span><span class="w">    </span><span class="c1">// 如果没有，就返回&#34;answer: nothing&#34;。
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">answer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">line</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">next_line</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">line</span><span class="p">.</span><span class="n">starts_with</span><span class="p">(</span><span class="s">&#34;answer: &#34;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="k">break</span><span class="w"> </span><span class="n">line</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">break</span><span class="w"> </span><span class="s">&#34;answer: nothing&#34;</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>自然，<code>loop</code>表达式中的所有<code>break</code>表达式必须产生相同类型的值，这个类型也会成为<code>loop</code>本身的类型。</p>
<p>一个<code>continue</code>表达式跳转到下一次迭代：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="c1">// 读取一些数据，一次读取一行
</span><span class="c1"></span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">input_lines</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">trimmed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">trim_comments_and_whitespace</span><span class="p">(</span><span class="n">line</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">trimmed</span><span class="p">.</span><span class="n">is_empty</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="c1">// 跳转到loop的开头并
</span><span class="c1"></span><span class="w">            </span><span class="c1">// 移动到下一行输入
</span><span class="c1"></span><span class="w">            </span><span class="k">continue</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="o">..</span><span class="p">.</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>在一个<code>for</code>循环中，<code>continue</code>会跳转到集合中的下一个值，如果没有值了，循环会停止。类似的，在一个<code>while</code>循环中<code>continue</code>会重新检查循环条件，如果现在是false，循环会停止。</p>
<p>一个循环可以用一个生命周期 <em>标记</em> 。在下面的例子中，<code>'search</code>是一个外层<code>for</code>循环的标签。因此<code>break 'search</code>会退出外层循环，而不是内层循环：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="o">&#39;</span><span class="na">search</span>:
    <span class="nc">for</span><span class="w"> </span><span class="n">room</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">apartment</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">spot</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">room</span><span class="p">.</span><span class="n">hiding_spots</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">spot</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;Your keys are {} in the {}.&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">spot</span><span class="p">,</span><span class="w"> </span><span class="n">room</span><span class="p">);</span><span class="w">
</span><span class="w">                </span><span class="k">break</span><span class="w"> </span><span class="nl">&#39;search</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>一个<code>break</code>可以同时带有一个标签和一个值表达式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="c1">// 寻找一列数中的第一个完全平方
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">sqrt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&#39;</span><span class="na">outer</span>: <span class="nc">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">next_number</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">square</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">square</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="c1">// 找到了一个平方根
</span><span class="c1"></span><span class="w">                </span><span class="k">break</span><span class="w"> </span><span class="nl">&#39;outer</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">square</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="c1">// `n`不是完全平方，尝试下一个数
</span><span class="c1"></span><span class="w">                </span><span class="k">break</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>标签也可以和<code>continue</code>一起使用。</p>
<h2 id="return表达式"><code>return</code>表达式</h2>
<p><code>return</code>表达式退出当前函数，向调用者返回一个值。</p>
<p>没有值的<code>return</code>相当于<code>return ()</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">f</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">    </span><span class="c1">// 返回类型被省略：默认是()
</span><span class="c1"></span><span class="w">        </span><span class="k">return</span><span class="p">;</span><span class="w"> </span><span class="c1">// 返回值被省略：默认是()
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>函数并不一定需要显式的<code>return</code>表达式。函数体就像是一个块表达式：如果最后一个表达式后边没有分号，它的值将是函数的返回值。事实上，这是在Rust中充当返回值的最佳方法。</p>
<p>但这并不意味着<code>return</code>就毫无作用，或者仅仅是为了符合不熟悉表达式语言的用户的习惯。类似于<code>break</code>表达式，<code>return</code>可以终止当前的工作。例如，在”第2章”中，在调用了一个可能会失败的函数之后，我们使用了<code>?</code>运算符来检查错误：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">create</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>我们解释过这是<code>match</code>表达式的缩写：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">File</span>::<span class="n">create</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这段代码首先调用<code>File::create(filename)</code>。如果返回<code>Ok(f)</code>，那么整个<code>match</code>表达式将求值为<code>f</code>，因此<code>f</code>被存储在<code>output</code>中，然后将继续执行<code>match</code>之后的代码。</p>
<p>否则， 我们会匹配到<code>Err(err)</code>，然后触发<code>return</code>表达式。此时我们正在求值一个<code>match</code>表达式，来决定变量<code>output</code>的值。但这都无所谓，我们会放弃所有任务，直接退出函数，并返回我们从<code>File::create()</code>得到的错误。</p>
<p>我们将在”传播错误”一节中详细介绍<code>?</code>运算符。</p>
<h2 id="rust为什么会有loop循环">Rust为什么会有loop循环</h2>
<p>Rust编译器的几个部分会检查整个程序中的控制流：</p>
<ul>
<li>Rust会检查一个函数里的所有返回路径是否返回相同类型的值。为了做到这一点，它需要知道控制流是否能到达函数结尾。</li>
<li>Rust会检查未初始化的局部变量是否绝不会被使用。这需要检查程序中的每一条路径来确保没有路径会到达未初始化的变量被使用的情况。</li>
<li>Rust会警告不可达的代码。函数中 <em>没有</em> 路径可以到达的代码就是不可达的代码。</li>
</ul>
<p>这些被称为 <em>控制流敏感(flow-sensitive)</em> 分析。这并不是新的概念，Java很多年前就有一个“确定性赋值(definite assignment)”的分析，和Rust的检查很相似。</p>
<p>当强迫执行这种规则时，一门语言（的编译器）必须在简洁和智能之间权衡。简洁可以让程序员更容易地理解编译器在说什么；智能则可以帮助消除错误警告和程序完全正确但编译器却报错的情况。Rust倾向于简洁，它的控制流敏感分析根本就不检查循环条件，而是假设程序中的所有条件都既可能是真又可能是假。</p>
<p>这导致Rust会拒绝编译这样的安全程序：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">wait_for_process</span><span class="p">(</span><span class="n">process</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Process</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">process</span><span class="p">.</span><span class="n">wait</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">process</span><span class="p">.</span><span class="n">exit_code</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">   </span><span class="c1">// 错误：不匹配的类型：期望i32，得到()
</span></code></pre></td></tr></table>
</div>
</div><p>这里的错误是假的。函数只可能通过<code>return</code>表达式返回，因此<code>while</code>循环不会产生<code>i32</code>值是无关紧要的。</p>
<p>而<code>loop</code>表达式作为一种“告诉编译器你的意思”的解决方案来解决这个问题。</p>
<p>Rust的类型系统也会被控制流影响。之前我们说过<code>if</code>表达式中的所有分支都必须有相同的类型。但如果在以<code>break</code>、<code>return</code>、<code>loop</code>表达式或对<code>panic!()</code>、<code>std::process::exit()</code>的调用作为结尾的块中强迫这个规则就会显得很愚蠢。这些表达式的共同点就是它们永远不会像正常的方式一样产生一个值：<code>break</code>或<code>return</code>会中断并退出当前的块、无限的<code>loop</code>循环则永远不会结束，等等。</p>
<p>因此在Rust中，这些表达式并没有通常的类型。不会正常结束的表达式会被赋予特殊类型<code>!</code>，并且它们不受类型必须匹配的规则的约束。 你可以在<code>std::process::exit()</code>的函数签名中看到<code>!</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">exit</span><span class="p">(</span><span class="n">code</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="o">!</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>!</code>意味着<code>exit()</code>永远不会返回，它是一个 <em>发散函数(divergent function)</em> 。</p>
<p>你可以用相同的语法编写自己的发散函数，在某些情况下这会显得非常自然：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">serve_forever</span><span class="p">(</span><span class="n">socket</span>: <span class="nc">ServerSocket</span><span class="p">,</span><span class="w"> </span><span class="n">handler</span>: <span class="nc">ServerHandler</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">socket</span><span class="p">.</span><span class="n">listen</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">socket</span><span class="p">.</span><span class="n">accept</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="n">handler</span><span class="p">.</span><span class="n">handle</span><span class="p">(</span><span class="n">s</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>当然，如果函数能正常返回的话，Rust会认为这是一个错误。</p>
<p>有了这些大规模控制流的构建块之后，我们可以继续分析常用的更细粒度的表达式，例如函数调用和算术运算。</p>
<h2 id="函数和方法调用">函数和方法调用</h2>
<p>在Rust中调用函数的方法的语法和许多其它语言一样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gcd</span><span class="p">(</span><span class="mi">1302</span><span class="p">,</span><span class="w"> </span><span class="mi">462</span><span class="p">);</span><span class="w">         </span><span class="c1">// 函数调用
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">room</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">player</span><span class="p">.</span><span class="n">location</span><span class="p">();</span><span class="w">   </span><span class="c1">// 方法调用
</span></code></pre></td></tr></table>
</div>
</div><p>在第二个例子中，<code>player</code>是一个编造的<code>Player</code>类型的变量，它有一个<code>.location()</code>方法。（我们将在”第9章”中讨论自定义类型时展示如何定义自己的方法。）</p>
<p>Rust通常会严格区分引用和它指向的值。如果你向接收<code>i32</code>的函数传递<code>&amp;i32</code>，将会引发类型错误。不过你会注意到<code>.</code>运算符放宽了这个限制，在方法调用<code>player.location()</code>中，<code>player</code>可以是一个<code>Player</code>、也可以是一个引用类型<code>&amp;Player</code>、也可以是智能指针类型<code>Box&lt;Player&gt;</code>或者<code>Rc&lt;Player&gt;</code>。<code>.location()</code>方法可能会以值也可能会以引用获取参数，同样的<code>.location()</code>语法可以适用于所有情况，因为Rust的<code>.</code>运算符会根据需要自动解引用<code>player</code>或者获取它的引用。</p>
<p>第三种语法用于调用类型关联函数，例如<code>Vec::new()</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">numbers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span><span class="w">   </span><span class="c1">// 类型关联函数调用
</span></code></pre></td></tr></table>
</div>
</div><p>这类似于面向对象语言中的静态方法，方法在值上调用（例如<code>my_vec.len()</code>），而类型关联函数在类型上调用（例如<code>Vec::new()</code>）。</p>
<p>当然，方法调用可以被串联起来：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="c1">// 取自于第二章的Actix-based web server
</span><span class="c1"></span><span class="w">    </span><span class="n">server</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">bind</span><span class="p">(</span><span class="s">&#34;127.0.0.1:3000&#34;</span><span class="p">).</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;error binding server to address&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">run</span><span class="p">().</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;error running server&#34;</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>Rust语法中的一个怪异之处是，不能按照泛型类型的通常语法例如<code>Vec&lt;T&gt;</code>来调用函数或者方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span>::<span class="n">with_capacity</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span><span class="w">   </span><span class="c1">// error: something about chained comparisons
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ramp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="n">n</span><span class="p">).</span><span class="n">collect</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;&gt;</span><span class="p">();</span><span class="w">    </span><span class="c1">// 同样的错误
</span></code></pre></td></tr></table>
</div>
</div><p>问题在于这个表达式中的<code>&lt;</code>被当作小于运算符。Rust编译器会建议使用<code>::&lt;T&gt;</code>来代替<code>&lt;T&gt;</code>，这样可以解决这个问题：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">Vec</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span>::<span class="n">with_capacity</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span><span class="w"> </span><span class="c1">// ok, using ::&lt;
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ramp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="n">n</span><span class="p">).</span><span class="n">collect</span>::<span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;&gt;</span><span class="p">();</span><span class="w"> </span><span class="c1">// ok, using ::&lt;
</span></code></pre></td></tr></table>
</div>
</div><p>符号<code>::&lt;...&gt;</code>在Rust中被亲切地称为 <em>turbofish</em> 。</p>
<p>另外，通常也可以省略类型参数，让Rust推断它们：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">with_capacity</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span><span class="w">  </span><span class="c1">// ok, 如果函数的返回类型是Vec&lt;i32&gt;
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ramp</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="n">n</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w"> </span><span class="c1">// ok, 指定了变量的类型
</span></code></pre></td></tr></table>
</div>
</div><p>在可以推断出类型时省略类型是一种好的风格。</p>
<h2 id="字段和元素">字段和元素</h2>
<p>访问结构体中字段的语法大家都很熟悉，元组也一样，不过元组中的字段是数字而不是名称：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="n">game</span><span class="p">.</span><span class="n">black_pawns</span><span class="w">    </span><span class="c1">// 结构体字段
</span><span class="c1"></span><span class="w">    </span><span class="n">coords</span><span class="p">.</span><span class="mi">1</span><span class="w">            </span><span class="c1">// 元组元素
</span></code></pre></td></tr></table>
</div>
</div><p>如果点左边的值是引用或者智能指针类型，它也会像方法调用一样自动解引用。</p>
<p>方括号可以访问数组、切片或vector中的元素：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="n">pieces</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w">           </span><span class="c1">// 数组元素
</span></code></pre></td></tr></table>
</div>
</div><p>方括号左侧的值也会自动解引用。</p>
<p>类似于这三种的表达式被称为 <em>左值</em> ，因为它们可以出现在赋值表达式的左边：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="n">game</span><span class="p">.</span><span class="n">black_pawns</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00ff0000_00000000_</span><span class="k">u64</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">coords</span><span class="p">.</span><span class="mi">1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">pieces</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">Piece</span>::<span class="n">new</span><span class="p">(</span><span class="n">Black</span><span class="p">,</span><span class="w"> </span><span class="n">Knight</span><span class="p">,</span><span class="w"> </span><span class="n">coords</span><span class="p">));</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>当然，只有当<code>game</code>、<code>coords</code>和<code>pieces</code>被声明为<code>mut</code>变量时才可以这么做。</p>
<p>从一个数组或者vector中提取切片非常直观：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">second_half</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">game_moves</span><span class="p">[</span><span class="n">midpoint</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="n">end</span><span class="p">];</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这里<code>game_moves</code>可能是一个数组、切片或者是vector，结果将是一个长度为<code>end - midpoint</code>的切片，在<code>second_half</code>的生命周期内<code>game_moves</code>都处于被借用的状态。</p>
<p><code>..</code>运算符允许任意一边的操作数被省略，根据两边是否有操作数，它可以被划分为四种形式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="o">..</span><span class="w">      </span><span class="c1">// 全部范围
</span><span class="c1"></span><span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="o">..</span><span class="w">    </span><span class="c1">// 起点范围 { start: a }
</span><span class="c1"></span><span class="w">    </span><span class="o">..</span><span class="w"> </span><span class="n">b</span><span class="w">    </span><span class="c1">// 终点范围 { end: b }
</span><span class="c1"></span><span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="n">b</span><span class="w">  </span><span class="c1">// 范围 { start: a, end: b }
</span></code></pre></td></tr></table>
</div>
</div><p>后两种形式是 <em>end-exclusive(右开区间)</em> ：终点值将不会被包含。例如，范围<code>0 .. 3</code>包括数字<code>0</code>、<code>1</code>、<code>2</code>。</p>
<p><code>..=</code>运算符产生 <em>end-inclusive(闭区间)</em> 范围，它会包含终点值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="o">..=</span><span class="w"> </span><span class="n">b</span><span class="w">       </span><span class="c1">// RangeToInclusive { end: b }
</span><span class="c1"></span><span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="o">..=</span><span class="w"> </span><span class="n">b</span><span class="w">     </span><span class="c1">// RangeInclusive::new(a, b)
</span></code></pre></td></tr></table>
</div>
</div><p>例如，范围<code>0 ..= 3</code>包含数字<code>0</code>、<code>1</code>、<code>2</code>、<code>3</code>。</p>
<p>只有包含start值的范围才可以迭代，因为一个循环必须有开始的地方。但在数组切片中，所有的六种形式都是有用的。如果起始值或终点值被省略了，将默认包含数组从起点开始的元素或者直到终点的元素。</p>
<p>因此快速排序的一个实现，经典的分治排序算法，将类似于这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="k">fn</span> <span class="nf">quicksort</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Ord</span><span class="o">&gt;</span><span class="p">(</span><span class="n">slice</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="n">T</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">slice</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">return</span><span class="p">;</span><span class="w"> </span><span class="c1">// 切片为空，不需要排序
</span><span class="c1"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="c1">// 将切片分为两个部分，前半部分和后半部分
</span><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">pivot_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">partition</span><span class="p">(</span><span class="n">slice</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="c1">// 递归排序`slice`的前半部分
</span><span class="c1"></span><span class="w">        </span><span class="n">quicksort</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">slice</span><span class="p">[</span><span class="o">..</span><span class="w"> </span><span class="n">pivot_index</span><span class="p">]);</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="c1">// 再排序后半部分
</span><span class="c1"></span><span class="w">        </span><span class="n">quicksort</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">slice</span><span class="p">[</span><span class="n">pivot_index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">..</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h2 id="引用运算符">引用运算符</h2>
<p>取地址运算符<code>&amp;</code>和<code>&amp;mut</code>，已经在”第5章”中介绍过了。</p>
<p>一元<code>*</code>运算符用于获取引用指向的值。正如我们看到的，当你使用<code>.</code>运算符访问字段或者方法时，Rust会自动解引用。因此只有在我们想读取或写入引用指向的整个值时，<code>*</code>运算符才是必须的。</p>
<p>例如，有时迭代器会产生引用，但程序需要底层的类型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">padovan</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u64</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">compute_padovan_sequence</span><span class="p">(</span><span class="n">n</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">elem</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="n">padovan</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">draw_triangle</span><span class="p">(</span><span class="n">turtle</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">elem</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>在这个例子中，<code>elem</code>的类型是<code>&amp;u64</code>，因此<code>*elem</code>是一个<code>u64</code>值。</p>
<h2 id="算术位运算比较逻辑运算符">算术、位运算、比较、逻辑运算符</h2>
<p>Rust的二元运算符和其他语言中的很像。为了节省时间，我们假设你熟悉这些语言中的一种，并只专注于Rust中背离传统的点。</p>
<p>Rust有通常的算术运算符<code>+, -, *, /, %</code>。正如在”第3章”中说过的一样，整数溢出会被检测到，并在debug模式下造成panic。标准库提供类似<code>a.wrapping_add(b)</code>的方法来执行不检查溢出的算术。</p>
<p>整数除法会向0舍入，并且整数除以0时即使在release模式也会导致panic。整数有一个<code>a.checked_div(b)</code>方法会返回<code>Option</code>(如果<code>b</code>是0时为<code>None</code>)，而不会panic。</p>
<p>一元的<code>-</code>运算符用于求负数，它支持除无符号整数外所有的数字类型。没有一元的<code>+</code>运算符：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">100</span><span class="p">);</span><span class="w">       </span><span class="c1">// -100
</span><span class="c1"></span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">100</span><span class="k">u32</span><span class="p">);</span><span class="w">    </span><span class="c1">// 错误：一元`-`不能用于类型`u32`
</span><span class="c1"></span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">+</span><span class="mi">100</span><span class="p">);</span><span class="w">       </span><span class="c1">// 错误：期望表达式，发现`+`
</span></code></pre></td></tr></table>
</div>
</div><p>和在C中一样，<code>a % b</code>会计算有符号的余数，或者叫取模。结果和左侧的操作数符号一致。注意<code>%</code>也可以像整数一样用于浮点数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1234.567</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mf">10.0</span><span class="p">;</span><span class="w">    </span><span class="c1">// 约为4.567
</span></code></pre></td></tr></table>
</div>
</div><p>Rust还继承了C的整数的位运算符<code>&amp;, |, ^, &lt;&lt;, &gt;&gt;</code>。然而，Rust使用<code>!</code>而不是<code>~</code>来表示按位取反：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">hi</span>: <span class="kt">u8</span> <span class="o">=</span><span class="w"> </span><span class="mh">0xe0</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">lo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">!</span><span class="n">hi</span><span class="p">;</span><span class="w">   </span><span class="c1">// 0x1f
</span></code></pre></td></tr></table>
</div>
</div><p>这意味着<code>!n</code>不能用来判断<code>n</code>是否为0，必须使用<code>n == 0</code>。</p>
<p>有符号整数的位移总是符号扩展，无符号整数的位移的位移总是0扩展。因为Rust有无符号整数，所以不需要像Java中的<code>&gt;&gt;&gt;</code>一样的无符号移位运算符。</p>
<p>和C语言不同的是，位运算符比比较运算的优先级更高，因此如果你写<code>x &amp; BIT != 0</code>，意味着<code>(x &amp; BIT) != 0</code>。这比C中的含义更有用，C中将是<code>x &amp; (BIT != 0)</code>。</p>
<p>Rust的比较运算符是<code>==, !=, &lt;, &lt;=, &gt;, &gt;=</code>。比较的两个值类型必须相同。</p>
<p>Rust也有短路求值的<code>&amp;&amp;</code>和<code>||</code>运算符，所有的操作数必须都是<code>bool</code>类型。</p>
<h2 id="赋值">赋值</h2>
<p><code>=</code>运算符可以用于给<code>mut</code>变量或它们的字段或元素赋值。但在Rust中赋值行为并不像在其他语言中那么普遍，因为变量默认是不可变的。</p>
<p>正如在”第4章”介绍的那样，如果变量是non-<code>Copy</code>类型，赋值行为将会把它的值 <em>移动</em> 到目标变量。值的所有权从源对象移动到目的对象，目的对象之前的值会被丢弃。</p>
<p>也可以使用复合赋值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="n">total</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">item</span><span class="p">.</span><span class="n">price</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这等价于<code>total = total + item.price;</code>。还支持其他的运算符例如：<code>-=, *=</code>等。完整的运算符支持在”表6-1”中列出。</p>
<p>和C不同，Rust不支持链式赋值：你不能写<code>a = b = 3</code>来把<code>3</code>同时赋给<code>a</code>和<code>b</code>。在Rust中赋值很罕见，所以你不会怀念这种缩写的。</p>
<p>Rust不支持C的自增和自减运算符<code>++</code>和<code>--</code>。</p>
<h2 id="类型转换">类型转换</h2>
<p>在Rust中把一个类型转换为另一个类型通常需要显式的转换。使用<code>as</code>关键字来进行转换：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">17</span><span class="p">;</span><span class="w">             </span><span class="c1">// x是i32类型
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">;</span><span class="w"> </span><span class="c1">// 转换为usize
</span></code></pre></td></tr></table>
</div>
</div><p>Rust允许以下几种转换：</p>
<ul>
<li>
<p>任何内建的数字类型可以彼此转换。</p>
<p>将一个整数转换为另一个整数总是良定义的。转换为更小的类型会导致截断，有符号数转换为更大的类型会进行符号扩展，无符号数是0扩展，等等。总而言之，没有意外的行为。</p>
<p>浮点数转换为整数会向0舍入：值<code>-1.99</code>转换为<code>i32</code>是<code>-1</code>。如果值太大不能用整数类型表示，转换会返回整数类型能表示的最接近真实值的值：值<code>1e6</code>转换为<code>u8</code>是<code>255</code>。</p>
</li>
<li>
<p><code>bool</code>、<code>char</code>、或者类似C的<code>enum</code>类型可以转换为任意整数类型（我们将在”第10章”中介绍枚举）。</p>
<p>其他方向的转换是不允许的，因为<code>bool</code>、<code>char</code>和<code>enum</code>都对它们的值有严格的要求，必须要进行运行时检查。例如，将一个<code>u16</code>数字转换为<code>char</code>类型是禁止的，因为一些<code>u16</code>值例如<code>0xd800</code>，对应Unicode的代理码点，因此不是有效的<code>char</code>类型值。有一个标准的方法<code>std::char::from_u32()</code>来进行运行时检查并返回<code>Option&lt;char&gt;</code>。但需要指出的是，这种转换的需求非常少见。我们通常一次转换整个字符串或流，有关Unicode文本的算法通常是非平凡的，最好留给库来实现。</p>
<p>一个例外是，<code>u8</code>可以转换为<code>char</code>类型，因为0到255之间的所有整数都是有效的Unicode码点。</p>
</li>
<li>
<p>一些涉及unsafe指针类型的转换也是允许的。见”原始指针”一节。</p>
</li>
</ul>
<p>我们说转换 <em>通常</em> 需要显式的转换。但少数涉及引用类型的转换非常直观以至于语言可以自动完成而不需要显式转换。一个小例子是把<code>mut</code>引用转换为non-<code>mut</code>引用。</p>
<p>还有一些更重要的自动转换可能发生：</p>
<ul>
<li><code>&amp;String</code>类型的值可以自动转换为<code>&amp;str</code>类型。</li>
<li><code>&amp;Vec&lt;i32&gt;</code>类型的值可以自动转换为<code>&amp;[i32]</code>。</li>
<li><code>&amp;Box&lt;Chessboard&gt;</code>类型的值可以自动转换为<code>&amp;Chessboard</code>。</li>
</ul>
<p>这些被称为 <em>强制解引用(deref coercions)</em> ，因为它们适用于实现了内建的<code>Deref</code> trait的类型。<code>Deref</code>是为了智能指针类型设计的，例如<code>Box</code>，它的行为尽量和和底层的值类型保持一致。得益于<code>Deref</code>，使用<code>Box&lt;Chessboard&gt;</code>非常像在使用一个普通的<code>Chessboard</code>。</p>
<p>用户自定义的类型也可以实现<code>Deref</code> trait。当你需要编写自己的智能指针类型时，见”Deref和DerefMut”一节。</p>
<h2 id="闭包">闭包</h2>
<p>Rust支持 <em>闭包</em> ：一种轻量的类似函数的值。一个闭包通常由被竖线包围的参数列表和一个表达式组成：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">is_even</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>Rust会自动推导参数类型和返回值类型。你可以显式写出它们，就像写函数签名一样。如果你指定了返回值类型，那么为了语法的健全，闭包的主体必须是一个块：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">is_even</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">x</span>: <span class="kt">u64</span><span class="o">|</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="nc">x</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="c1">// error
</span><span class="c1"></span><span class="w">    
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">is_even</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">x</span>: <span class="kt">u64</span><span class="o">|</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">};</span><span class="w">  </span><span class="c1">// ok
</span></code></pre></td></tr></table>
</div>
</div><p>调用一个闭包和调用函数的语法相同：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">is_even</span><span class="p">(</span><span class="mi">14</span><span class="p">),</span><span class="w"> </span><span class="kc">true</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>闭包是Rust中最令人愉快的特性之一，关于它有很多内容可以说，我们将在”第14章”中介绍。</p>
<h2 id="继续">继续</h2>
<p>表达式是“要运行的代码(running code)”。它们是Rust中要被编译为机器指令的一部分。然而它们只是整个语言的一小部分。</p>
<p>大多数其他语言也是这样。一个程序的第一个任务是运行起来，但这并不是它唯一的任务。程序之间必须交流，它们也必须可以测试，它们还需要保持有序和灵活以便继续改进，它们必须与其它队伍构建的代码和服务进行互操作。而且即使只是为了运行，像Rust这样的典型的静态语言的程序也需要更多的工具来组织数据。</p>
<p>接下来，我们将用数个章节讨论这些领域：让你的程序变得结构化的模块和crate、让你的数据变得结构化的结构体和枚举。</p>
<p>首先，我们将花费一些篇幅来介绍一个非常重要的话题：错误处理。</p>
<div class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn:1" role="doc-endnote">
<p>译者注：7月不是曲棍球赛季？&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

    </div>
<div class="post_comments">
  
  
  
</div>




    <hr>

<div id="gitalk-container"></div>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js" crossorigin="anonymous"></script>
    <script type="text/javascript">
      var gitalk = new Gitalk({
        id: '0001-01-01 00:00:00 \u002b0000 UTC',
        title: '',
        clientID: '72786bf87c19beec6abe',
        clientSecret: '93ce647699b49ea6434332d36b0122a4ad8281ad',
        repo: 'buf1024.github.io',
        owner: 'buf1024',
        admin: ['buf1024'],
        body: decodeURI(location.href)
      });
      gitalk.render('gitalk-container');
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/gitalk/gitalk">comments powered by gitalk.</a></noscript>

  </article>
<aside class="sidebar">
  <section class="sidebar_inner">
    <br>
    


    
    
    <h2 class="mt-4">最新文章</h2>
    <ul class="flex-column">
      <li>
        <a href="https://luoguochun.cn/post/2024-01-13-rust-sqlx-sqlbuilder/" class="nav-link" title="Rust sqlx SQLBuilder">Rust sqlx SQLBuilder</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2024-01-08-vite-engineering-config/" class="nav-link" title="前端工程化配置保姆级教程">前端工程化配置保姆级教程</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-12-26-rust-proc-macro/" class="nav-link" title="rust 过程宏">rust 过程宏</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-09-21-rust-panic/" class="nav-link" title="一行代码让 rustc panic">一行代码让 rustc panic</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-07-19-flutter-muti-window/" class="nav-link" title="Flutter 桌面端多窗口支持">Flutter 桌面端多窗口支持</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-07-04-hiqradio/" class="nav-link" title="hiqradio 一个简单的收音机软件">hiqradio 一个简单的收音机软件</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-03-21-android-https/" class="nav-link" title="android https 抓包">android https 抓包</a>
      </li>
      <li>
        <a href="https://luoguochun.cn/post/2023-03-16-love-for-insterest/" class="nav-link" title="为爱发电终是不能长久的……">为爱发电终是不能长久的……</a>
      </li>
    </ul>
    <div>
      <h2 class="mt-4 taxonomy" id="categories-section">分类</h2>
      <nav class="tags_nav">
        <a href='https://luoguochun.cn/categories/misc/' class="post_tag button button_translucent" title="misc">
          MISC
          <span class="button_tally">11</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/linux/' class="post_tag button button_translucent" title="linux">
          LINUX
          <span class="button_tally">8</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/tcp/' class="post_tag button button_translucent" title="tcp">
          TCP
          <span class="button_tally">8</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/c/' class="post_tag button button_translucent" title="c">
          C
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/flutter/' class="post_tag button button_translucent" title="flutter">
          FLUTTER
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/rust/' class="post_tag button button_translucent" title="rust">
          RUST
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/python/' class="post_tag button button_translucent" title="python">
          PYTHON
          <span class="button_tally">6</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/c&#43;&#43;/' class="post_tag button button_translucent" title="c&#43;&#43;">
          C&#43;&#43;
          <span class="button_tally">4</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/web/' class="post_tag button button_translucent" title="web">
          WEB
          <span class="button_tally">4</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/gcc/' class="post_tag button button_translucent" title="gcc">
          GCC
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/git/' class="post_tag button button_translucent" title="git">
          GIT
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/reactjs/' class="post_tag button button_translucent" title="reactjs">
          REACTJS
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/unittest/' class="post_tag button button_translucent" title="unittest">
          UNITTEST
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/vim/' class="post_tag button button_translucent" title="vim">
          VIM
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/%E6%9E%84%E6%9E%B6/' class="post_tag button button_translucent" title="构架">
          构架
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/asm/' class="post_tag button button_translucent" title="asm">
          ASM
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/docker/' class="post_tag button button_translucent" title="docker">
          DOCKER
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/categories/go/' class="post_tag button button_translucent" title="go">
          GO
          <span class="button_tally">1</span>
        </a>
        
        
      </nav>
    </div>
    <div>
      <h2 class="mt-4 taxonomy" id="tags-section">标签</h2>
      <nav class="tags_nav">
        <a href='https://luoguochun.cn/tags/c/' class="post_tag button button_translucent" title="c">
          C
          <span class="button_tally">21</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/linux/' class="post_tag button button_translucent" title="linux">
          LINUX
          <span class="button_tally">16</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/c&#43;&#43;/' class="post_tag button button_translucent" title="c&#43;&#43;">
          C&#43;&#43;
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/python/' class="post_tag button button_translucent" title="python">
          PYTHON
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/tcp/' class="post_tag button button_translucent" title="tcp">
          TCP
          <span class="button_tally">7</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/dart/' class="post_tag button button_translucent" title="dart">
          DART
          <span class="button_tally">6</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/flutter/' class="post_tag button button_translucent" title="flutter">
          FLUTTER
          <span class="button_tally">6</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/rust/' class="post_tag button button_translucent" title="rust">
          RUST
          <span class="button_tally">4</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/tdd/' class="post_tag button button_translucent" title="tdd">
          TDD
          <span class="button_tally">4</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/android/' class="post_tag button button_translucent" title="android">
          ANDROID
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/git/' class="post_tag button button_translucent" title="git">
          GIT
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/gtest/' class="post_tag button button_translucent" title="gtest">
          GTEST
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/js/' class="post_tag button button_translucent" title="js">
          JS
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/rust-lib/' class="post_tag button button_translucent" title="rust-lib">
          RUST-LIB
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/vcs/' class="post_tag button button_translucent" title="vcs">
          VCS
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/vim/' class="post_tag button button_translucent" title="vim">
          VIM
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/asm/' class="post_tag button button_translucent" title="asm">
          ASM
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/css/' class="post_tag button button_translucent" title="css">
          CSS
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/gas/' class="post_tag button button_translucent" title="gas">
          GAS
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/gcc/' class="post_tag button button_translucent" title="gcc">
          GCC
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/http/' class="post_tag button button_translucent" title="http">
          HTTP
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/libevent/' class="post_tag button button_translucent" title="libevent">
          LIBEVENT
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/macos/' class="post_tag button button_translucent" title="macos">
          MACOS
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/react-native/' class="post_tag button button_translucent" title="react-native">
          REACT-NATIVE
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/redis/' class="post_tag button button_translucent" title="redis">
          REDIS
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/%E6%9E%84%E6%9E%B6/' class="post_tag button button_translucent" title="构架">
          构架
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/api/' class="post_tag button button_translucent" title="api">
          API
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/bt/' class="post_tag button button_translucent" title="bt">
          BT
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/c&#43;/' class="post_tag button button_translucent" title="c&#43;">
          C&#43;
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/coroutine/' class="post_tag button button_translucent" title="coroutine">
          COROUTINE
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/database/' class="post_tag button button_translucent" title="database">
          DATABASE
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/docker/' class="post_tag button button_translucent" title="docker">
          DOCKER
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/endian/' class="post_tag button button_translucent" title="endian">
          ENDIAN
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/frontend/' class="post_tag button button_translucent" title="frontend">
          FRONTEND
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/gdb/' class="post_tag button button_translucent" title="gdb">
          GDB
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/go/' class="post_tag button button_translucent" title="go">
          GO
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/html/' class="post_tag button button_translucent" title="html">
          HTML
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/https/' class="post_tag button button_translucent" title="https">
          HTTPS
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/jquery/' class="post_tag button button_translucent" title="jquery">
          JQUERY
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/ld/' class="post_tag button button_translucent" title="ld">
          LD
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/logger/' class="post_tag button button_translucent" title="logger">
          LOGGER
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/makefile/' class="post_tag button button_translucent" title="makefile">
          MAKEFILE
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/misc/' class="post_tag button button_translucent" title="misc">
          MISC
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/orm/' class="post_tag button button_translucent" title="orm">
          ORM
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/os/' class="post_tag button button_translucent" title="os">
          OS
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/process/' class="post_tag button button_translucent" title="process">
          PROCESS
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/react/' class="post_tag button button_translucent" title="react">
          REACT
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/rpm/' class="post_tag button button_translucent" title="rpm">
          RPM
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/rsa/' class="post_tag button button_translucent" title="rsa">
          RSA
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/server/' class="post_tag button button_translucent" title="server">
          SERVER
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/sqlalchemy/' class="post_tag button button_translucent" title="sqlalchemy">
          SQLALCHEMY
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/ssh/' class="post_tag button button_translucent" title="ssh">
          SSH
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/ssl/tls/' class="post_tag button button_translucent" title="ssl/tls">
          SSL/TLS
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/vc/' class="post_tag button button_translucent" title="vc">
          VC
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/vite/' class="post_tag button button_translucent" title="vite">
          VITE
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/vue/' class="post_tag button button_translucent" title="vue">
          VUE
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/webui/' class="post_tag button button_translucent" title="webui">
          WEBUI
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/wechat/' class="post_tag button button_translucent" title="wechat">
          WECHAT
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/win32/' class="post_tag button button_translucent" title="win32">
          WIN32
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/windows/' class="post_tag button button_translucent" title="windows">
          WINDOWS
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/wireshark/' class="post_tag button button_translucent" title="wireshark">
          WIRESHARK
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://luoguochun.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/' class="post_tag button button_translucent" title="微服务">
          微服务
          <span class="button_tally">1</span>
        </a>
        
        
      </nav>
    </div>
  </section>
</aside>

  
</div>
  </main><svg width="0" height="0" class="hidden">
  <symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="facebook">
    <path d="M437 0H75C33.648 0 0 33.648 0 75v362c0 41.352 33.648 75 75 75h151V331h-60v-90h60v-61c0-49.629 40.371-90 90-90h91v90h-91v61h91l-15 90h-76v181h121c41.352 0 75-33.648 75-75V75c0-41.352-33.648-75-75-75zm0 0"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18.001 18.001" id="twitter">
    <path d="M15.891 4.013c.808-.496 1.343-1.173 1.605-2.034a8.68 8.68 0 0 1-2.351.861c-.703-.756-1.593-1.14-2.66-1.14-1.043 0-1.924.366-2.643 1.078a3.56 3.56 0 0 0-1.076 2.605c0 .309.039.585.117.819-3.076-.105-5.622-1.381-7.628-3.837-.34.601-.51 1.213-.51 1.846 0 1.301.549 2.332 1.645 3.089-.625-.053-1.176-.211-1.645-.47 0 .929.273 1.705.82 2.388a3.623 3.623 0 0 0 2.115 1.291c-.312.08-.641.118-.979.118-.312 0-.533-.026-.664-.083.23.757.664 1.371 1.291 1.841a3.652 3.652 0 0 0 2.152.743C4.148 14.173 2.625 14.69.902 14.69c-.422 0-.721-.006-.902-.038 1.697 1.102 3.586 1.649 5.676 1.649 2.139 0 4.029-.542 5.674-1.626 1.645-1.078 2.859-2.408 3.639-3.974a10.77 10.77 0 0 0 1.172-4.892v-.468a7.788 7.788 0 0 0 1.84-1.921 8.142 8.142 0 0 1-2.11.593z"
      ></path>
  </symbol>
  <symbol aria-hidden="true" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="mail">
    <path  d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="calendar">
    <path d="M452 40h-24V0h-40v40H124V0H84v40H60C26.916 40 0 66.916 0 100v352c0 33.084 26.916 60 60 60h392c33.084 0 60-26.916 60-60V100c0-33.084-26.916-60-60-60zm20 412c0 11.028-8.972 20-20 20H60c-11.028 0-20-8.972-20-20V188h432v264zm0-304H40v-48c0-11.028 8.972-20 20-20h24v40h40V80h264v40h40V80h24c11.028 0 20 8.972 20 20v48z"></path>
    <path d="M76 230h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zM76 310h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zM76 390h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zm80-80h40v40h-40z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="github">
    <path d="M255.968 5.329C114.624 5.329 0 120.401 0 262.353c0 113.536 73.344 209.856 175.104 243.872 12.8 2.368 17.472-5.568 17.472-12.384 0-6.112-.224-22.272-.352-43.712-71.2 15.52-86.24-34.464-86.24-34.464-11.616-29.696-28.416-37.6-28.416-37.6-23.264-15.936 1.728-15.616 1.728-15.616 25.696 1.824 39.2 26.496 39.2 26.496 22.848 39.264 59.936 27.936 74.528 21.344 2.304-16.608 8.928-27.936 16.256-34.368-56.832-6.496-116.608-28.544-116.608-127.008 0-28.064 9.984-51.008 26.368-68.992-2.656-6.496-11.424-32.64 2.496-68 0 0 21.504-6.912 70.4 26.336 20.416-5.696 42.304-8.544 64.096-8.64 21.728.128 43.648 2.944 64.096 8.672 48.864-33.248 70.336-26.336 70.336-26.336 13.952 35.392 5.184 61.504 2.56 68 16.416 17.984 26.304 40.928 26.304 68.992 0 98.72-59.84 120.448-116.864 126.816 9.184 7.936 17.376 23.616 17.376 47.584 0 34.368-.32 62.08-.32 70.496 0 6.88 4.608 14.88 17.6 12.352C438.72 472.145 512 375.857 512 262.353 512 120.401 397.376 5.329 255.968 5.329z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 212 212" id="gitlab">
    <path d="M12.3 74.7h54L43.3 3c-1-3.6-6.4-3.6-7.6 0L12.3 74.8z" />
    <path d="M12.3 74.7L.5 111c-1 3.2 0 6.8 3 8.8l101.6 74-92.5-119z"/>
    <path d="M105 193.7l-38.6-119h-54l92.7 119z"/>
    <path d="M105 193.7l38.7-119H66.4l38.7 119z"/>
    <path d="M105 193.7l38.7-119H198l-93 119z"/>
    <path d="M198 74.7l11.6 36.2c1 3 0 6.6-3 8.6l-101.5 74 93-119z"/>
    <path d="M198 74.7h-54.3L167 3c1.2-3.6 6.4-3.6 7.6 0L198 74.8z"/>
  </symbol>
  <symbol viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="rss">
    <circle cx="3.429" cy="20.571" r="3.429"></circle>
    <path d="M11.429 24h4.57C15.999 15.179 8.821 8.001 0 8v4.572c6.302.001 11.429 5.126 11.429 11.428z"></path>
    <path d="M24 24C24 10.766 13.234 0 0 0v4.571c10.714 0 19.43 8.714 19.43 19.429z"></path>
  </symbol>
  <symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="linkedin">
    <path d="M437 0H75C33.648 0 0 33.648 0 75v362c0 41.352 33.648 75 75 75h362c41.352 0 75-33.648 75-75V75c0-41.352-33.648-75-75-75zM181 406h-60V196h60zm0-240h-60v-60h60zm210 240h-60V286c0-16.54-13.46-30-30-30s-30 13.46-30 30v120h-60V196h60v11.309C286.719 202.422 296.93 196 316 196c40.691.043 75 36.547 75 79.688zm0 0"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 612 612" id="to-top">
    <path d="M604.501 440.509L325.398 134.956c-5.331-5.357-12.423-7.627-19.386-7.27-6.989-.357-14.056 1.913-19.387 7.27L7.499 440.509c-9.999 10.024-9.999 26.298 0 36.323s26.223 10.024 36.222 0l262.293-287.164L568.28 476.832c9.999 10.024 26.222 10.024 36.221 0 9.999-10.023 9.999-26.298 0-36.323z"></path>
  </symbol>
  <symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="carly">
    <path d="M504.971 239.029L448 182.059V84c0-46.317-37.682-84-84-84h-44c-13.255 0-24 10.745-24 24s10.745 24 24 24h44c19.851 0 36 16.149 36 36v108c0 6.365 2.529 12.47 7.029 16.971L454.059 256l-47.029 47.029A24.002 24.002 0 0 0 400 320v108c0 19.851-16.149 36-36 36h-44c-13.255 0-24 10.745-24 24s10.745 24 24 24h44c46.318 0 84-37.683 84-84v-98.059l56.971-56.971c9.372-9.372 9.372-24.568 0-33.941zM112 192V84c0-19.851 16.149-36 36-36h44c13.255 0 24-10.745 24-24S205.255 0 192 0h-44c-46.318 0-84 37.683-84 84v98.059l-56.971 56.97c-9.373 9.373-9.373 24.568 0 33.941L64 329.941V428c0 46.317 37.682 84 84 84h44c13.255 0 24-10.745 24-24s-10.745-24-24-24h-44c-19.851 0-36-16.149-36-36V320c0-6.365-2.529-12.47-7.029-16.971L57.941 256l47.029-47.029A24.002 24.002 0 0 0 112 192z"></path>
  </symbol>
  <symbol viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="copy">
    <path d="M23 2.75A2.75 2.75 0 0 0 20.25 0H8.75A2.75 2.75 0 0 0 6 2.75v13.5A2.75 2.75 0 0 0 8.75 19h11.5A2.75 2.75 0 0 0 23 16.25zM18.25 14.5h-7.5a.75.75 0 0 1 0-1.5h7.5a.75.75 0 0 1 0 1.5zm0-3h-7.5a.75.75 0 0 1 0-1.5h7.5a.75.75 0 0 1 0 1.5zm0-3h-7.5a.75.75 0 0 1 0-1.5h7.5a.75.75 0 0 1 0 1.5z"></path>
    <path d="M8.75 20.5a4.255 4.255 0 0 1-4.25-4.25V2.75c0-.086.02-.166.025-.25H3.75A2.752 2.752 0 0 0 1 5.25v16A2.752 2.752 0 0 0 3.75 24h12a2.752 2.752 0 0 0 2.75-2.75v-.75z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512.001 512.001" id="closeme">
    <path d="M284.286 256.002L506.143 34.144c7.811-7.811 7.811-20.475 0-28.285-7.811-7.81-20.475-7.811-28.285 0L256 227.717 34.143 5.859c-7.811-7.811-20.475-7.811-28.285 0-7.81 7.811-7.811 20.475 0 28.285l221.857 221.857L5.858 477.859c-7.811 7.811-7.811 20.475 0 28.285a19.938 19.938 0 0 0 14.143 5.857 19.94 19.94 0 0 0 14.143-5.857L256 284.287l221.857 221.857c3.905 3.905 9.024 5.857 14.143 5.857s10.237-1.952 14.143-5.857c7.811-7.811 7.811-20.475 0-28.285L284.286 256.002z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="open-menu">
    <path d="M492 236H20c-11.046 0-20 8.954-20 20s8.954 20 20 20h472c11.046 0 20-8.954 20-20s-8.954-20-20-20zm0-160H20C8.954 76 0 84.954 0 96s8.954 20 20 20h472c11.046 0 20-8.954 20-20s-8.954-20-20-20zm0 320H20c-11.046 0-20 8.954-20 20s8.954 20 20 20h472c11.046 0 20-8.954 20-20s-8.954-20-20-20z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="instagram">
    <path d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948 0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072 3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.163 6.162 6.163 6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zm0 10.162c-2.209 0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796 0-1.441.645-1.441 1.44s.645 1.44 1.441 1.44c.795 0 1.439-.645 1.439-1.44s-.644-1.44-1.439-1.44z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id=youtube>
    <path d="M19.615 3.184c-3.604-.246-11.631-.245-15.23 0-3.897.266-4.356 2.62-4.385 8.816.029 6.185.484 8.549 4.385 8.816 3.6.245 11.626.246 15.23 0 3.897-.266 4.356-2.62 4.385-8.816-.029-6.185-.484-8.549-4.385-8.816zm-10.615 12.816v-8l8 3.993-8 4.007z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="stackoverflow">
    <path d="M21 27v-8h3v11H0V19h3v8h18z"></path><path d="M17.1.2L15 1.8l7.9 10.6 2.1-1.6L17.1.2zm3.7 14.7L10.6 6.4l1.7-2 10.2 8.5-1.7 2zM7.2 12.3l12 5.6 1.1-2.4-12-5.6-1.1 2.4zm-1.8 6.8l13.56 1.96.17-2.38-13.26-2.55-.47 2.97zM19 25H5v-3h14v3z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="xing">
    <path d="M18.188 0c-.517 0-.741.325-.927.66 0 0-7.455 13.224-7.702 13.657.015.024 4.919 9.023 4.919 9.023.17.308.436.66.967.66h3.454c.211 0 .375-.078.463-.22.089-.151.089-.346-.009-.536l-4.879-8.916c-.004-.006-.004-.016 0-.022L22.139.756c.095-.191.097-.387.006-.535C22.056.078 21.894 0 21.686 0h-3.498zM3.648 4.74c-.211 0-.385.074-.473.216-.09.149-.078.339.02.531l2.34 4.05c.004.01.004.016 0 .021L1.86 16.051c-.099.188-.093.381 0 .529.085.142.239.234.45.234h3.461c.518 0 .766-.348.945-.667l3.734-6.609-2.378-4.155c-.172-.315-.434-.659-.962-.659H3.648v.016z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 71 55" id="discord">
    <path d="M60.1045 4.8978C55.5792 2.8214 50.7265 1.2916 45.6527 0.41542C45.5603 0.39851 45.468 0.440769 45.4204 0.525289C44.7963 1.6353 44.105 3.0834 43.6209 4.2216C38.1637 3.4046 32.7345 3.4046 27.3892 4.2216C26.905 3.0581 26.1886 1.6353 25.5617 0.525289C25.5141 0.443589 25.4218 0.40133 25.3294 0.41542C20.2584 1.2888 15.4057 2.8186 10.8776 4.8978C10.8384 4.9147 10.8048 4.9429 10.7825 4.9795C1.57795 18.7309 -0.943561 32.1443 0.293408 45.3914C0.299005 45.4562 0.335386 45.5182 0.385761 45.5576C6.45866 50.0174 12.3413 52.7249 18.1147 54.5195C18.2071 54.5477 18.305 54.5139 18.3638 54.4378C19.7295 52.5728 20.9469 50.6063 21.9907 48.5383C22.0523 48.4172 21.9935 48.2735 21.8676 48.2256C19.9366 47.4931 18.0979 46.6 16.3292 45.5858C16.1893 45.5041 16.1781 45.304 16.3068 45.2082C16.679 44.9293 17.0513 44.6391 17.4067 44.3461C17.471 44.2926 17.5606 44.2813 17.6362 44.3151C29.2558 49.6202 41.8354 49.6202 53.3179 44.3151C53.3935 44.2785 53.4831 44.2898 53.5502 44.3433C53.9057 44.6363 54.2779 44.9293 54.6529 45.2082C54.7816 45.304 54.7732 45.5041 54.6333 45.5858C52.8646 46.6197 51.0259 47.4931 49.0921 48.2228C48.9662 48.2707 48.9102 48.4172 48.9718 48.5383C50.038 50.6034 51.2554 52.5699 52.5959 54.435C52.6519 54.5139 52.7526 54.5477 52.845 54.5195C58.6464 52.7249 64.529 50.0174 70.6019 45.5576C70.6551 45.5182 70.6887 45.459 70.6943 45.3942C72.1747 30.0791 68.2147 16.7757 60.1968 4.9823C60.1772 4.9429 60.1437 4.9147 60.1045 4.8978ZM23.7259 37.3253C20.2276 37.3253 17.3451 34.1136 17.3451 30.1693C17.3451 26.225 20.1717 23.0133 23.7259 23.0133C27.308 23.0133 30.1626 26.2532 30.1066 30.1693C30.1066 34.1136 27.28 37.3253 23.7259 37.3253ZM47.3178 37.3253C43.8196 37.3253 40.9371 34.1136 40.9371 30.1693C40.9371 26.225 43.7636 23.0133 47.3178 23.0133C50.9 23.0133 53.7545 26.2532 53.6986 30.1693C53.6986 34.1136 50.9 37.3253 47.3178 37.3253Z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 17 18" id="mastodon">
    <path
    fill="#ffffff"
    d="m 15.054695,9.8859583 c -0.22611,1.1632697 -2.02517,2.4363497 -4.09138,2.6830797 -1.0774504,0.12856 -2.1382704,0.24673 -3.2694704,0.19484 -1.84996,-0.0848 -3.30971,-0.44157 -3.30971,-0.44157 0,0.1801 0.0111,0.35157 0.0333,0.51194 0.24051,1.82571 1.81034,1.93508 3.29737,1.98607 1.50088,0.0514 2.8373104,-0.37004 2.8373104,-0.37004 l 0.0617,1.35686 c 0,0 -1.0498104,0.56374 -2.9199404,0.66742 -1.03124,0.0567 -2.3117,-0.0259 -3.80308,-0.42069 -3.23454998,-0.85613 -3.79081998,-4.304 -3.87592998,-7.8024197 -0.026,-1.03871 -0.01,-2.01815 -0.01,-2.83732 0,-3.57732 2.34385998,-4.62587996 2.34385998,-4.62587996 1.18184,-0.54277 3.20976,-0.77101 5.318,-0.7882499985409 h 0.0518 C 9.8267646,0.01719834 11.856025,0.24547834 13.037775,0.78824834 c 0,0 2.34377,1.04855996 2.34377,4.62587996 0,0 0.0294,2.63937 -0.32687,4.47183"/>
 <path
    fill="#000000"
    d="m 12.616925,5.6916583 v 4.3315297 h -1.71607 V 5.8189683 c 0,-0.88624 -0.37289,-1.33607 -1.1187604,-1.33607 -0.82467,0 -1.23799,0.53361 -1.23799,1.58875 v 2.30122 h -1.70594 v -2.30122 c 0,-1.05514 -0.4134,-1.58875 -1.23808,-1.58875 -0.74587,0 -1.11876,0.44983 -1.11876,1.33607 v 4.2042197 h -1.71607 V 5.6916583 c 0,-0.88527 0.22541,-1.58876 0.67817,-2.10922 0.46689,-0.52047 1.07833,-0.78727 1.83735,-0.78727 0.87816,0 1.54317,0.33752 1.98288,1.01267 l 0.42744,0.71655 0.42753,-0.71655 c 0.43961,-0.67515 1.10463,-1.01267 1.9828704,-1.01267 0.75893,0 1.37037,0.2668 1.83735,0.78727 0.45268,0.52046 0.67808,1.22395 0.67808,2.10922"/>
  </symbol>
</svg>

<footer class="footer">
  <div class="footer_inner wrap pale">
    <img src='https://luoguochun.cn/icons/apple-touch-icon.png' class="icon icon_2 transparent" alt="BUF1024">
    <p>Copyright&nbsp;2011-&nbsp;<span class="year"></span>&nbsp;BUF1024. All Rights Reserved</p><a class="to_top" href="#documentTop">
  <svg class="icon">
  <title>to-top</title>
  <use xlink:href="#to-top"></use>
</svg>

</a>

  </div>
</footer>

<script type="text/javascript" src="https://luoguochun.cn/zh-cn/js/bundle.884eccc71c2848fb4aeb15945329b5a857717f0313da00cb46b765b5734cfa64b08ce2609627167129c2de17d9b47ed210682f96a2502ebb3aadc73191740211.js" integrity="sha512-iE7MxxwoSPtK6xWUUym1qFdxfwMT2gDLRrdltXNM&#43;mSwjOJglicWcSnC3hfZtH7SEGgvlqJQLrs6rccxkXQCEQ==" crossorigin="anonymous"></script>
</body>

</html>
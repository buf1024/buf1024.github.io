<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>vcs on BUF1024!!!</title>
    <link>https://luoguochun.cn/categories/vcs/</link>
    <description>Recent content in vcs on BUF1024!!!</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>Copyletf buf2024</copyright>
    <lastBuildDate>Mon, 10 Oct 2016 14:46:23 +0000</lastBuildDate><atom:link href="https://luoguochun.cn/categories/vcs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>git 版本控制</title>
      <link>https://luoguochun.cn/post/2016-10-10-git-toilet-book/</link>
      <pubDate>Mon, 10 Oct 2016 14:46:23 +0000</pubDate>
      
      <guid>https://luoguochun.cn/post/2016-10-10-git-toilet-book/</guid>
      <description>&lt;h3 id=&#34;简介&#34;&gt;简介 &lt;a href=&#34;#%e7%ae%80%e4%bb%8b&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;git，是目前最流行的版本控制系统，没有之一。git作为分布式版本控制系统，与其他集中式版本控制系统(如svn)的一个重要区别是，git &lt;code&gt;clone&lt;/code&gt;的是整个完整版本仓库，在git目录中&lt;code&gt;.git&lt;/code&gt;目录为仓库目录，这里记录了仓库的所有信息。git对于每一个版本，存储的是整个系统的一个快照(未改变内容，使用指针引用)，而不是版本之间的差异。因为这种存储方式，git在创建分支时非常快，只需要简单的用指针引用对应的版本即可(典型的空间换时间)。git的存储数据，提交信息，分支信息，标签信息等都使用&lt;code&gt;SHA1&lt;/code&gt;计算校验和以及用作引用使用，这使得git有非常强的保持完整性的特征。在git的概念中，文件分为&lt;strong&gt;未跟踪&lt;/strong&gt;和&lt;strong&gt;已跟踪&lt;/strong&gt; 两种，对于&lt;strong&gt;已跟踪&lt;/strong&gt;的文件，存在三种状态：&lt;strong&gt;已提交(committed)&lt;/strong&gt;，&lt;strong&gt;已修改(modified)&lt;/strong&gt;，&lt;strong&gt;已暂存(staged)&lt;/strong&gt;。这三种状态分别对应三个工作区域：git仓库，工作目录，暂存区域。
git使用&lt;code&gt;git config&lt;/code&gt;来进制配置git。git的配置存在于三个地方：/etc/gitconfig(针对所有用户的配置，使用&amp;ndash;system选项读写), ~/.gitconfig或~/.config/git/config(针对当前用户，使用&amp;ndash;global读写), git项目的.git/config(针对当前项目)。三个配置的地方，最细一级的配置覆盖上一级的配置。对于新安装的git，最基本需要配置&lt;code&gt;user.name&lt;/code&gt;和&lt;code&gt;user.email&lt;/code&gt;这两个配置，因为git项目的几乎所有的操作都会用的这两个信息。&lt;/p&gt;
&lt;h3 id=&#34;基本操作&#34;&gt;基本操作 &lt;a href=&#34;#%e5%9f%ba%e6%9c%ac%e6%93%8d%e4%bd%9c&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;git config&lt;/code&gt;读取或写入配置。
&lt;code&gt;git help&lt;/code&gt;查看帮助。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git init&lt;/code&gt;或&lt;code&gt;git clone [url] [alias]&lt;/code&gt;初始化git仓库,前者为创建一个新的git仓库，后者为克隆一个已有的仓库。初始化仓库会创建一个&lt;code&gt;.git&lt;/code&gt;的目录，仓库的默认分支为&lt;code&gt;master&lt;/code&gt;，远程仓库的默认为&lt;code&gt;origin&lt;/code&gt;。
&lt;code&gt;git status&lt;/code&gt;查看当前工作目录文件的状态，并提示相关操作。简洁显示方式为&lt;code&gt;git status -s&lt;/code&gt;或&lt;code&gt;git status --short&lt;/code&gt;
&lt;code&gt;git add&lt;/code&gt; 将文件添加到暂存区，以待下一步进行提交。若要取消暂存区文件的提交，则可用&lt;code&gt;git reset HEAD&lt;/code&gt;进行取消。若想丢弃本地目录修改，则可使用&lt;code&gt;git checkout -- &lt;/code&gt;。&lt;code&gt;git add -i&lt;/code&gt;加上这个参数后，可以进行交互式操作。对于无需要跟踪或文件或目录，在git项目目录增加&lt;code&gt;.gitignore&lt;/code&gt;文件，&lt;code&gt;gitignore&lt;/code&gt;文件格式：1) 所有空行或者以 # 开头的行都会被 Git 忽略。 2) 可以使用标准的 glob 模式匹配。3) 匹配模式可以以(/)开头防止递归。4) 匹配模式可以以(/)结尾指定目录。5) 要忽略指定模式以外的文件或目录,可以在模式前加上惊叹号(!)取反。
&lt;code&gt;git diff&lt;/code&gt;可查看未暂存区和暂存去文件的差异，如果想查看暂存区和上次提交的仓库差异，使用&lt;code&gt;git diff --staged&lt;/code&gt;或&lt;code&gt;git diff --cached&lt;/code&gt;。可使用&lt;code&gt;git difftool&lt;/code&gt;使用差异分析软件分析差异。
&lt;code&gt;git commit&lt;/code&gt;将暂存区内容提交到仓库。如果需要跳过暂存区，直接提交到仓库，使用&lt;code&gt;git commit -a&lt;/code&gt;，该选项只针对已经跟踪的文件有效。如果提交时，发现少提交了几个文件或做了修改，想修正上次提交信息，进行相关操作后，使用&lt;code&gt;git commit -amend&lt;/code&gt;。
&lt;code&gt;git rm&lt;/code&gt;将仓库和本地的文件删掉，如果需要保存本地文件，则可使用&lt;code&gt;git rm --cached&lt;/code&gt;，删除的文件将不再纳入版本控制。
&lt;code&gt;git mv&lt;/code&gt;将文件改名，只是改变&lt;code&gt;tree&lt;/code&gt;对象的信息。
&lt;code&gt;git clean&lt;/code&gt;清清理工作目录，可使用&lt;code&gt;git clean -i&lt;/code&gt;选项交互操作。
&lt;code&gt;git log&lt;/code&gt;查看提交历史，支持多种参数格式。
&lt;code&gt;git tag&lt;/code&gt;打标签，有两种类型标签，轻量级的标签，和带附注的。删除标签使用&lt;code&gt;git tag -d &amp;lt;标签明&amp;gt;&lt;/code&gt;。分享标签到远程分支可使用&lt;code&gt;git push origin &amp;lt;标签名&amp;gt;&lt;/code&gt;或&lt;code&gt;git push origin --tags&lt;/code&gt;将所有的标签都推送。如果需要删除远程标签可使用&lt;code&gt;git push origin :refs/tags/&amp;lt;标签名&amp;gt;&lt;/code&gt;。标签并不能像分支一样被&lt;code&gt;checkout&lt;/code&gt;，如需要，则需要先创建标签对应的分支。
&lt;code&gt;git remote add &amp;lt;shortname&amp;gt; &amp;lt;url&amp;gt;&lt;/code&gt;增加远程仓库。&lt;code&gt;git remote -v&lt;/code&gt;查看远程仓库。&lt;code&gt;git remote show origin&lt;/code&gt;可以查看到更加详细的信息。&lt;code&gt;git remote rename&lt;/code&gt;远程仓库重命名。&lt;code&gt;git remote rm&lt;/code&gt;删除远程仓库。&lt;code&gt;git fetch&lt;/code&gt;抓取远程仓库，但并不进行合并。&lt;code&gt;git pull&lt;/code&gt;抓取远程仓库，并进行合并。&lt;code&gt;git push&lt;/code&gt;提交本地修改到远程仓库。
&lt;code&gt;git reflog&lt;/code&gt; 显示&lt;code&gt;HEAD&lt;/code&gt;引用的变化日志。
&lt;code&gt;git stash&lt;/code&gt;，如果不想对当前的分支进行提交，但是又想切换到其他分支，可以使用该命令，改命令是将当前的修改先保存起来。&lt;code&gt;git stash list&lt;/code&gt;可以显示存起来的内容。&lt;code&gt;git stash apply&lt;/code&gt;进行恢复。&lt;/p&gt;
&lt;p&gt;分支被称之为git的杀手锏，因为它创建一个分支出奇的快。创建分支使用&lt;code&gt;git branch &amp;lt;分支名&amp;gt;&lt;/code&gt;(不带参数为列车所有分支)，创建分支即是创建一个引用指向一个&lt;code&gt;commit&lt;/code&gt;对象，所以特别快。切换分支使用&lt;code&gt;git checkout &amp;lt;分支名&amp;gt;&lt;/code&gt;，切换分支，即是简单的将&lt;code&gt;HEAD&lt;/code&gt;指针指向对应的分支，所以也非常快。
远程分支使用&lt;code&gt;git remote show &amp;lt;remote name&amp;gt;&lt;/code&gt;可以查看，远程分支跟踪是对远程分支状态的引用。向远程仓库分享分支使用&lt;code&gt;git push origin &amp;lt;分支名&amp;gt;&lt;/code&gt;，如果不想远程分支和本地分支有同样的名称，使用&lt;code&gt;git push origin &amp;lt;本地分支名:远程分支名&amp;gt;&lt;/code&gt;。当从远程仓库抓取远程分支时，git不会自动在本地创建远程分支的副本。使用&lt;code&gt;git checkout -b &amp;lt;本地分支名&amp;gt; &amp;lt;远程分支名&amp;gt;&lt;/code&gt;,从远程分支创建分支。跟踪一个分支使用&lt;code&gt;git checkout --track &amp;lt;远程分支名&amp;gt;&lt;/code&gt;，对已有的分支进行跟踪使用&lt;code&gt;git branch -u &amp;lt;远程分支名&amp;gt;&lt;/code&gt;(或&lt;code&gt;--set-up-stream-to&lt;/code&gt;选项)，这样可以&lt;code&gt;git pull&lt;/code&gt;时直接从远程分支抓取。删除一个远程分支&lt;code&gt;git push origin --delete &amp;lt;分支名&amp;gt;&lt;/code&gt;。
分支合并的方式有两种，一种是&lt;code&gt;git merge&lt;/code&gt;，另外一种是&lt;code&gt;git rebase&lt;/code&gt;。对于任何一种方式，都可以加上&lt;code&gt;--abort&lt;/code&gt;参数进行合并的取消。先看第一种方式，&lt;code&gt;git merge&lt;/code&gt;:
对于要合并的分支在同一条线上，被合并的分支比较前，这种情况比较简单。如：
&lt;img src=&#34;https://luoguochun.cn/img/vcs/git-merge-fastforward.png&#34; alt=&#34;git fast-forward&#34;&gt;
将&lt;code&gt;hotfix&lt;/code&gt;合并到&lt;code&gt;master&lt;/code&gt;分支：&lt;code&gt;git merge master hotfix&lt;/code&gt;。由于&lt;code&gt;hotfix&lt;/code&gt;在&lt;code&gt;master&lt;/code&gt;前，直接将&lt;code&gt;master&lt;/code&gt;指向&lt;code&gt;hotfix&lt;/code&gt;所值的&lt;code&gt;commit&lt;/code&gt;对象即可，这种合并方式称为&lt;code&gt;fast forward&lt;/code&gt;。合并后：
&lt;img src=&#34;https://luoguochun.cn/img/vcs/git-merged-fastforward.png&#34; alt=&#34;git fast-forward 完成&#34;&gt;
对于要合并的分支不在同一条线上，这种方式相对复杂点。如：
&lt;img src=&#34;https://luoguochun.cn/img/vcs/git-merge-normal.png&#34; alt=&#34;git 合并&#34;&gt;
将&lt;code&gt;iss53&lt;/code&gt;合并到&lt;code&gt;master&lt;/code&gt;分支：&lt;code&gt;git merge master iss53&lt;/code&gt;。git需要计算两个分支的共同祖先，和各个分支的&lt;code&gt;HEAD&lt;/code&gt;指针，然后做3方的对比，产生一个新的快照。合并后：
&lt;img src=&#34;https://luoguochun.cn/img/vcs/git-merged-normal.png&#34; alt=&#34;git 合并完成&#34;&gt;
另外一种合并的方式是：&lt;code&gt;git rebase&lt;/code&gt;。由以上&lt;code&gt;merge&lt;/code&gt;可看出，由多少条分支就由多少条历史，&lt;code&gt;rebase&lt;/code&gt;的目的是为了有更少更清晰的提交历史。如:
&lt;img src=&#34;https://luoguochun.cn/img/vcs/git-rebase.png&#34; alt=&#34;git rebase&#34;&gt;
先对&lt;code&gt;experiment&lt;/code&gt;分进行&lt;code&gt;rebase&lt;/code&gt;：&lt;code&gt;git rebase experiment master&lt;/code&gt;。git取出C4和C3的补丁，然后在C3那里进行一次合并，生成快照C4&amp;rsquo;，再在&lt;code&gt;master&lt;/code&gt;分支上面进行一次&lt;code&gt;fast forward&lt;/code&gt;合并：&lt;code&gt;git merge master experiment&lt;/code&gt;。合并后：
&lt;img src=&#34;https://luoguochun.cn/img/vcs/git-rebased.png&#34; alt=&#34;git rebase完成&#34;&gt;
可以看到，进行&lt;code&gt;rebase&lt;/code&gt;后，分支信息没有了。所以，请注意，&lt;strong&gt;千万不要在共同协作的仓库里面使用&lt;code&gt;rebase&lt;/code&gt;&lt;/strong&gt;
合并的过程中，不可避免的产出冲突。当合并产生冲突时，&lt;code&gt;git status&lt;/code&gt;可以看到冲突的状态。在冲突的文件里面，git会在冲突的文件中加入标志的冲突标记，需要手工解决冲突，并进行提交方可认为冲突解决了。对于冲突的文件，git使用一种特殊语法查看冲突文件，Stage 1 是它们共同的祖先版本,stage 2 是你的版本,stage 3 来自于 MERGE_HEAD,即你将要合并入的版本(“theirs”)。如：&lt;code&gt;git show :1:test.yy&lt;/code&gt;, &lt;code&gt;git show :2:test.yy&lt;/code&gt;和&lt;code&gt;git show :3:test.yy&lt;/code&gt;分别显示公共祖先版本，本地目录版本，和将要合并的版本。当合并后，使用&lt;code&gt;git diff --ours&lt;/code&gt;比较合并文件和本地文件差异，&lt;code&gt;git diff --theirs&lt;/code&gt;比较合并后文件和要合并的版本的差异。也可以使用&lt;code&gt;git mergetool&lt;/code&gt;启动外部合并工具进行合并。&lt;/p&gt;
&lt;p&gt;注意，这里的基本操作不包括git的全部。&lt;/p&gt;
&lt;h3 id=&#34;内部原理&#34;&gt;内部原理 &lt;a href=&#34;#%e5%86%85%e9%83%a8%e5%8e%9f%e7%90%86&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;git又称为内容寻址系统，因为它计算出“内容”的SHA1，然后用这个SHA1作为键来索引内容。对于一个新建的git仓库目录，它的仓库目录&lt;code&gt;.git&lt;/code&gt;目录如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    HEAD config* description hooks/
    info/ objects/ refs/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于一个已经存在的目录，还可能存在&lt;code&gt;COMMIT_EDITMSG FETCH_HEAD ORIG_HEAD&lt;/code&gt;等文件(含义为最近一次提交信息，&lt;code&gt;git fetch&lt;/code&gt;远程仓库的&lt;code&gt;HEAD&lt;/code&gt;，远程参考的&lt;code&gt;HEAD&lt;/code&gt;)或其他目录。 &lt;code&gt;config&lt;/code&gt;目录包括针对仓库的配置信息，&lt;code&gt;description&lt;/code&gt;是提供给GitWeb程序使用的，&lt;code&gt;HEAD&lt;/code&gt;文件标示当前分支的&lt;code&gt;HEAD&lt;/code&gt;指针，&lt;code&gt;index&lt;/code&gt;包括暂存区的数据，&lt;code&gt;objects/&lt;/code&gt;目录包括了仓库数据信息，&lt;code&gt;refs/&lt;/code&gt;目录包括数据提交对象(如分支，标签，远程仓库标签分支，head引用等)的引用。在git内部，包括4种对象：&lt;code&gt;blob tree commit tag&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;blob&lt;/code&gt;对象
存储文件内容数据的&lt;code&gt;blob&lt;/code&gt;对象。使用git的底层命令&lt;code&gt;hash-object&lt;/code&gt;可以写入命令，&lt;code&gt;cat-file&lt;/code&gt;可以读回，如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  heidong@HEIDONG:~/tmp/mygit-repo$ echo &amp;quot;hello, git world!&amp;quot; | git hash-object -w --stdin
  76f2ae3955bfd0b4e9e6260a0e48a001c9336f2b
  heidong@HEIDONG:~/tmp/mygit-repo$ git cat-file -p 76f2ae3955bfd0b4e9e6260a0e48a001c9336f2b
  hello, git world!
  heidong@HEIDONG:~/tmp/mygit-repo$ git cat-file -t 76f2ae3955bfd0b4e9e6260a0e48a001c9336f2b
  blob
  heidong@HEIDONG:~/tmp/mygit-repo$ ls .git/objects/76/f2ae3955bfd0b4e9e6260a0e48a001c9336f2b 
  .git/objects/76/f2ae3955bfd0b4e9e6260a0e48a001c9336f2b
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;blob&lt;/code&gt;对象的存储也是比较简单的，git为每个对象添加一个头信息，存储的格式为：头信息+内容。头信息的格式为：&lt;code&gt;blob 内容长度\0&lt;/code&gt;。git将这些信息组装完毕后，进行压缩，然后存储的&lt;code&gt;objects&lt;/code&gt;目录里面(在目录内部，取SHA1的前两个字母作为父目录，后面字母作为子目录文件名)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;tree&lt;/code&gt;对象
&lt;code&gt;blob&lt;/code&gt;对象存储的是数据的内容，并没有存储文件的文件名，权限等信息。git采用的解决办法是类似*NIX系统的文件系统类似的方式，类似于&lt;code&gt;inode&lt;/code&gt;，但有所简化，包括了文件名称，类型，权限，其他&lt;code&gt;tree&lt;/code&gt;对象，&lt;code&gt;blob&lt;/code&gt;对象引用等等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;commit&lt;/code&gt;对象
当保存一个仓库的快照时(提交)，需要标明提交者信息，提交信息，提交的文件文件等，这是通过提交对象提交的。&lt;code&gt;commit&lt;/code&gt;对象通常指向一个&lt;code&gt;tree&lt;/code&gt;对象，&lt;code&gt;commit&lt;/code&gt;对象可供&lt;code&gt;git log&lt;/code&gt;提取提交信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;tag&lt;/code&gt;对象
&lt;code&gt;tag&lt;/code&gt;对象类似于&lt;code&gt;commit&lt;/code&gt;对象，与&lt;code&gt;commit&lt;/code&gt;对象不同的是，&lt;code&gt;tag&lt;/code&gt;对象通常指向一个&lt;code&gt;commit&lt;/code&gt;对象。&lt;code&gt;tag&lt;/code&gt;对象如果是轻量级标签，直接指向&lt;code&gt;commit&lt;/code&gt;对象，否则，带上提交信息，注解信息等，指向一个&lt;code&gt;commit&lt;/code&gt;对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;git作为内容寻址系统，键为SHA1，要记住这个键或者记住这个键的一部分，是非常困难的，git的解决办法是采用名字引用的方式，这个名字引用的数据就存在&lt;code&gt;refs&lt;/code&gt;目录下面。如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    heidong@HEIDONG:~/tmp/mygit-repo/.git$ find refs/ -print
    refs/
    refs/tags
    refs/tags/v1.0
    refs/heads
    refs/heads/master
    refs/heads/devel
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;经过历次操作后，假设一下图:
&lt;img src=&#34;https://luoguochun.cn/img/vcs/git-internal.png&#34; alt=&#34;git 原理&#34;&gt;
该图的含义是(注意，这里每次提交，&amp;ldquo;master&amp;quot;指针总指向最新提交)：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建文件&amp;quot;test.txt&amp;rdquo;，其内容为&amp;quot;version 1&amp;quot;，并提交到仓库，提交信息为&amp;quot;first commit&amp;quot;&lt;/li&gt;
&lt;li&gt;创建文件&amp;quot;new.txt&amp;quot;，其内容为&amp;quot;new file&amp;quot;，修改&amp;quot;test.txt&amp;quot;文件的内容为&amp;quot;version 2&amp;quot;，并提交到仓库，提交信息为&amp;quot;second commit&amp;quot;, 提交后，创建分支&amp;quot;test&amp;quot;。&lt;/li&gt;
&lt;li&gt;创建目录&amp;quot;bak&amp;quot;，&amp;ldquo;bak&amp;quot;目录包含文件&amp;quot;test.txt&amp;rdquo;，文件内容为&amp;quot;version 1&amp;quot;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果仓库中存在一个比较大的文件，而每次进行修改至少修改那么丁点数据的话，那么在git仓库里面将会保存大量的快照，比较占用空间。git使用&lt;code&gt;git gc&lt;/code&gt;命令，进行仓库的压缩，把对象进行压缩增量存储的方式，并把相关信息存储在&lt;code&gt;objects/info/ objects/pack/&lt;/code&gt;目录下面。&lt;/p&gt;
&lt;h3 id=&#34;其他&#34;&gt;其他 &lt;a href=&#34;#%e5%85%b6%e4%bb%96&#34; class=&#34;anchor&#34;&gt;🔗&lt;/a&gt;&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;关某些系统中午乱码解决办法
1.1 git配置修改&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; [gui]
 encoding = utf-8 #代码库统一用urf-8,在git gui中可以正常显示中文
 [i18n]
 commitencoding = GB2312 #log编码，window下默认gb2312,声明后发到服务器才不会乱码
 [svn]
 pathnameencoding = GB2312 #支持中文路径
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1.2 /etc/git-completion.bash修改&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    alias ls=&#39;ls --show-control-chars --color=auto&#39;  #ls能够正常显示中文
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1.3 /etc/inputrc修改&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    set output-meta on   #bash中可以正常输入中文
    set convert-meta off
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1.4 /etc/profile修改&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    export LESSCHARSET=utf-8   #$ git log 命令不像其它 vcs 一样，n 条 log 从头滚到底，它会恰当地停在第一页，按 space 键再往后翻页。这是通过将 log 送给 less 处理实现的。以上即是设置 less 的字符编码，使得 $ git log 可以正常显示中文。
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;使用配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; [alias]
 lg = log --color --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&amp;lt;%ce&amp;gt;%Creset&#39; --abbrev-commit #带颜色输出日志
 # 简写
 st = status -s
 br = branch
 co = checkout
 cm = commit
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;github上fork项目，如何同步原始的项目&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1. 首先要先确定一下是否建立了主repo的远程源：
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   git remote -v
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2. 如果里面只能看到你自己的两个源(fetch 和 push)，那就需要添加主repo的源：
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   git remote add upstream URL
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   git remote -v
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;3. 然后你就能看到upstream了。如果想与主repo合并：
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   git fetch upstream
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   git merge upstream/master
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;完。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
